<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>递归详解</title>
      <link href="/2020/08/24/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/08/24/%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="递归解题步骤"><a href="#递归解题步骤" class="headerlink" title="递归解题步骤"></a>递归解题步骤</h3><ul><li>当前层进行处理</li><li>分派给下一层（if……else……根据不同的情况进行分派。if……else……进行剪枝。）</li><li>当前层处理从下一层返回的结果（对返回的结果进行加减乘除算数运算或者与或非逻辑运算等等，有时还要与当前层的处理结果一并进行处理）</li><li>返回给上一层（return）</li></ul><p>当递归的返回值是void时，解题步骤只需包含前两步就足够了。当递归有返回值时，需要包含完整的四步骤。</p><h3 id="递归的有效性"><a href="#递归的有效性" class="headerlink" title="递归的有效性"></a>递归的有效性</h3><p>递归函数每一层看起来只做了很少的事。但是，由于递归函数中经常多次调用自身，递归函数的传销模式其实是很可怕的，假设一个递归中调用自身两次，那么这已经是一个细胞分裂级别的指数增长，即便每个节点什么也不处理，只是单纯的分派给下一层，当到了最后一层时，不得不在结束条件时进行处理，这时候 的节点已经非常之多，每个节点只需做很少的事，整体上就可以完成一个很宏伟的事。</p><h3 id="记忆化递归的必要性"><a href="#记忆化递归的必要性" class="headerlink" title="记忆化递归的必要性"></a>记忆化递归的必要性</h3><p>同样由于递归的传销模式，当某次分派出现重复子问题时，意味着这个重复的子问题并非被重复计算一次，而是很多次，所以需要记忆化递归解决这种重复子问题。</p><ul><li>记忆化递归很好理解，就是将每次递归函数的<参数，返回值>对应存起来，可以用数组，也可以用map，根据题目要求灵活选取。</li></ul><h3 id="递归函数的执行顺序"><a href="#递归函数的执行顺序" class="headerlink" title="递归函数的执行顺序"></a>递归函数的执行顺序</h3><p>想象给你一颗解空间树，从根节点开始，一笔画将所有节点连接起来，最后返回根节点。</p><p>那么一笔画连接的顺序其实就是递归函数的执行顺序。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux学习笔记</title>
      <link href="/2020/07/17/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/07/17/linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h4 id="configure-prefix"><a href="#configure-prefix" class="headerlink" title="./configure  prefix="></a>./configure  prefix=</h4><p>configure文件是一个可执行的脚本文件，它有很多选项，在待安装的源码目录下使用命令./configure –help可以输出详细的选项列表。其中—prefix选项是配置安装目录。</p><ul><li><p>如果不配置该选项，安装后可执行文件默认放在/usr /local/bin，库文件默认放在/usr/local/lib，配置文件默认放在/usr/local/etc，其它的资源文件放在/usr /local/share，比较凌乱。</p></li><li><p>如果配置了—prefix，如：$ ./configure —prefix=/usr/local/test</p><p>安装后的所有资源文件都会被放在/usr/local/test目录中，不会分散到其他目录。</p></li></ul><h4 id="rpm-npm"><a href="#rpm-npm" class="headerlink" title="rpm npm"></a>rpm npm</h4><ul><li><p>RPM 是Red-Hat Package Manager（RPM软件包管理器）的缩写，这一文件格式名称虽然打上了RedHat的标志，但是其原始设计理念是开放式的，包括OpenLinux、S.u.S.E.以及Turbo Linux等Linux的分发版本都有采用，可以算是公认的行业标准了。</p></li><li><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题。新版的nodejs已经集成了npm。</p></li></ul><h4 id="程序终止与挂起"><a href="#程序终止与挂起" class="headerlink" title="程序终止与挂起"></a>程序终止与挂起</h4><ul><li><p>ctrl+c 强制中断程序的执行，终止进程</p></li><li><p>ctrl+z 将任务暂停，挂起，fg将其再次调到前台运行，bg将其在后台静默运行</p></li><li>先 <code>ps aux | grep  进程名</code> 看一下进程号，然后 <code>kill -9  进程号</code> 结束进程</li></ul><h4 id="以d结尾的程序"><a href="#以d结尾的程序" class="headerlink" title="以d结尾的程序"></a>以d结尾的程序</h4><p>d表示daemon 守护进程的意思，在linux中，很多服务以点d结尾，如 mysqld ,firewalld，httpd</p><h4 id="chkconfig（check-config）"><a href="#chkconfig（check-config）" class="headerlink" title="chkconfig（check config）"></a>chkconfig（check config）</h4><p>管理系统服务在不同运行级别启动与停止的工具。</p><ul><li>chkconfig —list [name] 　　 服务列表[可根据实际需要,停掉不用服务]</li><li>chkconfig —add [name] 　　服务添加[如缺省，则从缺省的init脚本自动建立]</li><li>chkconfig —del [name] 　　 服务删除[并把相关符号连接从/etc/rc[0-6].d删除]</li></ul><p>运行级别分为7个挡位。表示在不同级别下的运行状态是on还是off。所以千万不用讲运行级别设置为0,6; 最常用的就是2,3,5。</p><ul><li>0 - 停机</li><li>1 - 单用户模式</li><li>2 - 多用户，没有NFS</li><li>3 - 完全多用户模式(标准的运行级)</li><li>4 - 没有用到</li><li>5 - X11(xwindow)</li><li>6 - 重新启动</li></ul><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><p>管理服务启动和关闭的工具</p><ul><li>service    服务 start</li><li>service    服务  stop</li><li>service    服务  status  </li></ul><h4 id="systemctl-（ctl-control）"><a href="#systemctl-（ctl-control）" class="headerlink" title="systemctl （ctl=control）"></a>systemctl （ctl=control）</h4><p>systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。</p><ul><li>启动一个服务：systemctl start firewalld.service</li><li>关闭一个服务：systemctl stop firewalld.service</li><li>重启一个服务：systemctl restart firewalld.service</li><li>显示一个服务的状态：systemctl status firewalld.service</li><li>在开机时启用一个服务：systemctl enable firewalld.service</li><li>在开机时禁用一个服务：systemctl disable firewalld.service</li><li>查看服务是否开机启动：systemctl is-enabled firewalld.service</li><li>查看已启动的服务列表：systemctl list-unit-files|grep enabled</li><li>查看启动失败的服务列表：systemctl —failed</li></ul><h4 id="防火墙管理"><a href="#防火墙管理" class="headerlink" title="防火墙管理"></a>防火墙管理</h4><ul><li>添加端口:   firewall-cmd —zone=public —add-port=80/tcp —permanent   （—permanent永久生效，没有此参数重启后失效）</li><li>删除端口：firewall-cmd —zone= public —remove-port=80/tcp —permanent</li><li>查看端口：firewall-cmd —zone= public —query-port=80/tcp</li><li>查看所有打开的端口： firewall-cmd —zone=public —list-ports</li><li>更新防火墙规则： firewall-cmd —reload</li><li>查看版本： firewall-cmd —version</li><li>查看帮助： firewall-cmd —help</li><li>显示状态： firewall-cmd —state</li><li>查看区域信息:  firewall-cmd —get-active-zones</li><li>查看指定接口所属区域： firewall-cmd —get-zone-of-interface=eth0</li><li>拒绝所有包：firewall-cmd —panic-on</li><li>取消拒绝状态： firewall-cmd —panic-off</li><li>查看是否拒绝： firewall-cmd —query-panic</li></ul><h4 id="文件和目录颜色"><a href="#文件和目录颜色" class="headerlink" title="文件和目录颜色"></a>文件和目录颜色</h4><ul><li>绿色：可执行文件 （chmod +x  就可以把文件变成可执行）</li><li>蓝色：目录</li><li>红色：压缩文件</li><li>白色：普通文件</li><li>浅蓝色：链接文件</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell脚本学习之路</title>
      <link href="/2020/07/17/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/"/>
      <url>/2020/07/17/shell%E8%84%9A%E6%9C%AC%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h4 id="shell脚本第一行"><a href="#shell脚本第一行" class="headerlink" title="shell脚本第一行"></a>shell脚本第一行</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#! /bin/bash</span><br><span class="line">通常作为shell脚本的第一行，#！是一个约定的标记，表示找个脚本用哪个解释器来执行</span><br></pre></td></tr></tbody></table></figure></div><h4 id="shell变量"><a href="#shell变量" class="headerlink" title="shell变量"></a>shell变量</h4><ul><li>定义变量时，使用等号，变量名=变量值，注意等号左右不能有空格</li><li>使用变量时，在变量名前加$符号</li><li>readonly 命令可以将一个变量变成只读变量，之后就不可以再对该变量重新赋值</li><li>unset 命令用于删除变量（如果变量是只读的，那就不可删除）</li></ul><h4 id="shell数据类型"><a href="#shell数据类型" class="headerlink" title="shell数据类型"></a>shell数据类型</h4><ul><li><p>shell中有三种数据类型：字符串，数字，数组。</p></li><li><p>shell中的数据类型默认是字符串类型。也就是不能当作数字进行运算。</p></li><li>如果想要进行运算，可以用 $[运算式] 或者 $ ((运算式))</li><li>shell中支持一维数组，并用括号表示数组，数组中的元素用空格分离：数组名=（值1 值2 值3），读取和赋值时也是用下标。使用@或者*可以获取数组中所有元素</li></ul><h4 id="shell运算符"><a href="#shell运算符" class="headerlink" title="shell运算符"></a>shell运算符</h4><p>shell支持多种运算符，如算数运算符，关系运算符，布尔运算符，字符串运算符，文件测试运算符</p><ul><li><p>原生bash不支持数学运算，一般借助于 expr,如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">shell</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight shell"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">注意表达式和运算符之间要有空格</span></span><br><span class="line">val=`expr 2 + 2`</span><br></pre></td></tr></tbody></table></figure></div></li><li><p>其他的运算符就不写了，看见了应该能认识</p></li></ul><h4 id="shell程序控制"><a href="#shell程序控制" class="headerlink" title="shell程序控制"></a>shell程序控制</h4><h4 id="shell-函数和参数"><a href="#shell-函数和参数" class="headerlink" title="shell 函数和参数"></a>shell 函数和参数</h4></body></html>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的刷题笔记</title>
      <link href="/2020/07/16/%E6%88%91%E7%9A%84%E5%88%B7%E9%A2%98%E7%A7%98%E7%B1%8D/"/>
      <url>/2020/07/16/%E6%88%91%E7%9A%84%E5%88%B7%E9%A2%98%E7%A7%98%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>程序有顺序，判断，循环三种结构，而循环正是程序的精髓，电脑能够取代人力，最主要的就是因为程序能够做一些重复的事情，而这一切都离不开循环结构。</p><p>在做算法题时，不管我们准备对数据执行哪些操作，通常要先对数据进行遍历 ,而不同的数据结构又有不同的遍历方式，熟练掌握遍历是开始编程的第一步。以下总结了几种数据结构的遍历方式：</p><h4 id="对数组进行遍历"><a href="#对数组进行遍历" class="headerlink" title="对数组进行遍历"></a>对数组进行遍历</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对数组进行遍历一般会给一个数组nums</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i<nums.length;i++){< span><br><span class="line">}</span><br></nums.length;i++){<></span></pre></td></tr></tbody></table></figure></div><h4 id="对链表进行遍历"><a href="#对链表进行遍历" class="headerlink" title="对链表进行遍历"></a>对链表进行遍历</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对链表进行遍历一般会给一个链表的头head(其实就相当于数组遍历中的nums)</span></span><br><span class="line">Node idx = head;</span><br><span class="line"><span class="comment">//循环结束的条件</span></span><br><span class="line"><span class="keyword">while</span>(idx!=<span class="keyword">null</span>){</span><br><span class="line">    <span class="comment">//循环的索引变更</span></span><br><span class="line">    idx=idx.next;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h4 id="对树进行遍历"><a href="#对树进行遍历" class="headerlink" title="对树进行遍历"></a>对树进行遍历</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">TreeNode idx=root;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(idx)</span></span>{</span><br><span class="line">    <span class="comment">//循环结束的条件</span></span><br><span class="line">    <span class="keyword">if</span>(idx==<span class="keyword">null</span>){</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    <span class="comment">//如果idx!=null:循环的索引变更</span></span><br><span class="line">    DFS(idx.left);</span><br><span class="line">    DFS(idx.right);</span><br><span class="line">}</span><br><span class="line"><span class="comment">//对树的遍历和对链表和数组遍历的最大的不同，就在于对数的遍历的路径是分叉的，在每一轮的循环中索引都要增加且分叉，循环结束的路径也不是一个，而是在多条路径处都要结束</span></span><br></pre></td></tr></tbody></table></figure></div><h4 id="对数字的位进行遍历"><a href="#对数字的位进行遍历" class="headerlink" title="对数字的位进行遍历"></a>对数字的位进行遍历</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(num!=<span class="number">0</span>){<span class="comment">//遍历结构,这里写的是遍历到头，其实可以改条件达到半路截胡的效果</span></span><br><span class="line">    whatwewant=num%<span class="number">10</span>;<span class="comment">//我们想要的每一位</span></span><br><span class="line">    num=num/<span class="number">10</span>;<span class="comment">//遍历结构</span></span><br><span class="line">}<span class="comment">///遍历结构</span></span><br></pre></td></tr></tbody></table></figure></div><h4 id="对数字的比特位进行遍历"><a href="#对数字的比特位进行遍历" class="headerlink" title="对数字的比特位进行遍历"></a>对数字的比特位进行遍历</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(num!=<span class="number">0</span>){<span class="comment">//遍历结构</span></span><br><span class="line">    whatwewant=num&<span class="number">1</span>;<span class="comment">//我们想要的每一比特位</span></span><br><span class="line">    num=num>><span class="number">1</span>;<span class="comment">///遍历结构</span></span><br><span class="line">}<span class="comment">//遍历结构</span></span><br></pre></td></tr></tbody></table></figure></div><h4 id="对列表进行遍历"><a href="#对列表进行遍历" class="headerlink" title="对列表进行遍历"></a>对列表进行遍历</h4><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i<list.size(); i++) {< span><br><span class="line">     whatwewant = list.get(i);     </span><br><span class="line">}</span><br></list.size();></span></pre></td></tr></tbody></table></figure></div><h3 id="if……else……的简略写法"><a href="#if……else……的简略写法" class="headerlink" title="if……else……的简略写法"></a>if……else……的简略写法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原始写法(一般在函数的最后，通过一个判断来返回值时可以简写成三目运算的形式)</span></span><br><span class="line"><span class="keyword">if</span>(A==B){</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">}</span><br><span class="line"><span class="keyword">else</span>{</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//三目运算符写法（当三目运算的结果是boolean类型时，三目运算可以进一步化简）</span></span><br><span class="line"><span class="keyword">return</span> A==B ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//最简写法</span></span><br><span class="line"><span class="keyword">return</span> A==B;</span><br></pre></td></tr></tbody></table></figure></div><h3 id="判断奇数偶数的两种方式"><a href="#判断奇数偶数的两种方式" class="headerlink" title="判断奇数偶数的两种方式"></a>判断奇数偶数的两种方式</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">num%<span class="number">2</span>==<span class="number">1</span>;<span class="comment">//奇数</span></span><br><span class="line">num%<span class="number">2</span>==<span class="number">0</span>;<span class="comment">//偶数</span></span><br><span class="line">num&<span class="number">1</span>==<span class="number">1</span>;<span class="comment">//奇数</span></span><br><span class="line">num&<span class="number">1</span>==<span class="number">0</span>;<span class="comment">//偶数</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="摩尔投票法"><a href="#摩尔投票法" class="headerlink" title="摩尔投票法"></a>摩尔投票法</h3><p>摩尔投票法的核心就是<strong>对拼消耗</strong>。</p><p>玩一个诸侯争霸的游戏，假设你方人口超过总人口一半以上，并且能保证每个人口出去干仗都能一对一同归于尽。最后还有人活下来的国家就是胜利。</p><p>最差所有人都联合起来对付你（对应你每次选择作为计数器的数都是众数），或者其他国家也会相互攻击（会选择其他数作为计数器的数），但是只要你们不要内斗，最后肯定你赢。</p><h3 id="树相关知识点"><a href="#树相关知识点" class="headerlink" title="树相关知识点"></a>树相关知识点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否是叶结点</span></span><br><span class="line"><span class="keyword">if</span>(root.left==<span class="keyword">null</span>&&root.right==<span class="keyword">null</span>)</span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//树的遍历中一个重要的信息是看是否越过叶子节点</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="比特运算相关知识点"><a href="#比特运算相关知识点" class="headerlink" title="比特运算相关知识点"></a>比特运算相关知识点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n&(n-<span class="number">1</span>) 可以将最后一位<span class="number">1</span>变成<span class="number">0</span>;</span><br><span class="line">举例： n=<span class="number">1000</span>; n-<span class="number">1</span>=<span class="number">0111</span>; 相&之后变成 <span class="number">0000</span>;</span><br><span class="line">n&(-n) 可以得到最后一位<span class="number">1</span>；</span><br><span class="line">举例： n=<span class="number">10100</span>;-n=<span class="number">01100</span>; 相&之后变成<span class="number">00100</span>;</span><br></pre></td></tr></tbody></table></figure></div><h3 id="String相关知识点"><a href="#String相关知识点" class="headerlink" title="String相关知识点"></a>String相关知识点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//String和int相互转换</span></span><br><span class="line">Integer.parseInt(str);</span><br><span class="line">String.valueOf(<span class="keyword">int</span>);   string = <span class="string">""</span>+<span class="keyword">int</span>;</span><br><span class="line"><span class="comment">//String转char[]</span></span><br><span class="line"><span class="keyword">char</span>[] array = string.toCharArray();</span><br><span class="line"><span class="comment">//动态构建String</span></span><br><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">sb.append(<span class="string">"something"</span>);</span><br><span class="line">String res = sb.toString();</span><br></pre></td></tr></tbody></table></figure></div><h3 id="数组相关知识点"><a href="#数组相关知识点" class="headerlink" title="数组相关知识点"></a>数组相关知识点</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//List转Array方法1：toArray()返回一个Object[] 数组，之后需要进行强制类型转换</span></span><br><span class="line">List<string> list = List.of(<span class="string">"apple"</span>, <span class="string">"pear"</span>, <span class="string">"banana"</span>);</string></span><br><span class="line">Object[] array = list.toArray();</span><br><span class="line"><span class="comment">//List转Array方法2：toArray()中传入泛型参数，就不用强制类型转换了</span></span><br><span class="line">List<integer> list = List.of(<span class="number">12</span>, <span class="number">34</span>, <span class="number">56</span>);</integer></span><br><span class="line">Integer[] array = list.toArray(<span class="keyword">new</span> Integer[<span class="number">3</span>]);</span><br><span class="line"><span class="comment">//数组转换成List :  List.of();</span></span><br><span class="line">Integer[] array = {<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>};</span><br><span class="line">List<integer> list = List.of(array);</integer></span><br><span class="line"><span class="comment">//数组排序</span></span><br><span class="line"><span class="keyword">int</span>[] <span class="keyword">var</span>= <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">Arrays.sort(<span class="keyword">var</span>);</span><br></pre></td></tr></tbody></table></figure></div><h3 id="compare-和-compareTo-方法"><a href="#compare-和-compareTo-方法" class="headerlink" title="compare() 和 compareTo() 方法"></a>compare() 和 compareTo() 方法</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// compare</span></span><br><span class="line">compare(a,b){</span><br><span class="line">    <span class="comment">//返回-1(负数)，a在前b在后</span></span><br><span class="line">    <span class="comment">//返回1(正数),b在前a在后</span></span><br><span class="line">}</span><br><span class="line"><span class="comment">//compareTo 方法用于字符串，对象之间的比较，且返回值是正数，负数或者0，分别表示a比b大，小或者相等</span></span><br><span class="line">a.compareTo(b)</span><br><span class="line"><span class="comment">//所以compare中一般包含一个compareTo，compareTo负责大小，compare负责前后。两者合作可以实现按大小排序</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>状态转移：</p><ul><li>多对多：即一个状态可以转变成多种状态，同理一个状态也可以由多个状态转移而来，这在dp数组的每一维度都有可能发生，一般在最后一个维度</li><li>一对一：一个状态只能由一种状态转移而来，这种比较简单</li></ul><h3 id="回溯法"><a href="#回溯法" class="headerlink" title="回溯法"></a>回溯法</h3><p>回溯法中最重要的就是记录进行到了哪一步，如果这个能记录的比较清楚，回溯法就会很简单。回溯法函数中的参数就是专门做这个的。所以，回溯法的函数参数必须要体现两点，一个是已经做了哪些选择，一个是还可以做哪些选择。</p><p>例如在数组中做选择，一般dfs的参数只需要一个索引”i” 就够了。这个i可以代表当前已经做了多少i个选择，还有length-i个选择没做。</p><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>leetcode 第315、327、493题</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>变分推断和VAE</title>
      <link href="/2020/06/06/%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD%E5%92%8CVAE/"/>
      <url>/2020/06/06/%E5%8F%98%E5%88%86%E6%8E%A8%E6%96%AD%E5%92%8CVAE/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="贝叶斯框架"><a href="#贝叶斯框架" class="headerlink" title="贝叶斯框架"></a>贝叶斯框架</h2><p>贝叶斯定理公式如下：</p><script type="math/tex; mode=display">P(A|B)={P(A)P(B|A)\over P(B)}</script><p>我们把P(A)称为”先验概率”（Prior probability），即在不知道B事件发生的前提下，我们对A事件发生概率的一个主观判断。</p><p>P(B|A)/P(B)称为”可能性函数”（Likelyhood），这是一个调整因子，即新信息事件B的发生调整，作用是，使得先验概率更接近真实概率。</p><p>P(A|B)称为”后验概率”（Posterior probability），即在B事件发生之后，我们对A事件概率的重新评估。</p><p>因此，贝叶斯定理可以理解成下面的式子：</p><p>后验概率（新信息出现后A发生的概率）＝先验概率（A发生的概率）×可能性函数（新信息带出现来的调整）</p><h2 id="VI（变分推断）"><a href="#VI（变分推断）" class="headerlink" title="VI（变分推断）"></a>VI（变分推断）</h2><p>变分推断要解决的问题类，叫做概率机器学习问题。简单来说，专家利用他们的知识，给出合理的模型假设p(z, x)，其中包括隐含变量z和观察值变量x（需要说明的是，隐含变量z在通常情况下不止一个，并且相互之间存在依赖关系，这也是问题难求解的原因之一）。我们认为，观察值是从已知的隐含变量组成的层次结构中生成出来的（比如常见的高斯混合模型，隐马尔可夫模型）。</p><p>后验概率$p(z | x)$是说，基于我们现有的数据集合x，推断隐含变量的分布情况。根据贝叶斯公式，$p(z|x) = p(z, x) / p(x)$。 我们根据专家提供的生成模型，可知$p(z, x) $部分（可以写出表达式并且方便优化），但是边缘概率$p(x)$，是不能求得的，当$z$连续时，边缘概率需要对所有可能的$z$求积分，不好求。当$z$离散时，计算复杂性随着$x$的增加而指数增长。</p><p>我们需要构造$q(z; v)$，并且不断更新$v$，使得$q(z;v)$更接近$p(z|x)$。首先注意，$q(z;v)$的表达，意思是$z$是变量，$v$是$z$的概率分布$q$的参数。所以在构造$q$的时候也分两步，第一，概率分布的选择。第二，参数的选择。第一步，我们在选择$q$的概率分布时，通常会直观选择$p$可能的概率分布，这样能够更好地保证$q$和$p$的相似程度。例如高斯混合模型中，原始假设$p$服从高斯分布，则构造的$q$依然服从高斯分布。之后，我们通过改变$v$，使得$q$不断逼近$p$。</p><p><a href="https://user-images.githubusercontent.com/36947860/83938240-3b373c80-a805-11ea-881d-9ce51251c85c.gif" data-fancybox="group" data-caption="clip_image004" class="fancybox"><img alt="clip_image004" data-src="https://user-images.githubusercontent.com/36947860/83938240-3b373c80-a805-11ea-881d-9ce51251c85c.gif" class="lazyload" title="clip_image004"></a></p><p>这样一来，一个复杂的推断问题就变成了优化问题。我们只需要优化$p(z|x)$和$q(z|x)$之间的KL散度即可。然而，KL的表达式中依然有一部分不可求的后验概率$p(z|x)$。</p><p>当给定数据集后，$P(x)$也就给定了，通过一系列的公式推导，我们可以得到如下公式，其中ELBO中只包括联合概率$p(z, x)$和$q(z; v)$，从而摆脱后验概率。此时最小化KL等价于最大化ELBO（Evidence Lower Bound）。</p><p> <a href="https://user-images.githubusercontent.com/36947860/83938228-35415b80-a805-11ea-8633-334ad71236d6.jpg" data-fancybox="group" data-caption="clip_image005" class="fancybox"><img alt="clip_image005" data-src="https://user-images.githubusercontent.com/36947860/83938228-35415b80-a805-11ea-8633-334ad71236d6.jpg" class="lazyload" title="clip_image005"></a></p><h2 id="VAE（Auto-Encoding-Variational-Bayes）"><a href="#VAE（Auto-Encoding-Variational-Bayes）" class="headerlink" title="VAE（Auto-Encoding Variational Bayes）"></a>VAE（Auto-Encoding Variational Bayes）</h2><p>VAE是和GAN齐名的生成模型，下面我们对VAE的原理进行讲解。</p><p><a href="https://user-images.githubusercontent.com/36947860/83938230-370b1f00-a805-11ea-884f-be2bf25f6190.jpg" data-fancybox="group" data-caption="clip_image007" class="fancybox"><img alt="clip_image007" data-src="https://user-images.githubusercontent.com/36947860/83938230-370b1f00-a805-11ea-884f-be2bf25f6190.jpg" class="lazyload" title="clip_image007"></a></p><p>假设我们有一批数据样本$ {X1,…,Xn}$，其整体用$ X $来描述，我们本想根据$ {X1,…,Xn}$ 得到$ X $的分布$ p(X)$，之后便可以根据 $p(X)$ 来采样，就可以得到所有可能的 $X $了（包括 ${X1,…,Xn} $以外的），这是一个终极理想的生成模型。但是直接得到$P(X)$是不可能的，因此我们<strong>假设</strong>样本$X$的生成过程如下：$p(X)=\sum<em>Zp(X|Z)p(Z)$。即，首先由一个先验概率分布$p</em>{\theta^<em>}(Z)$产生隐变量$z^{(i)}$, 然后，样本$x^{(i)}$从条件概率分布$p_{\theta^</em>}(X|Z)$中产生。这是我们的问题就从求$p(X)$变成了求$p(Z)$。</p><p>我们首先假设$p<em>{\theta^<em>}(Z)$服从一个(高维的连续的)<em>*标准</em></em>高斯分布，$p</em>{\theta^<em>}(X|Z)$服从高斯分布(这样的假设具有一定的合理性)，其实$p_{\theta^</em>}(Z)$的分布是什么并不重要，这是一个先验概率分布，只是我们的假设，根据上述的贝叶斯理论，我们在先验的基础上通过调整因子得到的后验才是我们关心的。 重要的是如何得到后验概率分布$p<em>{\theta}(Z|X)$，但是根据上述VI中的理论，这时后验概率分布很难求，所以我们使用一个$q</em>{\phi}(Z|X)$来对真实的后验概率分布$p_{\theta}(Z|X)$进行估计。同样根据上述VI中的理论，得到模型的ELBO如下：</p><p> <a href="https://user-images.githubusercontent.com/36947860/83938232-37a3b580-a805-11ea-9d1d-213e59e21528.jpg" data-fancybox="group" data-caption="clip_image025" class="fancybox"><img alt="clip_image025" data-src="https://user-images.githubusercontent.com/36947860/83938232-37a3b580-a805-11ea-9d1d-213e59e21528.jpg" class="lazyload" title="clip_image025"></a></p><p>在公式中，由于$p(X|Z)$ 形如Decoder，$q(Z|X)$形如Encoder，所以称为VAE。</p><p>由 Encoder 得到隐变量 z 的过程需要保证是连续的，这样才可以使用基于梯度的方法进行优化，如果设计 Encoder 的输出为多元正态分布的参数$\mu(X)$和$\sum(X)$，那么从分布$N(\mu(X),\sum(X))$中采样$z$的操作破坏了连续性。因此，这里我们使用一个叫做重参化的技巧来保证连续性，使用如下方法代替采样：</p><p><a href="https://user-images.githubusercontent.com/36947860/83938234-38d4e280-a805-11ea-918a-56b56f2858b2.jpg" data-fancybox="group" data-caption="clip_image035" class="fancybox"><img alt="clip_image035" data-src="https://user-images.githubusercontent.com/36947860/83938234-38d4e280-a805-11ea-918a-56b56f2858b2.jpg" class="lazyload" title="clip_image035"></a></p><p>其中$\epsilon$服从标准正态分布。</p><p>所以整个VAE训练中的模型结构如下所示：</p><p><a href="https://user-images.githubusercontent.com/36947860/83938235-396d7900-a805-11ea-866b-1b2e97943367.jpg" data-fancybox="group" data-caption="clip_image039" class="fancybox"><img alt="clip_image039" data-src="https://user-images.githubusercontent.com/36947860/83938235-396d7900-a805-11ea-866b-1b2e97943367.jpg" class="lazyload" title="clip_image039"></a></p><p>我们试着解释一下VAE的优化目标：</p><p><a href="https://user-images.githubusercontent.com/36947860/83938236-396d7900-a805-11ea-8b15-125fe9e74e6f.jpg" data-fancybox="group" data-caption="clip_image040" class="fancybox"><img alt="clip_image040" data-src="https://user-images.githubusercontent.com/36947860/83938236-396d7900-a805-11ea-8b15-125fe9e74e6f.jpg" class="lazyload" title="clip_image040"></a></p><p>期望部分可以看作是encoder和decoder的部分，可以看作真正的目标函数，也就是经过编码再解码之后得到的数据尽量和样本相像。</p><p>而KL散度部分可以看作一个正则化项，即Z的后验分布要尽可能的接近一个标准正态分布，避免模型退化成普通的Auto-Encoder。</p><p>测试时我们只需要Decoder就可以了。由于目标函数中的 KL 散度已经把后验分布和先验分布拉近，z 可以从先验采样。</p><p><a href="https://user-images.githubusercontent.com/36947860/83938237-3a060f80-a805-11ea-815c-a4511236dd82.jpg" data-fancybox="group" data-caption="clip_image042" class="fancybox"><img alt="clip_image042" data-src="https://user-images.githubusercontent.com/36947860/83938237-3a060f80-a805-11ea-815c-a4511236dd82.jpg" class="lazyload" title="clip_image042"></a></p><p>参考：<a href="https://www.zhihu.com/question/41765860" target="_blank" rel="noopener">https://www.zhihu.com/question/41765860</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>采样与MCMC</title>
      <link href="/2020/06/03/%E9%87%87%E6%A0%B7%E4%B8%8EMCMC/"/>
      <url>/2020/06/03/%E9%87%87%E6%A0%B7%E4%B8%8EMCMC/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="MCMC"><a href="#MCMC" class="headerlink" title="MCMC"></a>MCMC</h2><h3 id="MCMC命名"><a href="#MCMC命名" class="headerlink" title="MCMC命名"></a>MCMC命名</h3><p>MCMC由两个MC组成，即马尔可夫链和蒙特卡罗方法。</p><h3 id="MCMC方法解决的问题"><a href="#MCMC方法解决的问题" class="headerlink" title="MCMC方法解决的问题"></a>MCMC方法解决的问题</h3><p>蒙特卡罗原来是一个赌场的名称，用它作为名字大概是因为蒙特卡罗方法是一种随机模拟的方法，这很像赌博场里面的扔骰子的过程。最早的蒙特卡罗方法都是为了求解一些不太好求解的求和或者积分问题。比如积分：</p><p>$\theta=\int_a^b f(x)dx$</p><p>如果我们很难求解出$f(x)$的原函数，那么这个积分比较难求解。这时我们可以通过蒙特卡罗方法来模拟求解近似值。</p><p>$\theta=\int<em>a^b f(x)dx=\int_a^b {f(x)\over p(x)}p(x)dx=E</em>{x-p(x)}[{f(x)\over p(x)}]$  </p><p>即，把$q(x)$看作是x在区间内的分布函数，分数部分看作一个函数，然后求函数$f(x)\over q(x)$在分布$q(x)$下的期望。如果此时我们从$q(x)$中采样n个点，就可以使用以下公式近似</p><p>$\theta=\int<em>a^b f(x)dx=\int_a^b {f(x)\over p(x)}p(x)dx=E</em>{x-p(x)}[{f(x)\over p(x)}]\approx{1\over n}\sum_{i=1}^n {f(x)\over p(x)}(其中x是从p(x)中采样的点)$</p><p><strong>这时我们的问题就变成了如何从$p(x)$中采样n个样本点。MCMC就是用来解决这个问题的</strong></p><h2 id="采样"><a href="#采样" class="headerlink" title="采样"></a>采样</h2><h3 id="常见概率分布采样"><a href="#常见概率分布采样" class="headerlink" title="常见概率分布采样"></a>常见概率分布采样</h3><ul><li><p>均匀分布 ：</p><p>一般通过线性同余发生器可以很方便的生成(0,1)之间的伪随机数样本</p></li><li><p>其他常见分布：</p><p>比如正态分布，t分布，F分布，Beta分布，Gamma分布可以从均匀分布得到的采样样本转化得到。python中提供了类库可以直接生成对应分布的样本。</p></li></ul><h3 id="非常见概率分布采样"><a href="#非常见概率分布采样" class="headerlink" title="非常见概率分布采样"></a>非常见概率分布采样</h3><h4 id="接受拒绝采样"><a href="#接受拒绝采样" class="headerlink" title="接受拒绝采样"></a>接受拒绝采样</h4><p>既然 $p(x)$ 太复杂在程序中没法直接采样，那么我设定一个程序可采样的分布 $q(x)$ 比如高斯分布，然后按照一定的方法拒绝某些样本，以达到接近$ p(x)$ 分布的目的，其中$q(x)$叫做 proposal distribution。</p><p>具体采用过程如下，设定一个方便采样的常用概率分布函数 $q(x)$，以及一个常量 $k$，使得 $p(x)$总在 $kq(x)$的下方。</p><p><a href="https://images2015.cnblogs.com/blog/1042406/201703/1042406-20170327143755811-993574578.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://images2015.cnblogs.com/blog/1042406/201703/1042406-20170327143755811-993574578.png" class="lazyload" title="img"></a></p><p>因为$q(x)$是正态分布，我们可以方便的从中采样。之后，从均匀分布$ (0,kq(x))$中采样得到一个值$u$,如果$u$落在了上图中的灰色区域，则拒绝这次抽样，否则接受这个样本$z_0$</p><p><strong>缺点：</strong>找到合适的$q(x)$和$k$有时比较困难，有时也很难写出$p(x)$的分布</p><h4 id="MCMC采样"><a href="#MCMC采样" class="headerlink" title="MCMC采样"></a>MCMC采样</h4><p><strong>马尔可夫链的收敛性质</strong></p><p>一个马尔可夫链即使有不同初始概率分布，在状态转移矩阵不变的情况下，最终状态的概率分布趋于同一个稳定的概率分布， 也就是说我们的马尔科夫链模型的状态转移矩阵收敛到的稳定概率分布与我们的初始状态概率分布无关。</p><p>根据这个性质，可以这样说，如果我们得到了某个平稳分布对应的马尔可夫链状态转移矩阵，就可以从马尔可夫链中采样出来。</p><p><strong>马尔可夫链的收敛条件</strong></p><p>如果非周期马尔科夫链的状态转移矩阵$P$和概率分布$π(x)$对于所有的$i,j$满足：</p><p>$π(i)P(i,j)=π(j)P(j,i)$则称概率分布$π(x)$是状态转移矩阵$P$的平稳分布。</p><p>这其实很好理解，也就是说根据这个状态转移矩阵，到最后各个状态之间的转移到达一种平衡，有多少的A转移成B，就有多少的B转移成A</p><p><strong>从马尔可夫链中采样</strong></p><ol><li>基于一个可采样的简单概率分布$\pi_0(x)$采样得到$x_0$，基于条件概率分布$P(x|x_0)$采样状态$x_1$ ,一直进行下去</li><li>取出马尔可夫链收敛后的采样集</li></ol><p><strong>所以我们的问题现在变成了如何获取一个平稳分布对应的状态转移矩阵</strong></p><p>由于一般情况下，目标平稳分布$π(x)$和某一个马尔科夫链状态转移矩阵$Q$不满足细致平稳条件，即$π(i)Q(i,j)\not=π(j)Q(j,i)$</p><p>我们可以对上式做一个改造，使细致平稳条件成立。方法是引入一个$α(i,j)$,使上式可以取等号，即$π(i)Q(i,j)\alpha(i,j)=π(j)Q(j,i)\alpha(j,i)$,</p><p>其中$\alpha(i,j)=π(j)Q(j,i)$，$\alpha(j,i)=π(i)Q(i,j)$</p><p>所以状态转移概率矩阵$P(i,j)=Q(i,j)\alpha(i,j)$</p><p>在这个公式中，$Q(i,j) $是我们随便取的，$\alpha(j,i)$是由平稳分布$π(j)$和$Q(i,j) $算出来的，所以这个$P(i,j)$是可求的。</p><p>$α(i,j)$我们有一般称之为接受率。取值在[0,1]之间，可以理解为一个概率值。即目标矩阵$P$可以通过任意一个马尔科夫链状态转移矩阵$Q$以一定的接受率获得。 这和接受拒绝采样的思路是一样的。</p><p><strong>缺点：</strong>$α(i,j)$可能非常小，导致大部分情况下拒绝转移，这时马尔可夫链很难收敛</p><h4 id="M-H采样"><a href="#M-H采样" class="headerlink" title="M-H采样"></a>M-H采样</h4><p>M-H采样是Metropolis-Hastings采样的简称，这个算法首先由Metropolis提出，被Hastings改进，因此被称之为Metropolis-Hastings采样或M-H采样。</p><p>我们再来分析一下MCMC：</p><p>$π(i)Q(i,j)\alpha(i,j)=π(j)Q(j,i)\alpha(j,i)$,</p><p>$α(i,j)$可能非常小比如为0.1，而$α(j,i)$为0.2</p><p>$π(i)Q(i,j)×0.1=π(j)Q(j,i)×0.2$</p><p>如果两边同时扩大五倍，接受率提高到了0.5，但是细致平稳条件却仍然是满足的，即</p><p>$π(i)Q(i,j)×0.5=π(j)Q(j,i)×1$</p><p>这样我们的接受率可以做如下改进，即：</p><p>$α(i,j)=min{ {π(j)Q(j,i)\over π(i)Q(i,j)},1}$</p><p><strong>缺点：</strong> 由于$α(i,j)$ 计算式的存在，在高维时计算量大,并且由于接受率的原因导致算法收敛时间变长。二是有些高维数据，特征的条件概率分布好求，但是特征的联合分布不好求。</p><h4 id="Gibbs采样"><a href="#Gibbs采样" class="headerlink" title="Gibbs采样"></a>Gibbs采样</h4><p>在M-H采样中我们通过引入接受率使细致平稳条件满足。现在我们换一个思路。我们发现，在高维的情况下，比如在二维的情况下</p><p>在$x_1=x^{(1)}_1$这条直线上，如果用条件概率分布$π(x_2|x^{(1)}_1)$作为马尔科夫链的状态转移概率，则任意两个点之间的转移满足细致平稳条件！</p><p>因而我们可以构造处一个状态转移矩阵</p><p>参考：<a href="https://www.cnblogs.com/pinard/p/6625739.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6625739.html</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Dir()和help()</title>
      <link href="/2020/05/29/dir()%E5%92%8Chelp()/"/>
      <url>/2020/05/29/dir()%E5%92%8Chelp()/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p><strong>python内置了很多内置函数、类方法属性及各种模块。当我们想要当我们想要了解某种类型有哪些属性方法以及每种方法该怎么使用时，我们可以使用dir()函数和help()函数在python ide交互式模式下获得我们想要的信息。</strong></p><p>dir()用来查询一个类或者对象所有属性.</p><p>help()函数帮助我们了解模块、类型、对象、方法、属性的详细信息</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>强化学习</title>
      <link href="/2020/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/05/20/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="强化学习"><a href="#强化学习" class="headerlink" title="强化学习"></a>强化学习</h2><p>在参数$\theta$ 下，一个序列出现的概率为：</p><p><a href="https://user-images.githubusercontent.com/36947860/82409005-639e0780-9a9f-11ea-8f9d-33151d660ff8.png" data-fancybox="group" data-caption="微信截图_20200520133938" class="fancybox"><img alt="微信截图_20200520133938" data-src="https://user-images.githubusercontent.com/36947860/82409005-639e0780-9a9f-11ea-8f9d-33151d660ff8.png" class="lazyload" title="微信截图_20200520133938"></a></p><p>因为给定一个参数$\theta$，可能出现无数种序列，每个序列都有一个reward，所以一个$\theta$的reward应该是对所有序列 的reward取期望值。<a href="https://user-images.githubusercontent.com/36947860/82409102-947e3c80-9a9f-11ea-8e0b-3aabcaf62d55.png" data-fancybox="group" data-caption="微信截图_20200520134104" class="fancybox"><img alt="微信截图_20200520134104" data-src="https://user-images.githubusercontent.com/36947860/82409102-947e3c80-9a9f-11ea-8e0b-3aabcaf62d55.png" class="lazyload" title="微信截图_20200520134104"></a></p><h2 id="Policy-Gradient"><a href="#Policy-Gradient" class="headerlink" title="Policy Gradient"></a>Policy Gradient</h2><p>对每一个$\theta$的总的reward求导的时候，其实每个序列的reward是个常数，是不用求导的，我们只需要对每个序列出现的概率求导即可。</p><p>同时根据<strong>似然比技巧</strong> $\Delta f(x)=f(x)\Delta logf(x)$ ，可得：</p><p><a href="https://user-images.githubusercontent.com/36947860/82412371-1e310880-9aa6-11ea-8a63-a8c8dc8df3c3.png" data-fancybox="group" data-caption="微信截图_20200520142540" class="fancybox"><img alt="微信截图_20200520142540" data-src="https://user-images.githubusercontent.com/36947860/82412371-1e310880-9aa6-11ea-8a63-a8c8dc8df3c3.png" class="lazyload" title="微信截图_20200520142540"></a></p><p>这里用约等号的原因是本来要求的是期望，但是期望根本没法求，所以只能取N个采样来进行计算，这是对期望的一种近似。</p><h3 id="tip1-Add-a-BaseLine"><a href="#tip1-Add-a-BaseLine" class="headerlink" title="tip1  Add a BaseLine"></a>tip1  Add a BaseLine</h3><p>因为我们求期望的时候，是用采样的方式来估计的，有些模型里面，所有的reward都是正的，这对于那些没有被采样到的序列是不公平的，因为只要被采样就可以得到正的reward，所以我们要加一个baseline，使得reward有正有负。</p><p><a href="https://user-images.githubusercontent.com/36947860/82415042-8386f880-9aaa-11ea-8ea9-f4eca8288e81.png" data-fancybox="group" data-caption="微信截图_20200520144409" class="fancybox"><img alt="微信截图_20200520144409" data-src="https://user-images.githubusercontent.com/36947860/82415042-8386f880-9aaa-11ea-8ea9-f4eca8288e81.png" class="lazyload" title="微信截图_20200520144409"></a></p><h3 id="tip2-Assign-Suitable-Credit"><a href="#tip2-Assign-Suitable-Credit" class="headerlink" title="tip2  Assign Suitable Credit"></a>tip2  Assign Suitable Credit</h3><p>在同一个序列中，所有的决策都是乘上同一个总的reward，这是不合理的，一种解决办法是 认为reward并不是每一步的reward全部加起来，只把这个action执行之后的每一步的reward加起来，这是符合直觉的，因为前面的reward跟这个action并没有关系，这个action只会对之后的序列的reward产生影响。同时，对于越靠后的序列，这个action的影响就越小，因此也要乘上一个衰减因子，衰减程度离这个action越远越大</p><p><a href="https://user-images.githubusercontent.com/36947860/82415044-841f8f00-9aaa-11ea-9fe2-eb540192b39f.png" data-fancybox="group" data-caption="微信截图_20200520145817" class="fancybox"><img alt="微信截图_20200520145817" data-src="https://user-images.githubusercontent.com/36947860/82415044-841f8f00-9aaa-11ea-9fe2-eb540192b39f.png" class="lazyload" title="微信截图_20200520145817"></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java_NIO</title>
      <link href="/2020/05/18/java_NIO/"/>
      <url>/2020/05/18/java_NIO/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>同步和异步强调的是消息通信机制 (synchronous communication/ asynchronous communication)。所谓同步，就是在发出一个”调用”时，在没有得到结果之前，该“调用”就不返回。但是一旦调用返回，就得到返回值了。换句话说，就是由“调用者”主动等待这个“调用”的结果。而异步则是相反，”调用”在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在”调用”发出后，”被调用者”通过状态、通知来通知调用者，或通过回调函数处理这个调用</p><h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p>阻塞和非阻塞 强调的是程序在等待调用结果（消息，返回值）时的状态. 阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。</p><h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>NIO主要有三大核心部分：Channel(通道)，Buffer(缓冲区), Selector。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><p>首先说一下Channel，国内大多翻译成“通道”。Channel和IO中的Stream(流)是差不多一个等级的。只不过Stream是单向的，譬如：InputStream, OutputStream.而Channel是双向的，既可以用来进行读操作，又可以用来进行写操作。<br>NIO中的Channel的主要实现有：</p><ul><li>FileChannel</li><li>DatagramChannel</li><li>SocketChannel</li><li>ServerSocketChannel</li></ul><p>这里看名字就可以猜出个所以然来：分别可以对应文件IO、UDP和TCP（Server和Client）。</p><p>NIO的channel抽象的一个重要特征就是可以通过配置它的阻塞行为，以实现非阻塞式的信道。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>)</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h3><p>NIO中的关键Buffer实现有：ByteBuffer, CharBuffer, DoubleBuffer, FloatBuffer, IntBuffer, LongBuffer, ShortBuffer，分别对应基本数据类型: byte, char, double, float, int, long, short。当然NIO中还有MappedByteBuffer, HeapByteBuffer, DirectByteBuffer等这里先不进行陈述。</p><p>Buffer顾名思义：缓冲区，实际上是一个容器，一个连续数组。Channel提供从文件、网络读取数据的渠道，但是读写的数据都必须经过Buffer。如下图：</p><p><a href="https://img-blog.csdnimg.cn/2019050721080739.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://img-blog.csdnimg.cn/2019050721080739.png" class="lazyload" title="img"></a></p><p>向Buffer中写数据：</p><ul><li>从Channel写到Buffer (fileChannel.read(buf))</li><li>通过Buffer的put()方法 （buf.put(…)）</li></ul><p>从Buffer中读取数据：</p><ul><li>从Buffer读取到Channel (channel.write(buf))</li><li>使用get()方法从Buffer中读取数据 （buf.get()）</li></ul><h3 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h3><p>Selector运行单线程处理多个Channel，如果你的应用打开了多个通道，但每个连接的流量都很低，使用Selector就会很方便。例如在一个聊天服务器中。要使用Selector, 得向Selector注册Channel，然后调用它的select()方法。这个方法会一直阻塞到某个注册的通道有事件就绪。一旦这个方法返回，线程就可以处理这些事件，事件的例子有如新的连接进来、数据接收等。</p><p>Select里面其实就是维持了一个Channel的Map来实现多路复用</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java_BIO</title>
      <link href="/2020/05/17/Java_BIO/"/>
      <url>/2020/05/17/Java_BIO/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>转载：<a href="http://blog.csdn.net/u012250875/article/details/78341874" target="_blank" rel="noopener">http://blog.csdn.net/u012250875/article/details/78341874</a></p><h3 id="1-IO相关概念一览"><a href="#1-IO相关概念一览" class="headerlink" title="1.IO相关概念一览"></a>1.IO相关概念一览</h3><h4 id="1-1-什么是IO"><a href="#1-1-什么是IO" class="headerlink" title="1.1 什么是IO"></a>1.1 什么是IO</h4><p>所谓IO即input和output的缩写，是对数据的流入和流出的一种抽象，编程中很常见的一个概念。</p><h4 id="1-2-什么是流"><a href="#1-2-什么是流" class="headerlink" title="1.2 什么是流"></a>1.2 什么是流</h4><p>体会一下这几个词：水流（静止的水想必没人会叫水流），物流，人流（此人流非彼人流 = =！），可以发现流的特点：动态的，可转移的，从一处到另一处的</p><h4 id="1-3-java-io"><a href="#1-3-java-io" class="headerlink" title="1.3 java io"></a>1.3 java io</h4><p>java为了我们调用方便，而屏蔽输入/输出源和流动细节，抽象出的用于解决数据流动问题的类体系，这就是java的io流</p><h4 id="1-4-输入流和输出流"><a href="#1-4-输入流和输出流" class="headerlink" title="1.4 输入流和输出流"></a>1.4 输入流和输出流</h4><p>用于读取的流称为输入流（输入流只能用来读），用于写入的流称为输出流（输出流只能用来写）。输入输出的概念一般是针对内存来说的，流（写）入内存，从内存流（读）出。</p><h4 id="1-5-字节流和字符流"><a href="#1-5-字节流和字符流" class="headerlink" title="1.5 字节流和字符流"></a>1.5 字节流和字符流</h4><p>输入输出流可操作最小单位来区分字节流和字符流，最小操作单位是一个字节（8bit）的为字节流，最小操作单位为一个字符（16bit）的为字符流，java io体系中字节操作流以stream结尾，字符操作流以reader和writer结尾</p><h4 id="1-6-节点流和包装（处理）流"><a href="#1-6-节点流和包装（处理）流" class="headerlink" title="1.6 节点流和包装（处理）流"></a>1.6 节点流和包装（处理）流</h4><p>1）节点流偏向实现细节，直接与细节打交道，比如FileInputStream，而包装（处理）流偏功能，以目标功能为抽象，比如PrintStream。<br>2）区分节点流和包装（处理）流最简单的一个方式：处理流的构造方法中需要另一个流作为参数，而节点流构造方法则是具体的物理节点，如上FileInputStream构造法中需要一个文件路径或者File对象，而PrintStream构造方法中则需要一个流对象<br>3）包装流使用了装饰器模式（什么是装饰器模式？传送门），包装流对节点流进行了一系列功能的强化包装，让包装后的流拥有了更多的操作手段或更高的操作效率，而隐藏节点流底层的复杂性。</p><h4 id="1-7-低级流和高级流"><a href="#1-7-低级流和高级流" class="headerlink" title="1.7 低级流和高级流"></a>1.7 低级流和高级流</h4><p>低级流和高级流对应的概念即对应上面的节点流和包装（处理）流概念</p><h4 id="1-8-普通流和缓冲流"><a href="#1-8-普通流和缓冲流" class="headerlink" title="1.8 普通流和缓冲流"></a>1.8 普通流和缓冲流</h4><p>普通流和缓冲流主要是针对读写性能上提出的相对概念。普通流与缓冲流的区别在于一个一个数据的流动还是一堆一堆数据的流动。</p><h4 id="1-9-bio，nio，aio"><a href="#1-9-bio，nio，aio" class="headerlink" title="1.9 bio，nio，aio"></a>1.9 bio，nio，aio</h4><p>bio：b有两说，一为base，jdk中最早抽象出的io体系；一为block，jdk 1.0 中的io体系是阻塞的。所以两说皆有道理，一般我们认为b取block之意<br>nio：n也有两说，一为new，针对base而言；一为non-block，针对block而言。<br>aio：a为asynchronous，异步的，异步io，aio还有个名字叫：nio2</p><p>发展历程：bio(jdk1.0) -> nio(jdk1.4) -> aio(jdk1.7)</p><h3 id="2-BIO类体系"><a href="#2-BIO类体系" class="headerlink" title="2.BIO类体系"></a>2.BIO类体系</h3><h4 id="2-1-体系图"><a href="#2-1-体系图" class="headerlink" title="2.1 体系图"></a>2.1 体系图</h4><p><a href="https://img-blog.csdn.net/20171030145316386?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI1MDg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" data-fancybox="group" data-caption="这里写图片描述" class="fancybox"><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20171030145316386?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI1MDg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" title="这里写图片描述"></a></p><h3 id="3-BIO体系中的类该怎么使用？"><a href="#3-BIO体系中的类该怎么使用？" class="headerlink" title="3.BIO体系中的类该怎么使用？"></a>3.BIO体系中的类该怎么使用？</h3><p>要回答这个问题，我们需要将这个问题进行拆分为下面四个问题</p><h4 id="3-1-什么时候该用输入流，什么时候用输出流？"><a href="#3-1-什么时候该用输入流，什么时候用输出流？" class="headerlink" title="3.1 什么时候该用输入流，什么时候用输出流？"></a>3.1 什么时候该用输入流，什么时候用输出流？</h4><p>从流中读取信息使用输入流（xxxInputStream/xxxReader），写入信息使用输出流（xxxOutputStream/xxxWriter）</p><h4 id="3-2-什么时候该用字节流，什么时候用字符流？"><a href="#3-2-什么时候该用字节流，什么时候用字符流？" class="headerlink" title="3.2 什么时候该用字节流，什么时候用字符流？"></a>3.2 什么时候该用字节流，什么时候用字符流？</h4><p>处理纯文本数据时使用字符流（xxxReader/xxxWriter），处理非纯文本时使用字节流（xxxStream）。最后其实不管什么类型文件都可以用字节流处理，包括纯文本，但会增加一些额外的工作量。所以还是按原则选择最合适的流来处理</p><h4 id="3-3-什么时候该用节点流，什么时候用包装（处理）流？"><a href="#3-3-什么时候该用节点流，什么时候用包装（处理）流？" class="headerlink" title="3.3 什么时候该用节点流，什么时候用包装（处理）流？"></a>3.3 什么时候该用节点流，什么时候用包装（处理）流？</h4><p>不管你用什么包装（处理）流，都需要先使用节点流获取对应节点的数据流，然后根据具体需求来选择相应的包装（处理）流来对节点流进行包装修饰，从而获取相应的功能</p><h4 id="3-4-什么时候该用普通流，什么时候用缓冲流？"><a href="#3-4-什么时候该用普通流，什么时候用缓冲流？" class="headerlink" title="3.4 什么时候该用普通流，什么时候用缓冲流？"></a>3.4 什么时候该用普通流，什么时候用缓冲流？</h4><p>一般如果对数据流不做加工处理，而是单纯的读写，如数据转移（拷贝，上传，下载），则需要使用缓冲流来提高性能，当然你也可以自己使用buff数组来提高读写效率。</p><h4 id="3-5-使用小结"><a href="#3-5-使用小结" class="headerlink" title="3.5 使用小结"></a>3.5 使用小结</h4><p>1）判断操作的数据类型<br>纯文本数据：读用Reader系，写用Writer系<br>非纯文本数据：读用InputStream系，写用OutputStream系<br>如果纯文本数据只是简单的复制，下载，上传，不对数据内容本身做处理，那么使用Stream系<br>2）判断操作的物理节点<br>内存：ByteArrayXXX<br>硬盘：FileXXX<br>网络：http中的request和response均可获取流对象，tcp中socket对象可获取流对象<br>键盘（输入设备）：System.in<br>显示器（输出设备）：System.out<br>3）搞清读写顺序，一般是先获取输入流，从输入流中读取数据，然后再写到输出流中。<br>4）是否需增加特殊功能，如需要用缓冲提高读写效率则使用BufferedXXX，如果需要获取文本行号，则使用LineNumberXXX，如果需要转换流则使用InputStreamReader和OutputStreamWriter，如果需要写入和读取对象则使用ObjectOutputStream和ObjectInputStream</p><h3 id="4-使用IO流一些注意点"><a href="#4-使用IO流一些注意点" class="headerlink" title="4.使用IO流一些注意点"></a>4.使用IO流一些注意点</h3><h4 id="4-1-关于流的read、write方法的使用"><a href="#4-1-关于流的read、write方法的使用" class="headerlink" title="4.1 关于流的read、write方法的使用"></a>4.1 关于流的read、write方法的使用</h4><p>下面列出read和write的方法原型（这里以字节流为例，字符流道理相同）：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stream的read</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span>;<span class="comment">//返回值代表当前读取的字节（8bit）所对应的整形</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span></span>;<span class="comment">//将读入的数据装入缓冲区b，实际装了几个字节？实际装了返回值大小个字节，最常使用的read方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span></span>;<span class="comment">//将读入的数据装入缓冲区b，从哪开始装？从off开始，装几个字节？装len个，实际装了几个？实际装了返回值大小个字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// stream的write</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span></span>;<span class="comment">//一次写入一个字节，写入的内容是整型b所对应的二进制数据写入流中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[])</span></span>;<span class="comment">//一次将b数组中的数据写入流中</span></span><br><span class="line">write(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len);<span class="comment">//将b数组中区间为[off,off+len]的数据写入流中，最常使用的write方法</span></span><br></pre></td></tr></tbody></table></figure></div><p>如果不考虑性能会有如下两种形式来读写：读入一个字节，写入一个字节；使用缓冲区读入一堆字节，然后将缓冲区数据进行写入输出流。如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读一个字节，写一个字节</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>){</span><br><span class="line">    fos.write(b);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//读入一堆，写入一堆</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line"><span class="keyword">while</span>((b = fis.read(buff)) != -<span class="number">1</span>){</span><br><span class="line">    fos.write(buff,<span class="number">0</span>,b);<span class="comment">//将缓冲数组索引区间为[0,b]的数据写入</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面第一种方式读一个字节写一个字节没什么说的；第二个方式则需要注意，调用write(buff,0,b)而不是write(buff,0,buff.length)，为什么写入[0,b]而不是[0,buff.length]区间的数据呢？因为假如只剩余3个字节没有读取，而缓冲数组定义的大小是8个字节，那么使用[0,buff.length]则会造成多写入5个字节的脏数据</p><h4 id="4-2-关于流读写性能问题"><a href="#4-2-关于流读写性能问题" class="headerlink" title="4.2 关于流读写性能问题"></a>4.2 关于流读写性能问题</h4><p>流的读写是比较耗时的操作，因此为了提高性能，便有缓冲的这个概念（什么是缓冲？假如你是个搬砖工，你工头让你把1000块砖从A点运到B点，你可以一次拿一块砖从A点运到B点放下砖，这样你要来回跑1000次，大多数的时间开销在路上了；你还可以使用一辆小车，在A点装满一车的砖，然后运到B点放下砖，如果一车最多可以装500块，那么你来回两次便可以把这些砖运完。这里的小车便是那个缓冲），在java bio中使用缓冲一般有两种方式。一种是自己申明一个缓冲数组，利用这个数组来提高读写效率；另一种方式是使用jdk提供的处理流BufferedXXX类。下面我们分别演示不使用缓冲读写，使用自定义的缓冲读写，使用BufferedXXX缓冲读写一个文件。</p><h5 id="4-21-无缓冲读写文件"><a href="#4-21-无缓冲读写文件" class="headerlink" title="4.21 无缓冲读写文件"></a>4.21 无缓冲读写文件</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝文件（方法一）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 被拷贝的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 拷贝到的目的地</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByFileStream</span><span class="params">(File src,File dest)</span></span>{</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>((b = fis.read()) != -<span class="number">1</span>){<span class="comment">//一个字节一个字节的读</span></span><br><span class="line">            fos.write(b);<span class="comment">//一个字节一个字节的写</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span>{</span><br><span class="line">        close(fis,fos);</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"使用FileOutputStream拷贝大小"</span>+getSize(src)+<span class="string">"的文件未使用缓冲数组耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"毫秒"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h5 id="4-22-自定义数组做缓冲读写文件"><a href="#4-22-自定义数组做缓冲读写文件" class="headerlink" title="4.22 自定义数组做缓冲读写文件"></a>4.22 自定义数组做缓冲读写文件</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝文件（方法二）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 被拷贝的文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 拷贝到的目的地</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 缓冲数组大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByFileStream</span><span class="params">(File src,File dest,<span class="keyword">int</span> size)</span></span>{</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(dest);</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[size];<span class="comment">//定义一个缓冲数组</span></span><br><span class="line">        <span class="comment">//读取一定量的数据（read返回值表示这次读了多少个数据）放入数组中</span></span><br><span class="line">        <span class="keyword">while</span>((b = fis.read(buff)) != -<span class="number">1</span>){</span><br><span class="line">            fos.write(buff,<span class="number">0</span>,b);<span class="comment">//一次将读入到数组中的有效数据（索引[0,b]范围的数据）写入输出流中</span></span><br><span class="line">        }</span><br><span class="line">    } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span>{</span><br><span class="line">        close(fos,fis);</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"使用FileOutputStream拷贝大小"</span>+getSize(src)+<span class="string">"的文件使用了缓冲数组耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"毫秒，生成的目标文件大小为"</span>+getSize(dest));</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h5 id="4-23-使用BufferedXXX类使用默认大小缓冲来读写文件"><a href="#4-23-使用BufferedXXX类使用默认大小缓冲来读写文件" class="headerlink" title="4.23 使用BufferedXXX类使用默认大小缓冲来读写文件"></a>4.23 使用BufferedXXX类使用默认大小缓冲来读写文件</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝文件（方法三）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByBufferedStream</span><span class="params">(File src,File dest)</span> </span>{</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>( (b = bis.read())!=-<span class="number">1</span>){</span><br><span class="line">            bos.write(b);<span class="comment">//使用BufferedXXX重写的write方法进行写入数据。该方法看似未缓冲实际做了缓冲处理</span></span><br><span class="line">        }</span><br><span class="line">        bos.flush();</span><br><span class="line">    }<span class="keyword">catch</span>(IOException e){</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }<span class="keyword">finally</span>{</span><br><span class="line">        close(bis,bos);</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"使用BufferedXXXStream拷贝大小"</span>+getSize(src)+<span class="string">"的文件使用了缓冲数组耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"毫秒"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h5 id="4-24-使用BufferedXXX类自定义大小缓冲来读写文件"><a href="#4-24-使用BufferedXXX类自定义大小缓冲来读写文件" class="headerlink" title="4.24 使用BufferedXXX类自定义大小缓冲来读写文件"></a>4.24 使用BufferedXXX类自定义大小缓冲来读写文件</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 拷贝文件（方法四）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> src 被拷贝的文件对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> dest 拷贝目的地文件对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> size 自定义缓冲区大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByBufferedStream</span><span class="params">(File src,File dest,<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">while</span>( (b = bis.read(buff))!=-<span class="number">1</span>){<span class="comment">//数据读入缓冲区</span></span><br><span class="line">            bos.write(buff,<span class="number">0</span>,b);<span class="comment">//将缓存区数据写入输出流中</span></span><br><span class="line">        }</span><br><span class="line">        bos.flush();</span><br><span class="line">    }<span class="keyword">catch</span>(IOException e){</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }<span class="keyword">finally</span>{</span><br><span class="line">        close(bos,bis);</span><br><span class="line">    }</span><br><span class="line">    System.out.println(<span class="string">"使用BufferedXXXStream拷贝大小"</span>+getSize(src)+<span class="string">"的文件使用了缓冲数组耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"毫秒"</span>);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>从上面可以看出来，如果不使用缓冲（4.21）拷贝一个八百多k的文件，竟然要5秒钟，这个速度让人捉急啊，所以我们拷贝文件时应该使用缓冲技术。由于这是常用功能，便提供了BuffereXXX类简化这个工作，上面我们使用BufferedOutputStream（4.23），即使调用write(int b)方法没有显示使用缓冲数组为什么性能也大大得到提升？来看看BufferedOutputStream中的部分源码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedOutputStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>{</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The internal buffer where data is stored.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">byte</span> buf[];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out)</span> </span>{</span><br><span class="line">    <span class="keyword">this</span>(out, <span class="number">8192</span>);</span><br><span class="line">} </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out, <span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    <span class="keyword">super</span>(out);</span><br><span class="line">    <span class="keyword">if</span> (size <= <span class="number">0</span>) {</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size <= 0"</span>);</span><br><span class="line">    }</span><br><span class="line">    buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">}</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">if</span> (count >= buf.length) {</span><br><span class="line">        flushBuffer();</span><br><span class="line">    }</span><br><span class="line">    buf[count++] = (<span class="keyword">byte</span>)b;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h5 id="方法测试："><a href="#方法测试：" class="headerlink" title="方法测试："></a>方法测试：</h5><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    File src = <span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1.bmp"</span>);</span><br><span class="line">    File dest = <span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1_copy.bmp"</span>);</span><br><span class="line">    <span class="comment">//无缓冲区</span></span><br><span class="line">    copyByFileStream(src,dest);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//32k缓冲区</span></span><br><span class="line">    copyByFileStream(src,dest,<span class="number">32</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//64k缓冲区</span></span><br><span class="line">    copyByFileStream(src,dest,<span class="number">64</span>);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//BufferedOutputStream缓冲区默认大小为8192字节</span></span><br><span class="line">    copyByBufferedStream(src, dest);</span><br><span class="line">    sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//BufferedOutputStream缓冲区默认大小为8192*2字节</span></span><br><span class="line">    copyByBufferedStream(src, dest, <span class="number">8192</span>*<span class="number">2</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//我本地测试如下：</span></span><br><span class="line">使用FileOutputStream拷贝大小<span class="number">864054</span>字节的文件未使用缓冲数组耗时：<span class="number">5092</span>毫秒，生成的目标文件大小为<span class="number">864054</span>字节</span><br><span class="line">使用FileOutputStream拷贝大小<span class="number">864054</span>字节的文件使用了缓冲数组耗时：<span class="number">215</span>毫秒，生成的目标文件大小为<span class="number">864054</span>字节</span><br><span class="line">使用FileOutputStream拷贝大小<span class="number">864054</span>字节的文件使用了缓冲数组耗时：<span class="number">124</span>毫秒，生成的目标文件大小为<span class="number">864054</span>字节</span><br><span class="line">使用BufferedXXXStream拷贝大小<span class="number">864054</span>字节的文件使用了缓冲数组耗时：<span class="number">41</span>毫秒，生成的目标文件大小为<span class="number">864054</span>字节</span><br><span class="line">使用BufferedXXXStream拷贝大小<span class="number">864054</span>字节的文件使用了缓冲数组耗时：<span class="number">8</span>毫秒，生成的目标文件大小为<span class="number">864054</span>字节</span><br></pre></td></tr></tbody></table></figure></div><p>从上面BufferedOutputStream中可以看出，构造实例的时候便创造了一个大小为8192字节的缓冲数组，当我们调用write(int b)方法时，并没有在调用完后直接写入，而是将每一个传入的int值放入到了buf中，只有count >= buf.length时，才调用flushBuffer将缓冲区的数据写入。</p><h4 id="4-3-如何判断文件是否读写完毕？"><a href="#4-3-如何判断文件是否读写完毕？" class="headerlink" title="4.3 如何判断文件是否读写完毕？"></a>4.3 如何判断文件是否读写完毕？</h4><p>我们一般在处理文件，一般是一边从输出流中读数据，然后将读出的部分进行处理，最后将处理好的数据写入到输出流中。那么要将一个文件完整的处理完，我们必须知道什么时候已经读到文件的末尾了。<br>一般来说可以根据read方法返回的值，如果返回了-1表示没有可读取的字节了。<br>另一种是使用available()方法查看还有多少可供读取的，当输入流每读一个字节，available()返回的值便减小1，这种模式很像游标的模式，但要注意的是available的适用场景是非阻塞读取，如本地文件读取，如果是网络io使用该方法，可能你拿到的值就不对了。<br>总的来说一般输入流提供的读取方法是可以获得文件是否结束的标志，比如流默认的read方法，根据返回值是否非负，比如PrintReader和BufferedReader的readLine()方法，根据返回数据是否非空。</p><h4 id="4-4-关于flush-的问题"><a href="#4-4-关于flush-的问题" class="headerlink" title="4.4 关于flush()的问题"></a>4.4 关于flush()的问题</h4><p>为什么缓冲输出流写数据结束需要调用flush方法？我们以BufferedOutputStream的write(int b)方法源码为例，源码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">if</span> (count >= buf.length) {</span><br><span class="line">        flushBuffer();</span><br><span class="line">    }</span><br><span class="line">    buf[count++] = (<span class="keyword">byte</span>)b;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>可以得知，BufferedOutputStream在write时候，只有count >= buf.length，即缓冲区数据填满的时候才会自动调用flushBuffer()将缓冲区数据进行写入，也就是说如果缓冲区数据未满则将不会写入，这时我们需人为的调用flush()方法将未满的缓冲区数据进行写入，如下例，可以看出未flush和flush后的区别。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByBufferedStream</span><span class="params">(File src,File dest,<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">while</span>( (b = bis.read(buff))!=-<span class="number">1</span>){</span><br><span class="line">            bos.write(buff,<span class="number">0</span>,b);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"拷贝大小"</span>+getSize(src)+<span class="string">"的文件使用了缓冲数组耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"毫秒，未flush生成的目标文件大小为"</span>+getSize(dest));</span><br><span class="line">        bos.flush();</span><br><span class="line">        System.out.println(<span class="string">"拷贝大小"</span>+getSize(src)+<span class="string">"的文件使用了缓冲数组耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"毫秒，flush后生成的目标文件大小为"</span>+getSize(dest));</span><br><span class="line">    }<span class="keyword">catch</span>(IOException e){</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    File src = <span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1.bmp"</span>);</span><br><span class="line">    File dest = <span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1_copy.bmp"</span>);</span><br><span class="line">    copyByBufferedStream(src, dest, <span class="number">8192</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果：</span></span><br><span class="line">拷贝大小<span class="number">864054</span>字节的文件使用了缓冲数组耗时：<span class="number">3</span>毫秒，未flush生成的目标文件大小为<span class="number">860160</span>字节</span><br><span class="line">拷贝大小<span class="number">864054</span>字节的文件使用了缓冲数组耗时：<span class="number">3</span>毫秒，flush后生成的目标文件大小为<span class="number">864054</span>字节</span><br></pre></td></tr></tbody></table></figure></div><p>从上面测试可以知道，如果未使用flush，带来的后果可能会造成部分数据丢失，为什么说是可能？因为如果文件大小刚好是缓冲区的整倍数，即最后一次写入的数据刚好填满缓冲区，write方法也会自动flushBuffer。另一种原因是，调用close方法后会自动将缓冲区的数据flush，我们看看close方法源码，由于BufferedOutputStream类中并没有重写close方法，因此我们去看看直接父类FilterOutputStream的close，源码如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>{</span><br><span class="line">    <span class="keyword">try</span> (OutputStream ostream = out) {</span><br><span class="line">        flush();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>从上可以看出，在调用close后，其实内部调用了flush()，因此我们在调用close后，数据也能保证数据完整写入，我们验证下我们刚才的分析:</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyByBufferedStream</span><span class="params">(File src,File dest,<span class="keyword">int</span> size)</span> </span>{</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    BufferedOutputStream bos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">try</span>{</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(src));</span><br><span class="line">        bos = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dest));</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">        <span class="keyword">while</span>( (b = bis.read(buff))!=-<span class="number">1</span>){</span><br><span class="line">            bos.write(buff,<span class="number">0</span>,b);</span><br><span class="line">        }</span><br><span class="line">        System.out.println(<span class="string">"拷贝大小"</span>+getSize(src)+<span class="string">"的文件使用了缓冲数组耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"毫秒，未flush，未调close生成的目标文件大小为"</span>+getSize(dest));</span><br><span class="line">    }<span class="keyword">catch</span>(IOException e){</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }<span class="keyword">finally</span>{</span><br><span class="line">        close(bos,bis);<span class="comment">//一个工具方法，内部调用了输出流的close方法，文章后面部分可以看到该方法的源码</span></span><br><span class="line">        System.out.println(<span class="string">"拷贝大小"</span>+getSize(src)+<span class="string">"的文件使用了缓冲数组耗时："</span>+(System.currentTimeMillis()-start)+<span class="string">"毫秒，未flush，调用close后生成的目标文件大小为"</span>+getSize(dest));</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    File src = <span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1.bmp"</span>);</span><br><span class="line">    File dest = <span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1_copy.bmp"</span>);</span><br><span class="line">    copyByBufferedStream(src, dest, <span class="number">8192</span>);</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果如下：</span></span><br><span class="line">拷贝大小<span class="number">864054</span>字节的文件使用了缓冲数组耗时：<span class="number">5</span>毫秒，未flush，未调close生成的目标文件大小为<span class="number">860160</span>字节</span><br><span class="line">拷贝大小<span class="number">864054</span>字节的文件使用了缓冲数组耗时：<span class="number">6</span>毫秒，未flush，调用close后生成的目标文件大小为<span class="number">864054</span>字节</span><br></pre></td></tr></tbody></table></figure></div><p>这样的结果确实符合我们对源码的分析</p><h4 id="4-5-关于网络流中使用available-方法的问题"><a href="#4-5-关于网络流中使用available-方法的问题" class="headerlink" title="4.5 关于网络流中使用available()方法的问题"></a>4.5 关于网络流中使用available()方法的问题</h4><p>当你在网络io中，比如你用socket编程时获取到的流进行读写时，会发现使用available方法有问题，原因是网络io的特点是：<br>1.非实时性。你调用available()方法判断剩余流的大小时，远端数据可能还未发送，或者要发送的数据处于队列中，因此通过available()拿到的可用长度可能是0<br>2.非连续性。由于网络数据传输中，一般会分段多次发送，available仅仅能返回本次的可用长度。<br>鉴于以上两个特点，使用available判断网络io还有多少数据可读是不合适的，因此解决该问题一般采用自定义协议，比如文件大小，文件名等信息放入流的头几个字节中，接收方根据收到的头信息来解析出对法传送的文件大小，根据大小来判断还剩多少字节需要读取，是否读取完毕。</p><h4 id="4-6-关于关闭流的问题"><a href="#4-6-关于关闭流的问题" class="headerlink" title="4.6 关于关闭流的问题"></a>4.6 关于关闭流的问题</h4><p>1）为什么需要手动关闭？<br>参见<a href="https://blog.csdn.net/u012250875/article/details/78365112" target="_blank" rel="noopener">https://blog.csdn.net/u012250875/article/details/78365112</a></p><p>2） 关闭流的正确写法<br>先来两个不规范的，上代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例一</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1.bmp"</span>));</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1_copy.bmp"</span>));</span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 案例二</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">    FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">    FileOutputStream fos = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> {</span><br><span class="line">        fis = <span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1.bmp"</span>));</span><br><span class="line">        fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"E:\\iotest\\1_copy.bmp"</span>));</span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">        <span class="comment">//......</span></span><br><span class="line">    } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } <span class="keyword">finally</span>{</span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            <span class="keyword">if</span>(fos!=<span class="keyword">null</span>){</span><br><span class="line">                fos.close();    </span><br><span class="line">            }</span><br><span class="line">            <span class="keyword">if</span>(fis!=<span class="keyword">null</span>){</span><br><span class="line">                fis.close();    </span><br><span class="line">            }</span><br><span class="line">        } <span class="keyword">catch</span> (IOException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>案例一写法不规范的原因是fis和fos对象执行一些方法时是可能发生异常的，一旦出现异常，虽然由于进行了try catch，但是执行流程会直接进入到catch中，会跳过流的关闭操作。</p><p>案例二写法不规范的原因是，虽然讲close操作放入了finally中，但是一旦fos.close执行出现异常，则fis无法正常关闭，修改方法是在finally块中的同时对每个close都单独try catch。</p><p>因此写一个关闭流的工具方法，写法如下：</p><pre><code>/** * 关闭给定的io流 */public static void close(Closeable...closes){    for (Closeable closeable : closes) {        try {            if(closeable!=null){                closeable.close();                              }        } catch (IOException e) {            e.printStackTrace();        }    }}/** * 调用close()方法 */ public static void main(String[] args) {    FileInputStream fis = null;    FileOutputStream fos = null;    try {        fis = new FileInputStream(new File("E:\\iotest\\1.bmp"));        fos = new FileOutputStream(new File("E:\\iotest\\1_copy.bmp"));        //其他代码        //......    } catch (IOException e) {        e.printStackTrace();    } finally{        close(fos,fis);    }}</code></pre><h3 id="5-java-io流到底能干些什么？"><a href="#5-java-io流到底能干些什么？" class="headerlink" title="5.java io流到底能干些什么？"></a>5.java io流到底能干些什么？</h3><p>java io主要做两类事情：<br>1）数据传输，实际例子如文件上传，下载，文件本地拷贝等<br>2）数据处理，如文本内容加密，图片处理，文件压缩，音视频处理等</p><h3 id="6-实践一下"><a href="#6-实践一下" class="headerlink" title="6.实践一下"></a>6.实践一下</h3><p>下面就来个简单的实践</p><h4 id="6-1-文件拷贝"><a href="#6-1-文件拷贝" class="headerlink" title="6.1 文件拷贝"></a>6.1 文件拷贝</h4><p>本文中4.2中的几个方法均可进行文件拷贝，拷贝一般都会使用缓冲来提高性能</p><h4 id="6-2-文本加密"><a href="#6-2-文本加密" class="headerlink" title="6.2 文本加密"></a>6.2 文本加密</h4><p>因为我们通过java io流处理可以获得文本的原始数据，我们在数据上进行加工就可以加密文本，通过相反的方式就可以解密文本，实际生产中当然不会像下面这么简单的加密，下面我们只是做个示意</p><pre><code>public static void encrypt(File src, File dest) {    FileReader fr = null;    FileWriter fw = null;    try {        fr = new FileReader(src);        fw = new FileWriter(dest);        int tmp = 0;        while ((tmp = fr.read()) != -1) {            fw.write(tmp+1);        }    } catch (FileNotFoundException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    } finally {        close(fw, fr);    }}public static void decrypt(File src, File dest) {    FileReader fr = null;    FileWriter fw = null;    try {        fr = new FileReader(src);        fw = new FileWriter(dest);        int tmp = 0;        while ((tmp = fr.read()) != -1) {            fw.write(tmp-1);        }    } catch (FileNotFoundException e) {        e.printStackTrace();    } catch (IOException e) {        e.printStackTrace();    } finally {        close(fw, fr);    }}public static void main(String[] args) {    File src = new File("E:\\iotest\\1.txt");    File dest = new File("E:\\iotest\\1_jiami.txt");    File dest2 = new File("E:\\iotest\\1_jiemi.txt");    encrypt(src, dest);    decrypt(dest, dest2);}</code></pre><p>上面代码中处理方式很简单，仅仅做了一个字符加1处理，然后解密在字符上进行减1处理，便能达到一个加密解密的效果，效果如下<br>原始密文：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">加密后的文本：</span><br><span class="line"></span><br><span class="line">```赶充扙佡帯戒功為二</span><br></pre></td></tr></tbody></table></figure></div><p>解密后的文本：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 6.3 图片处理</span><br><span class="line">图片文件中存放中图片的分辨率，以及每个像素的色值等信息。我们经常看见如photoshop这类软件对图片进行旋转，扭曲，滤镜等处理，就是对图片中的二进制信息进行一个矩阵变换。下面我们试着做一个图片反相效果。</span><br><span class="line">做这个处理前有两个问题需要考虑：</span><br><span class="line">1）由于平时使用的jpg采用了压缩算法，所以图片中的每个字节并不是图片本身的像素信息，因此我们选择一个bmp格式的图片，来对每一位进行处理，以便达到我们想要的效果。</span><br><span class="line">2）基本所有的二进制文件，图片，音频等文件都有一个头信息，存放该文件的一些基本信息，这些基本信息决定了这个文件是一个bmp图片或者是个gif图片或者是个jpg图片。因此我们对bmp图片做处理时不能破坏bmp文件的头信息。我们知道bmp文件很大，是因为他没有进行压缩，文件内容保存的是图片上对应的像素点的颜色值信息，因此我们队这些颜色值信息做一个处理，即可以得到一些特别的效果。</span><br><span class="line">代码如下：</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">public static void imageFilter(File src, File dest) {</span><br><span class="line">    FileInputStream fis = null;</span><br><span class="line">    FileOutputStream fos = null;</span><br><span class="line">    try {</span><br><span class="line">        fis = new FileInputStream(src);</span><br><span class="line">        fos = new FileOutputStream(dest);</span><br><span class="line">        int b = 0;</span><br><span class="line">        int hasRead = 0;</span><br><span class="line">        int headSize = 8*12;</span><br><span class="line">        while ((b = fis.read()) != -1) {</span><br><span class="line">            hasRead++;</span><br><span class="line">            if(hasRead>headSize){</span><br><span class="line">                fos.write(-b);</span><br><span class="line">            }else{</span><br><span class="line">                fos.write(b);</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    } catch (FileNotFoundException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } catch (IOException e) {</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    } finally {</span><br><span class="line">        close(fos, fis);</span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) {</span><br><span class="line">    File src = new File("E:\\iotest\\1.bmp");</span><br><span class="line">    File dest = new File("E:\\iotest\\1_copy.bmp");</span><br><span class="line">    imageFilter(src, dest);//800k的文件执行时间大概好几秒，比较长，这里只是做个示意处理</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>上面代码中写数据时，如果字节长度小于headSize则原样输出（headSize我这里取的是12个字节，bmp头信息具体多大我并没有去查询。如果取太小头信息被破坏，bmp文件将不是bmp文件。因此取几十个字节只要保证头信息完整即可。），大于headSize的部分进行一个处理，我们对颜色值取反。效果如下：<br>原图：</p><p><a href="https://img-blog.csdn.net/20171031164534851?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI1MDg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" data-fancybox="group" data-caption="这里写图片描述" class="fancybox"><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20171031164534851?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI1MDg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" title="这里写图片描述"></a></p><p>处理后图片：<a href="https://img-blog.csdn.net/20171031164603840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI1MDg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" data-fancybox="group" data-caption="这里写图片描述" class="fancybox"><img alt="这里写图片描述" data-src="https://img-blog.csdn.net/20171031164603840?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMjI1MDg3NQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" class="lazyload" title="这里写图片描述"></a></p><p>通过上面三个的示例可以大致了解java io能做些什么。当然上面只是一个简单的处理，并不能用于实际生产，这里只是说明持有二进制数据，你将可以对文件为所欲为。</p><p>————————————————<br>版权声明：本文为CSDN博主「忧落」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/u012250875/article/details/78341874" target="_blank" rel="noopener">https://blog.csdn.net/u012250875/article/details/78341874</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java创建对象</title>
      <link href="/2020/05/16/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
      <url>/2020/05/16/java%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="创建对象的方式"><a href="#创建对象的方式" class="headerlink" title="创建对象的方式"></a>创建对象的方式</h2><ul><li>用new关键字创建</li><li>调用对象的clone方法</li><li>利用反射，调用Class类的或者是Constructor类的newInstance（）方法</li><li>用反序列化，调用ObjectInputStream类的readObject（）方法</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA泛型通配符</title>
      <link href="/2020/05/15/JAVA%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/"/>
      <url>/2020/05/15/JAVA%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><p><strong>通常情况下，T，E，K，V，？是这样约定的：</strong></p><ul><li>？表示不确定的 java 类型</li><li>T (type) 表示具体的一个java类型</li><li>K V (key value) 分别代表java键值中的Key Value</li><li><p>E (element) 代表Element</p></li><li><p>上界通配符 <!--? entends E--></p></li><li><p>下界通配符<!--? super E--></p></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Adaboost</title>
      <link href="/2020/05/11/Adaboost/"/>
      <url>/2020/05/11/Adaboost/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="Boosting作用"><a href="#Boosting作用" class="headerlink" title="Boosting作用"></a>Boosting作用</h3><p>如果一个弱分类器的错误率低于50%，那么通过boosting之后可以使得弱分类器在训练集上的错误率降低到0%</p><h3 id="Boosting框架"><a href="#Boosting框架" class="headerlink" title="Boosting框架"></a>Boosting框架</h3><ul><li><p>获取第一个分类器$f_1(x)$</p></li><li><p>找到另一个分类器$f_2(x)$去帮助$f_1(x)$</p><ul><li>$f_2(x)$要弥补$f_1(x)$，要和$f_1(x)$互补</li></ul></li><li>获取第二个分类器$f_2(x)$</li><li>……</li><li>最后，combine所有的分类器</li><li>注意（每个分类器的学习是有顺序的）</li></ul><h3 id="Adaboosting"><a href="#Adaboosting" class="headerlink" title="Adaboosting"></a>Adaboosting</h3><p>adaboosting的思想是：</p><ul><li><p>每一组数据都有一个weight，初始weight都为1 ,数据集$data1$</p></li><li><p>用数据训练一个分类器$f_1(x)$</p></li><li><p>调整数据的weight，得到数据集$data2$，使得$f_1(x)$在新数据上的分类正确率降低到50%</p><ul><li>其实这个weight最终会影响损失函数，使得损失函数加权，对错误的分类和正确的分类的权值不同</li><li>二分类的正确率不可能低于50%</li><li>调整weight的策略是，如果一个数据分类错误，那么这个数据的weight乘一个d，如果数据分类正确，那么该数据的weight除以一个d，之后，使得分类正确的加权损失和分类错误的损失相等，就可以解出d。</li></ul></li><li>在数据集$data2$上训练分类器$f_2(x)$</li><li>……</li><li>最后就到了combine阶段，对不同的分类器加权和，权值的设置和d有关。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>频率学派和贝叶斯学派</title>
      <link href="/2020/05/11/%E9%A2%91%E7%8E%87%E5%AD%A6%E6%B4%BE%E5%92%8C%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AD%A6%E6%B4%BE/"/>
      <url>/2020/05/11/%E9%A2%91%E7%8E%87%E5%AD%A6%E6%B4%BE%E5%92%8C%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%AD%A6%E6%B4%BE/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="频率学派和贝叶斯学派"><a href="#频率学派和贝叶斯学派" class="headerlink" title="频率学派和贝叶斯学派"></a>频率学派和贝叶斯学派</h3><p>概率模型的训练过程就是参数估计的过程。**</p><p>对于参数估计，统计学界的两个学派分别提供了不同的解决方案：</p><ul><li>频率主义学派认为参数虽然未知，但却是客观存在的固定值，因此可以通过优化极大似然函数等准则来确定参数值。</li><li>贝叶斯学派则认为参数是未观察到的随机变量，其本身也可有分布，因此可以假定参数服从一个先验分布，然后，基于观测到的数据来计算参数的后验分布。</li></ul><p>所以，对于贝叶斯公式：</p><p><a href="https://www.zhihu.com/equation?tex=P%28%5Ctheta+%7Cdata%29%3D%5Cfrac%7BP%28data%7C%5Ctheta%29P%28%5Ctheta%29%7D%7BP%28data%29%7D%5Cpropto+P%28data%7C%5Ctheta%29P%28%5Ctheta%29" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=P%28%5Ctheta+%7Cdata%29%3D%5Cfrac%7BP%28data%7C%5Ctheta%29P%28%5Ctheta%29%7D%7BP%28data%29%7D%5Cpropto+P%28data%7C%5Ctheta%29P%28%5Ctheta%29" class="lazyload" title="[公式]"></a></p><p>其中$p(data)$与我们所估计的$\theta$是独立的，所以我们不用考虑它。我们称$p(\theta|data)$为后验分布，$p(\theta)$是先验分布，$p(data|\theta)$为似然函数。</p><p>频率学派只需对$p(data|\theta)$做极大似然估计。</p><p>贝叶斯学派需要根据先指定一个先验概率的分布，再通过先验×似然求出后验。</p><h3 id="如何指定先验概率的分布？"><a href="#如何指定先验概率的分布？" class="headerlink" title="如何指定先验概率的分布？"></a>如何指定先验概率的分布？</h3><p>下面解释了为何在二分类问题中使先验概率为Beta分布，在多分类问题中使先验分布为狄利克雷分布。</p><p><strong>二项分布</strong></p><p>二项分布是N重伯努利分布，即为X ~ B(n, p). 概率密度公式为：</p><p><a href="https://www.zhihu.com/equation?tex=P%28K+%3D+k%29+%3D+%5Cbegin%7Bpmatrix%7D+n%5C%5C+k%5C%5C+%5Cend%7Bpmatrix%7Dp%5Ek%7B%281-p%29%7D%5E%7Bn-k%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=P%28K+%3D+k%29+%3D+%5Cbegin%7Bpmatrix%7D+n%5C%5C+k%5C%5C+%5Cend%7Bpmatrix%7Dp%5Ek%7B%281-p%29%7D%5E%7Bn-k%7D" class="lazyload" title="[公式]"></a></p><p><strong>多项分布</strong></p><p>多项分布，是二项分布扩展到多维的情况. 多项分布是指单次试验中的随机变量的取值不再是0-1的，而是有多种离散值可能（1,2,3…,k）.概率密度函数为：</p><p><a href="https://www.zhihu.com/equation?tex=P%28x_1%2C+x_2%2C+...%2C+x_k%3B+n%2C+p_1%2C+p_2%2C+...%2C+p_k%29+%3D+%5Cfrac%7Bn%21%7D%7Bx_1%21...x_k%21%7D%7Bp_1%7D%5E%7Bx_1%7D...%7Bp_k%7D%5E%7Bx_k%7D+" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=P%28x_1%2C+x_2%2C+...%2C+x_k%3B+n%2C+p_1%2C+p_2%2C+...%2C+p_k%29+%3D+%5Cfrac%7Bn%21%7D%7Bx_1%21...x_k%21%7D%7Bp_1%7D%5E%7Bx_1%7D...%7Bp_k%7D%5E%7Bx_k%7D+" class="lazyload" title="[公式]"></a></p><p><strong>Gamma函数</strong></p><p>Gamma函数的定义：</p><p><a href="https://www.zhihu.com/equation?tex=%5CGamma%28x%29+%3D+%5Cint_0%5E%5Cinfty+t%5E%7Bx-1%7De%5E%7B-t%7Ddt" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5CGamma%28x%29+%3D+%5Cint_0%5E%5Cinfty+t%5E%7Bx-1%7De%5E%7B-t%7Ddt" class="lazyload" title="[公式]"></a></p><p>分部积分后，可以发现Gamma函数如有这样的性质：</p><p><a href="https://www.zhihu.com/equation?tex=%5CGamma%28x%2B1%29+%3D+x%5CGamma%28x%29" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5CGamma%28x%2B1%29+%3D+x%5CGamma%28x%29" class="lazyload" title="[公式]"></a></p><p>Gamma函数可以看成是阶乘在实数集上的延拓，具有如下性质：</p><p><a href="https://www.zhihu.com/equation?tex=%5CGamma%28n%29+%3D+%28n-1%29%21" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5CGamma%28n%29+%3D+%28n-1%29%21" class="lazyload" title="[公式]"></a></p><p><strong>Beta分布</strong></p><p>Beta分布的定义：对于参数$\alpha$ > 0,$ \beta$ > 0, 取值范围为[0, 1]的随机变量x的概率密度函数为：</p><p><a href="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+f%28x%3B+%5Calpha%2C+%5Cbeta%29+%3D+%5Cfrac%7B1%7D%7BB%28%5Calpha%2C+%5Cbeta%29%7D+x%5E%7B%5Calpha+-+1%7D+%7B%281-x%29%7D%5E%7B%5Cbeta-1%7D+%5Cend%7Balign%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+f%28x%3B+%5Calpha%2C+%5Cbeta%29+%3D+%5Cfrac%7B1%7D%7BB%28%5Calpha%2C+%5Cbeta%29%7D+x%5E%7B%5Calpha+-+1%7D+%7B%281-x%29%7D%5E%7B%5Cbeta-1%7D+%5Cend%7Balign%7D" class="lazyload" title="[公式]"></a> (1)</p><p>其中，</p><p><a href="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%5Cfrac%7B1%7D%7BB%28%5Calpha%2C+%5Cbeta%29%7D+%3D+%5Cfrac%7B%5CGamma%28%5Calpha+%2B+%5Cbeta%29%7D%7B%5CGamma%28%5Calpha%29%5CGamma%28%5Cbeta%29%7D+%5Cend%7Balign%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+%5Cfrac%7B1%7D%7BB%28%5Calpha%2C+%5Cbeta%29%7D+%3D+%5Cfrac%7B%5CGamma%28%5Calpha+%2B+%5Cbeta%29%7D%7B%5CGamma%28%5Calpha%29%5CGamma%28%5Cbeta%29%7D+%5Cend%7Balign%7D" class="lazyload" title="[公式]"></a> (2)</p><p><strong>共轭先验分布</strong></p><p>在贝叶斯概率理论中，如果后验概率P(θ|x)和先验概率p(θ)满足同样的分布律，那么，先验分布和后验分布被叫做共轭分布，同时，先验分布叫做似然函数的共轭先验分布。</p><p><a href="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+P%28%5Ctheta+%7C+x%29+%3D+%5Cfrac%7BP%28%5Ctheta%2C+x%29%7D+%7BP%28x%29%7D+%5Cend%7Balign%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+P%28%5Ctheta+%7C+x%29+%3D+%5Cfrac%7BP%28%5Ctheta%2C+x%29%7D+%7BP%28x%29%7D+%5Cend%7Balign%7D" class="lazyload" title="[公式]"></a> </p><p>Beta分布是二项式分布的共轭先验分布，而狄利克雷(Dirichlet)分布是多项式分布的共轭分布。</p><p>共轭的意思是，以Beta分布和二项式分布为例，数据符合二项分布的时候，参数的先验分布和后验分布都能保持Beta分布的形式，这种形式不变的好处是，我们能够在先验分布中赋予参数很明确的物理意义，这个物理意义可以延续到后续分布中进行解释，同时从先验变换到后验过程中从数据中补充的知识也容易有物理解释。</p><p><strong>狄利克雷分布</strong></p><p>Dirichlet的概率密度函数为：</p><p><a href="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+f%28x_1%2C+x_2%2C+...%2C+x_k%3B+%5Calpha_1%2C+%5Calpha_2%2C+...%2C+%5Calpha_k%29+%3D+%5Cfrac%7B1%7D%7BB%28%5Calpha%29%7D%5Cprod_%7Bi%3D1%7D%5E%7Bk%7D%7Bx_i%7D%5E%7B%5Calpha%5Ei-1%7D+%5Cend%7Balign%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+f%28x_1%2C+x_2%2C+...%2C+x_k%3B+%5Calpha_1%2C+%5Calpha_2%2C+...%2C+%5Calpha_k%29+%3D+%5Cfrac%7B1%7D%7BB%28%5Calpha%29%7D%5Cprod_%7Bi%3D1%7D%5E%7Bk%7D%7Bx_i%7D%5E%7B%5Calpha%5Ei-1%7D+%5Cend%7Balign%7D" class="lazyload" title="[公式]"></a> (4)</p><p>其中，</p><p><a href="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+B%28%5Calpha%29+%3D+%5Cfrac%7B%5Cprod_%7Bi%3D1%7D%5E%7Bk%7D%5CGamma%28%5Calpha%5Ei%29%7D%7B%5CGamma%28%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%5Calpha%5Ei%29%7D%2C+%5Csum_%7Bi%3D1%7D%5E%7Bk%7Dx%5Ei+%3D+1+%5Cend%7Balign%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%7D+B%28%5Calpha%29+%3D+%5Cfrac%7B%5Cprod_%7Bi%3D1%7D%5E%7Bk%7D%5CGamma%28%5Calpha%5Ei%29%7D%7B%5CGamma%28%5Csum_%7Bi%3D1%7D%5E%7Bk%7D%5Calpha%5Ei%29%7D%2C+%5Csum_%7Bi%3D1%7D%5E%7Bk%7Dx%5Ei+%3D+1+%5Cend%7Balign%7D" class="lazyload" title="[公式]"></a> (5)</p><p>根据Beta分布、二项分布、Dirichlet分布、多项式分布的公式，我们可以验证上一小节中的结论 — Beta分布是二项式分布的共轭先验分布，而狄利克雷(Dirichlet)分布是多项式分布的共轭分布。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>常用快捷键及操作</title>
      <link href="/2020/05/03/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E6%93%8D%E4%BD%9C/"/>
      <url>/2020/05/03/%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%8F%8A%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><ul><li>ctrl+shift+enter 以管理员身份打开cmd</li><li>在文件资源管理器的搜索栏 输入cmd 即可在对应目录下打开cmd</li><li>win+v  查看剪切板</li></ul><h3 id="IDEA"><a href="#IDEA" class="headerlink" title="IDEA"></a>IDEA</h3><ul><li>psvm 生成main函数</li><li>sout 快速println</li><li>ctrl+shift+/  快速生成注释</li><li>ctrl+/  单行注释</li><li>ctrl+alt+L   格式化</li><li>ctrl+alt+space、ctrl+alt+v 内容辅助键</li><li>ctrl+alt+T 包围代码块 </li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/2020/04/26/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/04/26/lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>任何接口，如果只包含唯一一个抽象方法，那么它就是一个函数式接口。</p><p>对于函数式接口，我们可以通过lambda表达式来创建该接口的对象。</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>使用lambda表达式可以避免匿名内部类定义过多，使得代码看起来更加简洁，去掉了一堆没有意义的代码，只留下了核心逻辑。</p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>对于这种一般只用一次的类，为了使得代码更加简洁，经历了以下过程：</p><ul><li><p>普通实现类：最原始的方法，定义了抽象接口之后，定义一个接口的实现类，再new一个对象，再调用对象的方法。</p></li><li><p>静态内部类： 可以把这个接口的实现类定义到需要用到的类的内部，类前面加上static，为静态内部类</p></li><li><p>局部内部类：可以把这个接口的实现类定义到需要用到的类的方法内部，为局部内部类</p></li><li><p>匿名内部类：虽然这个接口有实现类，但是这个类没有名字，只能通过接口或者父类来new这个实现类的对象。</p><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">>接口  变量 =<span class="keyword">new</span> 接口(){</span><br><span class="line"></span><br><span class="line">      接口中的方法实现</span><br><span class="line"></span><br><span class="line">>}</span><br><span class="line">><span class="comment">//在作为参数时</span></span><br><span class="line">><span class="keyword">new</span> 接口(){}</span><br></pre></td></tr></tbody></table></figure></div></blockquote></li><li><p>lambda表达式：观察到匿名内部类还有继续简化的空间，比如接口 写了两次，还有一个繁琐的new关键字，lambda做了如下优化。因为函数式接口里面只有一个方法，所以{ }里面直接写的就是那个方法的实现。</p><blockquote><p>接口 变量 =（）-> { }   </p><p>如果只有一行<code>return xxx</code>的代码，完全可以用更简单的写法.</p></blockquote></li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程</title>
      <link href="/2020/04/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
      <url>/2020/04/26/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="基础多线程"><a href="#基础多线程" class="headerlink" title="基础多线程"></a>基础多线程</h2><h3 id="线程创建与启动"><a href="#线程创建与启动" class="headerlink" title="线程创建与启动"></a>线程创建与启动</h3><p>java用多线程非常简单，只需要两步</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">Thread thread=<span class="keyword">new</span> thread();</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">thread.start();</span><br></pre></td></tr></tbody></table></figure></div><p>有的教程讲的特别复杂，但是核心就这两步。</p><p>其中start()方法是最核心的，里面有一个  native  start0（）方法，看到这个名字就知道线程的启动的具体过程已经不受java控制了。</p><p>但是线程启动后，要干的事情，java还是能控制的，也就是run() 方法。线程启动后就会去执行run() 方法，做线程应该做的事情。</p><p>run() 方法有两种实现步骤：</p><ul><li>Thread类实现了Runnable 接口，也就是说Thread中有一个默认的run()方法，我们可以新定义一个类继承Thread类，重写其中的run()方法，run()方法中实现我们自己想让线程做的事情。</li><li>我们定义一个新的类 实现Runnable 接口，然后把这个类作为参数传给Thread类，因为Thread类的构造方法中有一种这样的构造方法。</li></ul><p>对比这两种方法，其实没什么本质区别，都是要对Thread中默认的run()方法进行改写，因为默认的run()方法里面是空的。第一种方法说白了就是在改写run()方法的同时改了Thread类的名字，但是第二种通过构造函数没有改名字。</p><hr><p>不管是通过哪种方式，<strong>值得注意的是</strong>，线程必须要通过start()方法才能启动（因为start()方法里面调用的是native的方法），然后线程会自动执行我们定义的run()方法，如果我们不调用start() 方法，直接调用Thread.run()方法，这和调用一个普通类的方法没什么两样，并没有启动新的线程，仍然还是在原来的线程中执行。</p><h3 id="线程停止"><a href="#线程停止" class="headerlink" title="线程停止"></a>线程停止</h3><p>通常通过一个外部标志位的方式停止线程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> flag=<span class="keyword">true</span>; <span class="comment">//当想要停止线程时，通过一个公开的方法将flag设置为false;</span></span><br><span class="line">run(){</span><br><span class="line">    <span class="keyword">while</span>(flag){</span><br><span class="line">}   </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程休眠"><a href="#线程休眠" class="headerlink" title="线程休眠"></a>线程休眠</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.sleep(<span class="number">1000</span>)  <span class="comment">//里面的单位是毫秒,sleep()里面也会调用native方法，将当前进程休眠</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程礼让"><a href="#线程礼让" class="headerlink" title="线程礼让"></a>线程礼让</h3><p>线程礼让通过如下代码实习，礼让即当前线程让出cpu，然后大家再一起竞争cpu</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.yeild(); <span class="comment">//注意，调用时调用的是Thread类的方法，而不是对象的方法，</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程强制执行"><a href="#线程强制执行" class="headerlink" title="线程强制执行"></a>线程强制执行</h3><p>调用后强制执行该线程，阻塞其他线程</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.join()<span class="comment">//调用时调用的是thread的对象</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread.State<span class="comment">//是一个枚举类型，枚举了所有的线程状态</span></span><br><span class="line">thread.getState()<span class="comment">//可以获取线程的状态</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线程的优先级用数字表示，范围从1~10</span></span><br><span class="line">Thread.MIN_PRORITY=<span class="number">1</span>;</span><br><span class="line">Thread.MAX_PRIORITY=<span class="number">10</span>;</span><br><span class="line">Thread.NORM_PRIORITY=<span class="number">5</span>;</span><br><span class="line"><span class="comment">//使用以下方法改变或获取优先级</span></span><br><span class="line">getPriority()</span><br><span class="line">setPriority(<span class="keyword">int</span> x)</span><br></pre></td></tr></tbody></table></figure></div><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>jvm不管守护线程有没有结束，只要用户线程结束了，都会退出</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread.setDaemon(<span class="keyword">true</span>) <span class="comment">//将线程设置为守护线程</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 对一个方法使用，如果这个方法不是静态方法，那么锁的就是这个类所属的对象，即 <span class="keyword">this</span></span><br><span class="line">    如果这个类是静态方法，那么锁的就是这里类，即  类<span class="class">.<span class="keyword">class</span></span></span><br><span class="line"><span class="class"><span class="title">synchronized</span>（）</span>{</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">可以锁任意对象</span><br></pre></td></tr></tbody></table></figure></div><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><p>当一个代码块被加synchronized 加锁以后，线程在这个代码块的地方只能单线程的执行了，但是这时候，此线程可能会需要和其他线程配合，比如需要其他线程给自己一个东西，但是其他线程没准备好，那么此时该线程就需要暂停一下，否则线程就一下子执行完了，那么这个方法就是wait(),执行wait后，线程让出cpu，让其他线程执行，其他线程把东西准备好之后，调用notifyAll()，唤醒所有被暂停的线程，让他们再次去抢占cpu，这就是线程通信。</p><h4 id="虚假唤醒"><a href="#虚假唤醒" class="headerlink" title="虚假唤醒"></a>虚假唤醒</h4><p>当一个条件满足时，很多线程都被唤醒了，但是只有其中部分是有用的唤醒，其它的唤醒都是无用功 。</p><p>比如说买货，如果商品本来没有货物，突然进了一件商品，这是所有的线程都被唤醒了 ，但是只能一个人买，所以其他人都是假唤醒，获取不到对象的锁。所以需要循环判断，当被一个人买走后，其他人又必须等待，所以wait()必须放在while里面，当被唤醒时，再次判断，如果不满足又继续wait。如果用if就会虚假唤醒，逻辑就不对了。</p><h3 id="synchronized和ReentrantLock"><a href="#synchronized和ReentrantLock" class="headerlink" title="synchronized和ReentrantLock"></a>synchronized和ReentrantLock</h3><p>synchronized一个关键字其实包含了加锁和解锁的步骤，而利用ReentrantLock把这两步分开了，灵活性更高。</p><p>比如synchronized在获取锁阶段如果获取不到，就会卡在那里一直去获取锁，这可能导致死锁哦，而ReentrantLock可以利用trylock()方法去尝试获取，如果获取不到，就返回false，这样就不会死锁了。</p><p>所以使用ReentrantLock比使用synchronized更安全</p><h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p>condition必须先拿到锁</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lock lock=<span class="keyword">new</span> ReentactLock();</span><br><span class="line">Codition cod1=lock.newCodition();</span><br><span class="line">Codition cod2=lock.newCodition();</span><br></pre></td></tr></tbody></table></figure></div><p>Condition是条件锁，可以设置多个条件队列，从而实现队列级别的精准唤醒。</p><p>一个内置锁仅仅能相应一个条件队列。这有个缺陷。就是当一个锁相应多个条件谓词时，多个条件谓词仅仅能公用一个条件队列，这时候唤醒等待线程时有可能出现唤醒丢失的情况。</p><p>显式锁和显式条件队列避免了这个问题，一个显示锁能够相应多个条件Condition,一个Condition维护一个条件队列，这样对于多个条件谓词，比方isFull和isEmpty,能够使用两个Condition。对每一个条件谓词单独await，唤醒时能够单独signal。效率更高。</p><h2 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h2><p><strong>管程，指的是管理共享变量以及对其操作过程，让它们支持并发访问</strong></p><p>其实，就是把共享变量以及各个进程之间操作这个变量的方法放在同一个类中，方便管理，而其他类只需要调用管程中的方法就好了。</p><p>一个管程定义了一个数据结构和可以并发进程所运行的一组操作，这组操作能同步进程和改变管程中的数据</p><ol><li><p>数据</p></li><li><p>方法</p></li><li><p>它的方法可以同步并发进程的操作</p></li></ol><p>说白了，管程就是一个专门为并发编程提出的概念，它表示一个对象自己维护自己的状态，而且可以依据自身状态来同步并发的线程操作。而不是把这样的同步的手段交给调用者来处理。</p><p>参考：<a href="https://www.cnblogs.com/lcchuguo/p/5382760.html" target="_blank" rel="noopener">https://www.cnblogs.com/lcchuguo/p/5382760.html</a></p><h2 id="三个同步工具类"><a href="#三个同步工具类" class="headerlink" title="三个同步工具类"></a>三个同步工具类</h2><h3 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h3><p>是一个计时器闭锁，通过它可以完成过类似于阻塞当前进程的功能，即：一个线程或多个线程一直等待，直到其他线程执行的操作完成。CountDownLatch用一个给定的计数器来初始化，该计数器的操作是原子操作，即同时只能有一个线程去操作该计数器。调用该类await方法的线程会一直处于阻塞状态，直到其他线程调用countDown方法使当前计数器的值变为零，每次调用countDown计数器的值减1。当计数器值减至零时，所有因调用await()方法而处于等待状态的线程就会继续往下执行。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.demo.CountDownLatchDemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.CountDownLatch;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 主线程等待子线程执行完成再执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountdownLatchTest1</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        ExecutorService service = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">3</span>; i++) {</span><br><span class="line">            Runnable runnable = <span class="keyword">new</span> Runnable() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        System.out.println(<span class="string">"子线程"</span> + Thread.currentThread().getName() + <span class="string">"开始执行"</span>);</span><br><span class="line">                        Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                        System.out.println(<span class="string">"子线程"</span>+Thread.currentThread().getName()+<span class="string">"执行完成"</span>);</span><br><span class="line">                        latch.countDown();<span class="comment">//当前线程调用此方法，则计数减一</span></span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            };</span><br><span class="line">            service.execute(runnable);</span><br><span class="line">        }</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> {</span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+Thread.currentThread().getName()+<span class="string">"等待子线程执行完成..."</span>);</span><br><span class="line">            latch.await();<span class="comment">//阻塞当前线程，直到计数器的值为0</span></span><br><span class="line">            System.out.println(<span class="string">"主线程"</span>+Thread.currentThread().getName()+<span class="string">"开始执行..."</span>);</span><br><span class="line">        } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h3><p>CyclicBarrier较CountDownLatch而言主要多了两个功能：</p><ol><li>支持重置状态，达到循环利用的目的。这也是Cyclic的由来。CyclicBarrier中有一个内部类Generation，代表当前的同步处于哪一个阶段。当最后一个任务完成，执行任务的线程会通过nextGeneration方法来重置Generation。也可以通过CyclicBarrier的reset方法来重置Generation。</li><li>支持barrierCommand，当最后一个任务运行完成，执行任务的线程会检查CyclicBarrier的barrierCommand是否为null，如果不为null，则运行该任务。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>{</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>{</span><br><span class="line">        </span><br><span class="line">        CyclicBarrier barrier;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TaskThread</span><span class="params">(CyclicBarrier barrier)</span> </span>{</span><br><span class="line">            <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">        }</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">            <span class="keyword">try</span> {</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(getName() + <span class="string">" 到达栅栏 A"</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(getName() + <span class="string">" 冲破栅栏 A"</span>);</span><br><span class="line">                </span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">                System.out.println(getName() + <span class="string">" 到达栅栏 B"</span>);</span><br><span class="line">                barrier.await();</span><br><span class="line">                System.out.println(getName() + <span class="string">" 冲破栅栏 B"</span>);</span><br><span class="line">            } <span class="keyword">catch</span> (Exception e) {</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            }</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">5</span>;</span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(threadNum, <span class="keyword">new</span> Runnable() {</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" 完成最后任务"</span>);</span><br><span class="line">            }</span><br><span class="line">        });</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i < threadNum; i++) {</span><br><span class="line">            <span class="keyword">new</span> TaskThread(barrier).start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h3><p>synchronized的语义是互斥锁，就是在同一时刻，只有一个线程能获得执行代码的锁。但是现实生活中，有好多的场景，锁不止一把。</p><p>比如说，又到了十一假期，买票是重点，必须圈起来。在购票大厅里，有5个售票窗口，也就是说同一时刻可以服务5个人。要实现这种业务需求，用synchronized显然不合适，因为synchronized只能同时服务一个人。</p><p>查看Java并发工具，发现有一个Semaphore类，天生就是处理这种情况的。</p><p>先用Semaphore实现一个购票的小例子，来看看如何使用.</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> semaphore;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> </span>{</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">        Semaphore windows = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);  <span class="comment">// 声明5个窗口</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i < <span class="number">8</span>; i++) {</span><br><span class="line">            <span class="keyword">new</span> Thread() {</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>{</span><br><span class="line">                    <span class="keyword">try</span> {</span><br><span class="line">                        windows.acquire();  <span class="comment">// 占用窗口</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">": 开始买票"</span>);</span><br><span class="line">                        sleep(<span class="number">2000</span>);  <span class="comment">// 睡2秒，模拟买票流程</span></span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">": 购票成功"</span>);</span><br><span class="line">                        windows.release();  <span class="comment">// 释放窗口</span></span><br><span class="line">                    } <span class="keyword">catch</span> (InterruptedException e) {</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    }</span><br><span class="line">                }</span><br><span class="line">            }.start();</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>Semaphore和线程池的区别</strong></p><p>信号量Semaphore是一个并发工具类，用来控制可同时并发的线程数，其内部维护了一组虚拟许可，通过构造器指定许可的数量，每次线程执行操作时先通过acquire方法获得许可，执行完毕再通过release方法释放许可。如果无可用许可，那么acquire方法将一直阻塞，直到其它线程释放许可。</p><p>线程池用来控制实际工作的线程数量，通过线程复用的方式来减小内存开销。线程池可同时工作的线程数量是一定的，超过该数量的线程需进入线程队列等待，直到有可用的工作线程来执行任务。</p><p>使用Seamphore，你创建了多少线程，实际就会有多少线程进行执行，只是可同时执行的线程数量会受到限制。但使用线程池，你创建的线程只是作为任务提交给线程池执行，实际工作的线程由线程池创建，并且实际工作的线程数量由线程池自己管理。</p><p>简单来说，线程池实际工作的线程是work线程，不是你自己创建的，是由线程池创建的，并由线程池自动控制实际并发的work线程数量。而Seamphore相当于一个信号灯，作用是<strong>对线程做限流</strong>，Seamphore可以对你自己创建的的线程做限流（也可以对线程池的work线程做限流），Seamphore的限流必须通过手动acquire和release来实现。</p><h2 id="并发原理"><a href="#并发原理" class="headerlink" title="并发原理"></a>并发原理</h2><h3 id="并发编程中的三个概念"><a href="#并发编程中的三个概念" class="headerlink" title="并发编程中的三个概念"></a>并发编程中的三个概念</h3><p>并发编程必须保证原子性、可见性和有序性</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>就是说一个操作或者多个操作在执行过程中是不会被打断的</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指当多个线程访问同一个变量时，如果一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>即程序的执行顺序按照代码的先后顺序执行。</p><p>编译器为了提高运行效率，会对指令进行重排，虽然不会保证程序执行顺序同代码中的顺序一致，但是运行结果是和代码顺序执行的结果是一致的(重排时会考虑数据依赖性)</p><p>但是在多线程环境下，指令重排就会出问题。</p><h3 id="总线锁和缓存一致性协议"><a href="#总线锁和缓存一致性协议" class="headerlink" title="总线锁和缓存一致性协议"></a>总线锁和缓存一致性协议</h3><p>在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LOCK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p><p>但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p><p>所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p>volatle 意为“不稳定的”，限定在变量前就是说这个变量是不稳定的，那么在多线程环境下，线程每次都应该从内存中读取该值，而不是从线程的缓存中读取值。</p><p>也就是说，volatile保证了可见性。（锁保证原子性，volatile保证可见性和有序性）</p><p>volatile还能禁止指令重排序，也就是保证了有序性。volatile禁止指令重排的意思是</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语句<span class="number">1</span></span><br><span class="line">语句<span class="number">2</span></span><br><span class="line"><span class="keyword">volatile</span> 语句<span class="number">3</span></span><br><span class="line">语句<span class="number">4</span></span><br><span class="line">语句<span class="number">5</span></span><br></pre></td></tr></tbody></table></figure></div><p>在执行语句3之前，语句1和语句2可以重排，但当执行语句3时，语句1和语句2都必须执行完毕。</p><p>只有语句3执行完之后，语句4和语句5才可以参与执行，并且他们之间是可以重排的</p><p>详解：<a href="https://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3920373.html</a></p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p>CAS全称是compare and swap，就是比较并替换的意思。一直比较并替换，如果成功就返回，如果失败就一直重试。是借助C来调用CPU底层指令实现的。</p><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p>CAS存在ABA问题。因为CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA问题的解决思路就是使用版本号。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量i＝2,j=a，合并一下ij=2a，然后用CAS来操作ij。从Java1.5开始JDK提供了<strong>AtomicReference类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行CAS操作。</strong></p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS全称AbstractQueuedSynchronizer。用大白话说，AQS就是基于CLH队列，用volatile修饰共享变量state，线程通过CAS去改变状态符，成功则获取锁成功，失败则进入等待队列，等待被唤醒。</p><p><a href="https://img-blog.csdnimg.cn/20181128142923147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211bGluc2VuNzc=,size_16,color_FFFFFF,t_70" data-fancybox="group" data-caption="在这里插入图片描述" class="fancybox"><img alt="在这里插入图片描述" data-src="https://img-blog.csdnimg.cn/20181128142923147.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L211bGluc2VuNzc=,size_16,color_FFFFFF,t_70" class="lazyload" title="在这里插入图片描述"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">}</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>{</span><br><span class="line">        state = newState;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>{</span><br><span class="line">        <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>AQS底层使用了模板方法模式。自定义同步器时需要重写下面几个 AQS 提供的模板方法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="原子类"><a href="#原子类" class="headerlink" title="原子类"></a>原子类</h3><p>原子类就是基于volatile和CAS实现的线程安全的类</p><h3 id="梳理"><a href="#梳理" class="headerlink" title="梳理"></a>梳理</h3><p>CAS保证原子性，volatile保证可见性和有序性。把这些特性整合在一起，就形成了整个concurrent包得以实现的基石。如果我们仔细分析concurrent包的源代码实现，会发现一个通用化的实现模式：</p><ol><li>首先，声明共享变量为volatile；</li><li>然后，使用CAS的原子条件更新来实现线程之间的同步；</li><li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li></ol><p>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。从整体来看，concurrent包的实现示意图如下：</p><p><a href="http://dl.iteye.com/upload/attachment/0083/2584/b7b2472f-6b93-3f85-9e44-29a9ff774c8e.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="http://dl.iteye.com/upload/attachment/0083/2584/b7b2472f-6b93-3f85-9e44-29a9ff774c8e.png" class="lazyload" title="img"></a></p><h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><h3 id="可重入锁与不可重入锁"><a href="#可重入锁与不可重入锁" class="headerlink" title="可重入锁与不可重入锁"></a>可重入锁与不可重入锁</h3><p>可重入锁就是如果一个锁被一个线程获取，那么该线程可以再次获得该锁，否则就是不可重入锁。</p><h3 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h3><p>悲观锁就是使用时先上锁再使用。</p><p>乐观锁就是使用时不上锁，直到更新时判断一下这个数据有没有更新过。根据这个思路可以想到一种实现乐观锁的机制就是带版本号的乐观锁。</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><p>公平锁就是竞争锁的时候不排队</p><p>非公平锁就是竞争锁的时候要排队</p><h3 id="互斥锁和共享锁"><a href="#互斥锁和共享锁" class="headerlink" title="互斥锁和共享锁"></a>互斥锁和共享锁</h3><p>互斥锁就是一个事务对一个数据加了互斥锁之后，其他事务就不能再对该数据加锁，比如写锁就要是互斥锁</p><p>共享锁就是一个事务如果对一个数据加了共享锁，其他事务还能对该数据加锁，不过只能加共享锁。</p><h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>自旋锁就是一直循环等待而不阻塞线程，比如CAS就是这样</p><h3 id="轻量级锁、偏向锁、重量级锁"><a href="#轻量级锁、偏向锁、重量级锁" class="headerlink" title="轻量级锁、偏向锁、重量级锁"></a>轻量级锁、偏向锁、重量级锁</h3><p>java对synchronized关键字的一种优化的锁分配机制</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h4 id="池化技术-简单点来说，就是提前保存大量的资源，以备不时之需。"><a href="#池化技术-简单点来说，就是提前保存大量的资源，以备不时之需。" class="headerlink" title="池化技术 - 简单点来说，就是提前保存大量的资源，以备不时之需。"></a>池化技术 - 简单点来说，就是提前保存大量的资源，以备不时之需。</h4><p>对于线程，内存，oracle的连接对象等等，这些都是资源，程序中当你创建一个线程或者在堆上申请一块内存时，都涉及到很多系统调用，也是非常消耗CPU的，如果你的程序需要很多类似的工作线程或者需要频繁的申请释放小块内存，如果没有在这方面进行优化，那很有可能这部分代码将会成为影响你整个程序性能的瓶颈。</p><p>池化技术主要有线程池，内存池，连接池，对象池等等。</p><p>对象池就是提前创建很多对象，将用过的对象保存起来，等下一次需要这种对象的时候，再拿出来重复使用</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService service = Executor.newFixedThreadPool(n);</span><br><span class="line">service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">service.execute(<span class="keyword">new</span> MyThread());</span><br><span class="line">service.shutdown();</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> thread </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String</title>
      <link href="/2020/04/22/String/"/>
      <url>/2020/04/22/String/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span>, <span class="title">Comparable</span><<span class="title">String</span>>, <span class="title">CharSequence</span></span>{</span><br><span class="line">    <span class="comment">/** The value is used for character storage. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> value[];</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">(String original)</span> </span>{</span><br><span class="line">        <span class="keyword">this</span>.value = original.value;</span><br><span class="line">        <span class="keyword">this</span>.hash = original.hash;</span><br><span class="line">}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="String的特性"><a href="#String的特性" class="headerlink" title="String的特性"></a>String的特性</h2><ul><li>1、String类是final的，不可被继承。</li><li>2、String类是的本质是字符数组char[], 并且其值不可改变。</li><li>3、String类对象有个特殊的创建的方式，就是直接指定比如String x = “abc”，”abc”就表示一个字符串对象。而x是”abc”对象的地址，也叫做”abc”对象的引用。</li><li>4、String对象可以通过“+”串联。串联后会生成新的字符串。</li><li>5、Java运行时会维护一个String Pool（String池），JavaDoc翻译很模糊“字符串缓冲区”。String池用来存放运行时中产生的各种字符串，并且池中的字符串的内容不重复。而一般对象不存在这个缓冲池，并且创建的对象仅仅存在于方法的堆栈区。</li></ul><h2 id="String对象的创建"><a href="#String对象的创建" class="headerlink" title="String对象的创建"></a>String对象的创建</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>原理1：当使用任何方式来创建一个字符串对象s=X时，Java运行时（运行中JVM）会拿着这个X在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。</li><li>原理2：Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。</li><li>原理3：使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。</li><li>原理4：使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。</li></ul><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><ul><li>其一，使用new关键字创建字符串，比如String s1 = new String(“abc”);</li><li>其二，直接指定。比如String s2 = “abc”;</li><li>其三，使用串联生成新的字符串。比如String s3 = “ab” + “c”; </li></ul><h3 id="String-s-”abc”-和String-s-new-String-“abc”-的区别"><a href="#String-s-”abc”-和String-s-new-String-“abc”-的区别" class="headerlink" title="String s=”abc” 和String s= new String(“abc”)的区别"></a>String s=”abc” 和String s= new String(“abc”)的区别</h3><p>从源码中可以看出，String 是一个final 类型的 char数组。</p><p>不论是String s=”abc” 还是String s= new String(“abc”)，在编译期生成的.class文件中，“abc”都已经被存储在 CONSTANT_String_info表（在class文件常量池中）中，当.class文件被JVM加载时，JVM会创建一块 String Pool（在运行时常量池中）。</p><p>当执行String s=”abc” 时，JVM首先在String Pool中查看是否存在字符串对象“abc”（如何查看呢？用equals()方法判断），如果已存在该对象，则不用创建新的字符串对象“abc”，而直接使用String Pool中已存在的对象“abc”，然后将引用s指向该对象；如果不存在该对象，则先在String Pool中创建一个新的字符串对象“abc”，然后将引用s指向String Pool中创建的新对象。</p><p>而String s= new String(“abc”)则会在堆中创建一个String对象，并且为这个String对象的char数组赋值为常量池中的“abc”。所以，这句代码其实创建了两个对象，一个是在编译期间创建的，一个是在new的时候创建的。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JVM</title>
      <link href="/2020/04/18/JVM/"/>
      <url>/2020/04/18/JVM/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>转载  <a href="https://zhuanlan.zhihu.com/p/34426768" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34426768</a></p><h2 id="内存结构图"><a href="#内存结构图" class="headerlink" title="内存结构图"></a>内存结构图</h2><p><a href="https://user-images.githubusercontent.com/36947860/80328243-5c555680-8871-11ea-8842-b6dfa259e8fc.jpg" data-fancybox="group" data-caption="未命名文件" class="fancybox"><img alt="未命名文件" data-src="https://user-images.githubusercontent.com/36947860/80328243-5c555680-8871-11ea-8842-b6dfa259e8fc.jpg" class="lazyload" title="未命名文件"></a></p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><ul><li>程序计数器是一块较小的空间，它可以看作是当前线程所执行的字节码的行号指示器</li><li>如果线程执行的是java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址（可以理解为上图所示的行号），如果正在执行的是native方法，这个计数器的值为undefined。</li><li>JVM的多线程是通过线程轮流切换并分配CPU执行时间片的方式来实现的，任何一个时刻，一个CPU都只会执行一条线程中的指令。为了保证线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程间的程序计数器独立存储，互不影响。</li><li>此区域是唯一一个在java虚拟机规范中没有规定任何OutOfMemoryError情况的区域，因为程序计数器是由虚拟机内部维护的，不需要开发者进行操作。</li></ul><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><ul><li><p>每个线程有一个私有的栈，随着线程的创建而创建，生命周期与线程相同。</p></li><li><p>虚拟机栈里面存着的是一种叫“栈帧”的东西，每个方法会创建一个栈帧，栈帧中存放了局部变量表、操作数栈、动态链接、方法出口等信息。</p><ul><li><p>局部变量表存放了编译期可知的各种基本数据类型和对象引用类型。通常我们所说的“栈内存”指的就是局部变量表这一部分。</p></li><li><p>64位的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。</p></li><li><p>局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧分配多少内存是固定的，运行期间不会改变局部变量表的大小。</p></li></ul></li><li><p>栈的大小可以固定也可以动态扩展。</p><ul><li><p>在固定大小的情况下，当栈调用深度大于JVM所允许的范围，会抛出StackOverflowError异常。</p></li><li><p>在动态扩展的情况下，若扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常。</p></li></ul></li></ul><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><ul><li><p>和虚拟机栈类似，两者的区别就是虚拟机栈是为虚拟机执行java方法服务，本地方法栈为虚拟机执行native方法服务 。</p></li><li><p><strong>HotSpot虚拟机不区分虚拟机栈和本地方法栈，两者是一块的。</strong></p></li><li><p>与虚拟机栈一样，本地方法栈也会抛StackOverflowError和OutOfMemoryError异常。</p></li></ul><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><ul><li>JVM管理的最大的一块内存区域，存放着对象的实例，是线程共享区。</li><li>堆是垃圾收集器管理的主要区域，因此也被称为“GC堆”</li><li><p>JAVA堆的分类：</p><ul><li><p>从内存回收的角度上看，可分为新生代（Eden空间，From Survivor空间、To Survivor空间）及老年代（Tenured Gen）</p></li><li><p>从内存分配的角度上看，为了解决分配内存时的线程安全性问题，线程共享的JAVA堆中可能划分出多个线程私有的分配缓冲区（TLAB）</p></li></ul></li><li>JAVA堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。</li><li>可通过参数 -Xmx -Xms 来指定运行时堆内存的大小，堆内存空间不足也会抛OutOfMemoryError异常</li></ul><h3 id="方法区-存的是比较全局的一些东西"><a href="#方法区-存的是比较全局的一些东西" class="headerlink" title="方法区 (存的是比较全局的一些东西)"></a>方法区 (存的是比较全局的一些东西)</h3><ul><li><p>方法区也是线程共享区，用于存储【虚拟机加载的类信息（类的版本、字段、方法、接口），常量，静态变量，即时编译器编译后的代码等数据】</p></li><li><p>方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”。</p></li><li><p>方法区可选择不实现垃圾收集，一般来说，这个区域对内存回收的条件较为苛刻，但是这部分区域的回收确实是必要的。</p></li><li><p>当方法区无法满足内存分配需求时，将会抛OutOfMemoryError异常</p></li><li><p><strong>运行时常量池</strong></p><ul><li><p>运行时常量池是方法区的一部分。</p></li><li><p>class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后加入方法区的运行时常量池中存放。</p></li><li><p><strong>运行时常量池相于class文件中的常量池，所不同的是其具备了动态性。</strong>class文件中常量池中的常量在编译期间就已经定义好了，而运行时常量池在程序运行期间也可以将常量放入该常量池中，最常见的做法就是调用String类的intern()方法。</p><blockquote><p>尽管在输出中调用intern方法并没有什么效果，但是实际上后台这个方法会做一系列的动作和操作。在调用”ab”.intern()方法的时候会返回”ab”，但是这个方法会首先检查字符串池中是否有”ab”这个字符串，如果存在则返回这个字符串的引用，否则就将这个字符串添加到字符串池中，然会返回这个字符串的引用。</p></blockquote></li></ul></li></ul><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p><strong>简介</strong></p><p>运行时常量池（Runtime Constant Pool），它是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到常量池中。</p><p>运行时常量是相对于常量来说的，它具备一个重要特征是：动态性。当然，值相同的动态常量与我们通常说的常量只是来源不同，但是都是储存在池内同一块内存区域。Java语言并不要求常量一定只能在编译期产生，运行期间也可能产生新的常量，这些常量被放在运行时常量池中。这里所说的常量包括：基本类型包装类（包装类不管理浮点型，整形只会管理-128到127）和String（也可以通过String.intern()方法可以强制将String放入常量池）</p><p><strong>Class文件中的信息常量池</strong></p><p>在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p><p>常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><p><strong>常量池的好处</strong></p><p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><ul><li>节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li></ul><blockquote><p>双等号==的含义</p><ul><li>基本数据类型之间应用双等号，比较的是他们的数值。</li><li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li></ul></blockquote><p><strong>基本类型的包装类和常量池</strong></p><p>java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean。这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float,Double并没有实现常量池技术。 </p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><h4 id="加载-class文件的方式"><a href="#加载-class文件的方式" class="headerlink" title="加载.class文件的方式"></a>加载.class文件的方式</h4><ul><li>从本地系统中直接加载</li><li>通过网络下载.class文件</li><li>从zip，jar等归档文件中加载.class文件</li><li>从专有数据库中提取.class文件</li><li>将Java源文件动态编译为.class文件</li></ul><h4 id="类加载器分类"><a href="#类加载器分类" class="headerlink" title="类加载器分类"></a>类加载器分类</h4><p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p><p><strong>启动类加载器</strong>： <code>BootstrapClassLoader</code>，负责加载存放在 <code>JDK\jre\lib</code>(JDK代表JDK的安装目录，下同)下，或被 <code>-Xbootclasspath</code>参数指定的路径中的，并且能被虚拟机识别的类库（如rt.jar，所有的java.开头的类均被 <code>BootstrapClassLoader</code>加载）。启动类加载器是无法被Java程序直接引用的。<br><strong>扩展类加载器</strong>： <code>ExtensionClassLoader</code>，该加载器由 <code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载 <code>JDK\jre\lib\ext</code>目录中，或者由 <code>java.ext.dirs</code>系统变量指定的路径中的所有类库（如javax.开头的类），开发者可以直接使用扩展类加载器。<br><strong>应用程序类加载器</strong>： <code>ApplicationClassLoader</code>，该类加载器由 <code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p><h4 id="类加载机制——双亲委派机制"><a href="#类加载机制——双亲委派机制" class="headerlink" title="类加载机制——双亲委派机制"></a>类加载机制——双亲委派机制</h4><ul><li>1、当 <code>AppClassLoader</code>加载一个class时，它首先不会自己去尝试加载这个类，而是把类加载请求委派给父类加载器<code>ExtClassLoader</code>去完成。</li><li>2、当 <code>ExtClassLoader</code>加载一个class时，它首先也不会自己去尝试加载这个类，而是把类加载请求委派给BootStrapClassLoader```去完成。</li><li>3、如果 <code>BootStrapClassLoader</code>加载失败（例如在 <code>$JAVA_HOME/jre/lib</code>里未查找到该class），会使用 <code>ExtClassLoader</code>来尝试加载；</li><li>4、若ExtClassLoader也加载失败，则会使用 <code>AppClassLoader</code>来加载，如果 <code>AppClassLoader</code>也加载失败，则会报出异常 <code>ClassNotFoundException</code></li></ul><h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“<strong>GC堆</strong>”。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：<strong>新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。</strong>   在新生代的GC叫做轻GC、在老年代的GC叫做重GC。</p><h3 id="对象存活判断"><a href="#对象存活判断" class="headerlink" title="对象存活判断"></a>对象存活判断</h3><p>判断对象是否存活一般有两种方式：</p><ul><li><p><strong>引用计数</strong>：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。</p></li><li><p><strong>可达性分析</strong>（Reachability Analysis）：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。</p><p>在Java语言中，GC Roots包括:</p><ul><li>虚拟机栈中引用的对象。</li><li>方法区中类静态属性实体引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI引用的对象。</li></ul></li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li><p>“标记-清除”（Mark-Sweep）算法，如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的。</p><p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。标记-压缩算法</p></li><li><p>“复制”（Copying）的收集算法，它将可用内存按容量划分成两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p><p>这样使得每次都是对其中的一块进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。但是这种方法需要一块未使用的内存作为复制区，造成内存浪费，而且只适用于新生代这种存活对象少的情况。</p></li><li><p>标记-压缩算法。复制收集算法在对象存活率较高时就要执行较多的复制操作，效率将会变低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。</p><p>根据老年代的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p></li><li><p>GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。</p><p>“分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。</p></li></ul><p><strong>Question：为什么要设置两个幸存区?</strong></p><p>答：因为新生代采用 “复制”算法来收集垃圾，所以需要一个空的内存区域，用来保存存活下来的对象，这是幸存区存在的原因。而之所以需要两个，是因为当伊甸区满了之后，不光要对伊甸区进行垃圾回收，同时要对幸存区进行垃圾回收，此时又需要一块空的内存区域，用来保存存活下来的对象。所以需要两个幸存区，交替着用。 通常  伊甸区：幸存区1：幸存区2=8:1:1  .</p><p>而老年代 使用的不是“复制”算法，而是标记压缩算法，所以就不需要幸存区。</p><h2 id="内存调优"><a href="#内存调优" class="headerlink" title="内存调优"></a>内存调优</h2><p><strong>参数含义</strong></p><p>先说VM选项， 三种：</p><ul><li>- : 标准VM选项，VM规范的选项</li><li>-X: 非标准VM选项，不保证所有VM支持</li><li>-XX: 高级选项，高级特性，但属于不稳定的选项</li></ul><p>参见 <a href="https://link.zhihu.com/?target=http%3A//www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html%23Options">Java HotSpot VM Options</a></p><p>题主提到的参数前缀为X，显然属于第二类</p><p>再说这几个参数，其语义分别是：</p><ul><li>-Xmx: 堆的最大内存数，等同于-XX:MaxHeapSize</li><li>-Xms: 堆的初始化初始化大小</li><li>-Xmn: 堆中新生代初始及最大大小，如果需要进一步细化，初始化大小用-XX:NewSize，最大大小用-XX:MaxNewSize </li><li>-Xss: 线程栈大小，等同于-XX:ThreadStackSize</li></ul><p>命名应该非简称，助记的话： memory maximum, memory startup, memory nursery/new, stack size.</p><p><strong>Jprofiler使用</strong></p><p>1、下载软件并安装</p><p>2、在idea 市场中安装对应插件</p><p>3、在setting/tools/Jprofiler中配置软件安装目录</p><p>4、在运行时配置虚拟机参数 -XX:+HeapDumpOnOutOfMemoryError</p><p>5 、在项目目录下找到dump出来hprof的文件。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>各种查找树</title>
      <link href="/2020/04/15/%E5%90%84%E7%A7%8D%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
      <url>/2020/04/15/%E5%90%84%E7%A7%8D%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>1、二叉排序树、二叉查找树、二叉搜索树 都是同一个树的不同名称</p><h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><p>2、二叉平衡树对二叉排序树进行约束，即左右子树高度差不能大于1，否则就要调整。由于二叉平衡树的严格限制，使得二叉平衡树的查找更加方便，但是也同样由于二叉树的严格限制，使得插入和删除操作较多时，平衡二叉树的调整特别频繁，影响性能，于是出现了红黑树。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>3、红黑树的约束条件相较于二叉平衡树简单粗暴的约束条件来说，更加的巧妙，但同时也更加的松散</p><ul><li>节点是红色或者黑色</li><li>根是黑色</li><li>所有叶子节点都是黑色</li><li>红色节点和红色节点不能直接相连</li><li>任一节点的左右子树中黑色节点个数相同(黑高相同)</li><li>每次插入时插入红色节点</li></ul><p>由于这种设计(主要是4和5)，使得左右子树的高度差不会超过一倍，达到了一定程度的平衡，同时因为插入的是红色节点，使得插入和删除时调整树的代价比较小，所以红黑树使用的很广泛。红黑树怎么调整这里就不谈了。</p><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>4、B树，注意B树就叫B树，有的教材非要在”B”和”树”之间加个”-“,变成”B-树”，使得很多人以为还有一种B减树的存在，其实是不存在的。</p><p>B树其实就是多叉排序树。但是B树也有自己的约束，比如每个节点做多能分的叉是有限制的，最少能分的叉也是有限制的，并且要求所有叶子节点都在同一层，所以也免不了要对B树进行调整。</p><p>B树相对于平衡二叉树的不同在于，每个节点包含的关键字的数目不在是一个了，而可以是多个。B树应用到数据库时，可以充分利用磁盘块的性质（磁盘数据的存储是采用块 的形式存储的，每个块的大小为4k，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制在磁盘块的大小范围。</p><p><strong>B树</strong>相对于<strong>B+树</strong>的优点是，如果经常访问的数据离根节点很近，而<strong>B树</strong>的<strong>非叶子</strong>节点本身存有关键字其数据的地址，所以这种数据检索的时候会要比<strong>B+树</strong>快</p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>5、B+树，B+树与B树相比，它的非叶子节点部分不存储数据，仅仅用作判断该往哪个方向走，只有叶子节点存储数据，并且叶子节点通过指针串起来。B+树其实很像一本书的实现，非叶子节点部分就像书的索引部分一样，叶子节点部分就像书的内容一样。</p><p><strong>B+树相对于B树的优点</strong></p><ul><li>B+<strong>树的层级更少</strong>：相较于B树B+每个<strong>非叶子</strong>节点存储的关键字数更多，树的层级更少所以查询数据更快</li><li>B+<strong>树查询速度更稳定</strong>：B+所有关键字数据地址都存在<strong>叶子</strong>节点上，所以每次查找的次数都相同所以查询速度要比B树更稳定;</li><li>B+<strong>树天然具备排序功能：</strong>B+树所有的<strong>叶子</strong>节点数据构成了一个有序链表，在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>B+<strong>树全节点遍历更快：</strong>B+树遍历整棵树只需要遍历所有的<strong>叶子</strong>节点即可，，而不需要像B树一样需要对每一层进行遍历，这有利于数据库做全表扫描。</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>HashMap</title>
      <link href="/2020/04/13/HashMap/"/>
      <url>/2020/04/13/HashMap/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="哈希桶数组"><a href="#哈希桶数组" class="headerlink" title="哈希桶数组"></a>哈希桶数组</h2><p>HashMap类中有一个非常重要的字段，就是Node[] table,称作哈希桶数组，是一个Node数组。其中Node结构如下</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span><<span class="title">K</span>,<span class="title">V</span>> <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span><<span class="title">K</span>,<span class="title">V</span>> </span>{</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;    <span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node<k,v> next;   <span class="comment">//链表的下一个node</span></k,v></span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node<k,v> next) { ... }</k,v></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span></span>{ ... }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span> </span>{ ... }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>{ ... }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>{ ... }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>{ ... }</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>{ ... }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>Node是HashMap的一个内部类，实现了Map.Entry接口，本质是就是一个映射(键值对)。</p><h2 id="HashMap的几个字段："><a href="#HashMap的几个字段：" class="headerlink" title="HashMap的几个字段："></a>HashMap的几个字段：</h2><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> threshold;             <span class="comment">// 所能容纳的key-value对极限 </span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;    <span class="comment">// 负载因子</span></span><br><span class="line"><span class="keyword">int</span> modCount;  </span><br><span class="line"><span class="keyword">int</span> size;</span><br></pre></td></tr></tbody></table></figure></div><p>首先，Node[]table的初始化长度length(默认值为16)，Load factor为负载因子（默认为0.75）。threshold是HashMap所能容纳的最大数据量的Node个数。threshold=length×Load_factor。size是HashMap中实际存在的键值对数量。</p><p>当size大于threshold时，就要多HashMap进行resize。</p><p>modCount字段主要用来记录HashMap结构发生变化的次数，值得注意的是，内部结构发生变化指的是结构发生变化，例如put新键值对，但是某个key对应的value值被覆盖不属于结构变化。</p><h2 id="哈希桶数组的table的长度为2的n次方的原因"><a href="#哈希桶数组的table的长度为2的n次方的原因" class="headerlink" title="哈希桶数组的table的长度为2的n次方的原因"></a>哈希桶数组的table的长度为2的n次方的原因</h2><p>一般来说，哈希桶数组的桶数为素数比较好，但在jdk1.8中，table的长度length大小必须为2的n次方（合数），主要为了在<strong>取模</strong>和<strong>扩容</strong>（扩容时容易rehash）时做优化。</p><blockquote><p> 为什么一般哈希桶数组的桶数会取一个素数？</p><p>设有一个哈希函数<br>H( c ) = c % N;<br>当N取一个合数时，最简单的例子是取2^n，比如说取2^3=8,这时候<br>H( 11100(二进制） ) = H( 28 ) = 4<br>H( 10100(二进制) ) = H( 20 ）= 4<br>这时候c的二进制第4位（从右向左数）就”失效”了，也就是说，无论第c的4位取什么值，都会导致H( c )的值一样．这时候c的第四位就根本不参与H( c )的运算，这样H( c )就无法完整地反映c的特性，增大了导致冲突的几率。</p></blockquote><h2 id="Hash算法"><a href="#Hash算法" class="headerlink" title="Hash算法"></a>Hash算法</h2><p>数据结构书上学的hash算法中常用的就是 取模，这样能使的hash值分布比较均匀。在jdk1.8中思想也是这样，具体是这么做的</p><ol><li><p>取key的hashCode值，通过hashCode()函数，得到一个int。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h = key.hashCode()</span><br></pre></td></tr></tbody></table></figure></div><p>其中hashCode()的计算公式如下：</p><blockquote><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">><span class="comment">//hashCode()计算公式</span></span><br><span class="line">>s[<span class="number">0</span>]*<span class="number">31</span>^(n-<span class="number">1</span>) + s[<span class="number">1</span>]*<span class="number">31</span>^(n-<span class="number">2</span>) + ... + s[n-<span class="number">1</span>]</span><br></pre></td></tr></tbody></table></figure></div></blockquote></li><li><p>高位运算,hash()函数，进行扰动</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h ^ (h >>> <span class="number">16</span>)</span><br></pre></td></tr></tbody></table></figure></div><p>如果没有高位运算，取模后总是低位的值，而低位的值就那么几个，很容易冲突。右移16位的原因是因为int的长度为32位。</p><p>扩展</p><blockquote><p>>>：带符号右移。正数右移高位补0，负数右移高位补1。比如：</p><p>4 >> 1，结果是2；-4 >> 1，结果是-2。-2 >> 1，结果是-1。</p><p>>>>：无符号右移。无论是正数还是负数，高位通通补0。</p><p>对于正数而言，>>和>>>没区别。</p></blockquote></li><li><p>取模运算</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h & (table.length-<span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure></div><p>因为length总是2的n次方的缘故，对$2^n$取模，就相当于h& (table.length-1),位运算效率更高。</p></li></ol><h2 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h2><p>分为两步</p><ul><li><p>扩容：创建一个新的空数组，长度是原数组的2倍。</p></li><li><p>ReHash：遍历原数组，把所有的Node重新Hash到新数组。</p><blockquote><p>为什么要重新创建一个2倍大小的数组，在原数组的基础上不行吗？</p><p>java数组大小不可变。</p><p>为什么要重新Hash呢，直接复制过去不行吗？</p><p>hash规则跟table的长度有关，所以不能直接复制。</p><p><strong>为什么扩容大小为原来的2倍，不是3倍或者4倍？</strong></p><p>因为length变为2倍，那么取模时h & (table.length-1)就会比未扩容前多1位，且多出来的这1位只有可能是0或者1，如下图所示：</p><p><a href="https://pic2.zhimg.com/80/a285d9b2da279a18b052fe5eed69afe9_720w.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/80/a285d9b2da279a18b052fe5eed69afe9_720w.png" class="lazyload" title="img"></a></p><p>所以扩容之后我们就rehash的过程就变得特别简单，不需要像JDK1.7的实现那样重新从头计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap”。</p><p><a href="https://pic2.zhimg.com/80/b2cb057773e3d67976c535d6ef547d51_720w.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/80/b2cb057773e3d67976c535d6ef547d51_720w.png" class="lazyload" title="img"></a></p><p>下图为16扩充为32的resize示意图：</p><p><a href="https://pic3.zhimg.com/80/544caeb82a329fa49cc99842818ed1ba_720w.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/80/544caeb82a329fa49cc99842818ed1ba_720w.png" class="lazyload" title="img"></a></p></blockquote></li></ul><h2 id="冲突避免"><a href="#冲突避免" class="headerlink" title="冲突避免"></a>冲突避免</h2><p>在数据结构书中，避免冲突的算法有 开放位置法和拉链法。在jdk中基于拉链法的思想，进行改进。</p><p>jdk1.7中，采用头插法：</p><ul><li><p>优点</p><ul><li>头插法插入方便。</li><li>根据程序局部性原理，后插入的更有可能被访问，插在头部查找效率高</li></ul></li><li><p>缺点：</p><ul><li>在扩容时会造成倒序，上述的优点就失效了。</li><li>在多线程操作中，扩容会造成链表成环。</li></ul></li></ul><p>jdk1.8中，采用尾插法：</p><ul><li><p>扩容转移后前后链表顺序不变，保持之前节点的引用关系, 在同样的前提下并不会引起死循环。</p><blockquote><p>那是不是意味着Java8就可以把HashMap用在多线程中呢？</p><p>即使不会出现死循环，但是通过源码看到put/get方法都没有加同步锁，多线程情况最容易出现的就是：无法保证上一秒put的值，下一秒get的时候还是原值，所以线程安全还是无法保证。</p></blockquote></li><li><p>采用尾插法丢失了头插法的优点，但是jdk1.8中，加入了红黑树优化。红黑树我之后会写。</p></li></ul><p>参考</p><p><a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征值和特征向量</title>
      <link href="/2020/04/11/%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/"/>
      <url>/2020/04/11/%E7%89%B9%E5%BE%81%E5%80%BC%E5%92%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="矩阵变换-伸缩和旋转"><a href="#矩阵变换-伸缩和旋转" class="headerlink" title="矩阵变换(伸缩和旋转)"></a>矩阵变换(伸缩和旋转)</h3><p>在讲特征值和特征向量之前，我们先来理解一下矩阵。</p><p>矩阵乘法对应了一个<strong>变换</strong> ，是把任意一个向量变成另一个方向或长度都大多不同的新向量。在这个变换的过程中，原向量主要发生 <strong>旋转、伸缩</strong> 的变化。</p><p>为什么我们说矩阵具有旋转和伸缩的功能呢？矩阵代表一种变换，这种变化我们是无法直接描述的，我们只能通过它所作用的对象的变化来描述，就好像物理学中的“力”一样。我们用矩阵乘以一个向量，可以看到这个向量变到了另一个位置，而这个位置可以在原位置通过伸缩和旋转得到，所以我们说矩阵变换就是伸缩和旋转变换。其实从纯数字计算的角度，如果我们以<script type="math/tex">\left[ \matrix{  1 & 0\\  0 & 1  } \right]</script>作为基，在这组基张成的向量空间里，矩阵（也就是一个变换），其对角线上的值代表的就是伸缩，其他位置的值代表的就是旋转（不过这个旋转同时也会带来部分伸缩）。比如<script type="math/tex">\left[ \matrix{  2 & 0\\  1 & 1  } \right]</script> 的第一列就代表向量<script type="math/tex">\left[ \matrix{  1 \\  0  } \right]</script>伸缩和旋转到了<script type="math/tex">\left[ \matrix{  2\\  1  } \right]</script>的位置。这个部分可能解释的不够精确，但是想必有人已经意会了。换个解释的说法就是，如果我们以<script type="math/tex">\left[ \matrix{  1 & 0\\  0 & 1  } \right]</script>作为基，在这组基张成的向量空间里，一个矩阵变换如果只有对角线上有值，那么这个矩阵变换仅代表伸缩，如果除了对角线以外，其他地方还有值，那么就带有一点旋转。如果我们以<script type="math/tex">\left[ \matrix{  0 & 1\\  1 & 0 } \right]</script>作为基，那么对于一个矩阵变换来说，就是副对角线上的值代表伸缩了。</p><h3 id="特征值和特征向量"><a href="#特征值和特征向量" class="headerlink" title="特征值和特征向量"></a>特征值和特征向量</h3><p>特征值和特征向量的公式： <script type="math/tex">Ax= \lambda x</script></p><p>说明A有这样一个功能：即对向量$x$变换后，长度拉伸$\lambda$倍，方向不变。</p><p>如果矩阵对某一个向量或某些向量只发生伸缩变换，不对这些向量产生旋转的效果，那么这些向量就称为这个矩阵的特征向量，伸缩的比例就是特征值。</p><p>计算特征向量的过程就是寻找一个正交系去表示你原来的函数，特征向量就是新的坐标系的坐标轴。</p><p>也就是说我们可以用特征向量和特征值去表示这个矩阵。那么问题来了，why？</p><p>不急，且听我慢慢道来。</p><p>根据上一节我们已经知道，矩阵=伸缩+旋转。同时，根据这一节，我们知道矩阵对特征向量只有伸缩功能，对其他向量有伸缩和旋转的功能。即矩阵=对特征向量的伸缩+对其他向量的伸缩和旋转。同时我要告诉大家的是  矩阵对特征向量的伸缩蕴涵了矩阵对其他向量的伸缩和旋转。所以有  矩阵=对特征向量的伸缩。</p><p> 为什么 矩阵对特征向量的伸缩蕴涵了矩阵对其他向量的伸缩和旋转呢？因为对不同特征向量的伸缩的倍数不一样，导致用特征向量去表示其他向量（比如向量x）时，相较于特征向量未伸缩之前，其他向量就发生了伸缩和旋转。比如未伸缩之前的特征向量<script type="math/tex">\left[ \matrix{  1 \\  0  } \right]</script>和<script type="math/tex">\left[ \matrix{  0 \\  1  } \right]</script>,伸缩后变为<script type="math/tex">\left[ \matrix{  1 \\  0  } \right]</script>和<script type="math/tex">\left[ \matrix{  0 \\  3  } \right]</script>，那么在原坐标系中的向量<script type="math/tex">\left[ \matrix{  1 \\  1  } \right]</script>就变到了<script type="math/tex">\left[ \matrix{  1 \\  3 } \right]</script>的位置。所以矩阵对特征向量的伸缩蕴涵了矩阵对其他向量的伸缩和旋转。所以我们可以用特征值和特征向量就可以描述这个矩阵。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>假设一个矩阵是10维的，那么我们可以用10个向量（基）来描述这个矩阵。这10个向量就是特征向量。而且这些特征向量带有倍数$\lambda$，也就是说 基 并不是等长的，不是单位正交基。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>POSIX</title>
      <link href="/2020/04/10/%E6%9F%A5%E8%AF%A2POSIX%E8%8E%B7%E5%8F%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/04/10/%E6%9F%A5%E8%AF%A2POSIX%E8%8E%B7%E5%8F%96%E7%9A%84%E4%B8%80%E4%BA%9B%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="POSIX简介"><a href="#POSIX简介" class="headerlink" title="POSIX简介"></a>POSIX简介</h3><p>POSIX全称是Portable Operating System Interface，意为可移植操作系统接口，是IEEE要在各种UNIX操作系统上运行软件，而定义API的一系列互相关联的标准的总称。X表示对UNIX的传承（X在UNIX中是cross的缩写，代表跨平台的意思）。</p><h3 id="Linux和-POSIX的关系"><a href="#Linux和-POSIX的关系" class="headerlink" title="Linux和 POSIX的关系"></a>Linux和 POSIX的关系</h3><p>严格来说，Linux 有自己的跨平台（不同Linux之间）标准，叫 Linux Standard Base（LSB）。</p><p>LSB 融合了 POSIX 和 SVID 的内容，并在此基础上进行了拓展。</p><p>Unix 和 类-Unix 系统的现行标准道是 POSIX，但这份标准只定义了 API，没有定义可执行文件格式 ABI。而 LSB 则添加了 ABI 方面的内容，其中有许多来自 SVID。</p><p>LSB 和 POSIX 的标准制定委员会决定 尽最大可能简小两份标准之间的分歧，所以两者大体容上是兼容的。</p><p>SVID 现在已经不再使用了，他的 API 已经被 POSIX 取代了。但它的 ABI 还是现在大部分系统所采用的。</p><h3 id="API和ABI"><a href="#API和ABI" class="headerlink" title="API和ABI"></a>API和ABI</h3><p>API全称是APPlication Programming Interface（应用程序编程接口），是给程序员用的。</p><p>ABI全称是APPlication Binary Interface（应用程序二进制接口），是给编译好的二进制用的。这也是为什么exe不能在linux下运行的原因。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Do{……}while(0)的巧妙用处</title>
      <link href="/2020/04/10/do%7B...%7Dwhile(0)%E7%9A%84%E5%B7%A7%E5%A6%99%E7%94%A8%E5%A4%84/"/>
      <url>/2020/04/10/do%7B...%7Dwhile(0)%E7%9A%84%E5%B7%A7%E5%A6%99%E7%94%A8%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="1-辅助定义复杂的宏，避免引用的时候出错："><a href="#1-辅助定义复杂的宏，避免引用的时候出错：" class="headerlink" title="1.辅助定义复杂的宏，避免引用的时候出错："></a>1.辅助定义复杂的宏，避免引用的时候出错：</h3><p>假设要定义一个宏：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F()   f1();f2();</span></span><br></pre></td></tr></tbody></table></figure></div><p>这个宏的意思是，当调用F()时，f1()和f2()都会被调用。但是在调用的时候如果这么写：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr)</span><br><span class="line">    F();</span><br></pre></td></tr></tbody></table></figure></div><p> 而宏在预处理的时候会直接被展开为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr)</span><br><span class="line">    f1();f2();</span><br></pre></td></tr></tbody></table></figure></div><p>这就导致无论expr是否为真，f2()一定被执行，因为if语句只能控制下一句f1()，这并不是我们的预期。</p><p>一种解决办法是用{}将f1();f2{};包起来：即</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F()  { f1();f2(); }</span></span><br></pre></td></tr></tbody></table></figure></div><p>但这种情况下，我们发现语句被展开为：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expr)</span><br><span class="line">    {f1();f2();};</span><br></pre></td></tr></tbody></table></figure></div><p> 最后的分号是我们习惯添加的，显然，这是个语法错误。有些编译器并不能通过。</p><p>这时候我们发现do{…}while(0)似乎是一种很好的解决办法：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> F() \</span></span><br><span class="line">        <span class="keyword">do</span>{ \</span><br><span class="line">          f1();\</span><br><span class="line">          f2();\</span><br><span class="line">        }<span class="keyword">while</span>(<span class="number">0</span>)\</span><br></pre></td></tr></tbody></table></figure></div><h3 id="2-避免使用goto对程序流进行统一的控制："><a href="#2-避免使用goto对程序流进行统一的控制：" class="headerlink" title="2.避免使用goto对程序流进行统一的控制："></a>2.避免使用goto对程序流进行统一的控制：</h3><p>一些代码中想达到goto这种简单的代码流控制效果，例如：有些函数中，在函数return之前我们经常会进行一些收尾的工作，比如free掉一块函数开始malloc的内存，goto一直都是一个比较简便的方法。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    somestruct* ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    }</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">if</span>(error)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    }</span><br><span class="line">    ...;</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>但是goto不符合软件工程的结构化，而且有可能使得代码难懂，所以不倡导使用，这时可以用do{}while(0)来进行统一的管理：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    somestruct* ptr = <span class="built_in">malloc</span>(...);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        ...;</span><br><span class="line">        <span class="keyword">if</span>(error)</span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        }</span><br><span class="line">        ...;</span><br><span class="line">    }<span class="keyword">while</span>(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p> 这里将函数主体部分使用do{…}while(0)包含起来，使用break来代替goto，后续的清理工作在while之后，现在既能达到同样的效果，而且代码的可读性、可维护性都要比上面的goto代码好的多了。</p><h3 id="3、避免空宏引起的警告"><a href="#3、避免空宏引起的警告" class="headerlink" title="3、避免空宏引起的警告"></a>3、避免空宏引起的警告</h3><p>内核中由于不同架构的限制，很多时候会用到空宏。在编译的时候，这些空宏会给出warning，为了避免这样的warning，可以使用do{…}while(0)来定义空宏：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EMPTYMICRO do{}while(0)</span></span><br></pre></td></tr></tbody></table></figure></div><p>这种情况不太常见，因为有很多编译器，已经支持空宏。</p><h3 id="4、定义一个单独的函数块来实现复杂的操作："><a href="#4、定义一个单独的函数块来实现复杂的操作：" class="headerlink" title="4、定义一个单独的函数块来实现复杂的操作："></a>4、定义一个单独的函数块来实现复杂的操作：</h3><p>复杂的函数，变量很多，若不想要增加新的函数，可以用do{…}while(0)，将代码写在里面，里面可以定义变量而不用考虑变量名会同函数之前或者之后的重复。<br>但是不建议这样做，尽量声明不同的变量名，以便于后续开发人员阅读。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">c</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight c"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">unsigned</span> j;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">int</span> j = fi();</span><br><span class="line">    <span class="keyword">unsigned</span> j = fj();</span><br><span class="line">    ...;</span><br><span class="line">    <span class="keyword">do</span>{</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">unsigned</span> j;</span><br><span class="line">        ...;</span><br><span class="line">    }<span class="keyword">while</span>(<span class="number">0</span>);    </span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> C语言 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux的历史与开源精神</title>
      <link href="/2020/04/08/Linux%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%BC%80%E6%BA%90%E7%B2%BE%E7%A5%9E/"/>
      <url>/2020/04/08/Linux%E7%9A%84%E5%8E%86%E5%8F%B2%E4%B8%8E%E5%BC%80%E6%BA%90%E7%B2%BE%E7%A5%9E/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>Unics用c语言重写了一遍，改名unix（x=cross，跨平台的意思）</p><p>伯克利大学模仿unix写出BSD系统，BSD就是一种unix</p><p>BSD先商业化导致unix不服，遂告BSD侵权。从此以后unix开始收费和商业闭源，BSD删除全部unix代码，变成unix-like系统（类unix系统）</p><p>有人对unix商业化和闭源很不爽，发起GUN（GUN is Not Unix）计划，模仿unix的界面和使用方式，从头做一个开源的版本。并起草GPL（GNU General Public License）：如果你在开源代码基础上开发，并将其分发，你就必须放出您的修改的源代码。</p><p>GUN先开发出了软件，但是其系统内核Hurd一直没开发出来。</p><p>有人写出一个linux内核，GUN采用了它。</p><p>BSD一直活到现在，代表伯克利软件套件（Berkeley Software Distribution），有三个主流分支FreeBSD、NetBSD、OpenBSD。有两个重要的BSD操作系统DragonFly BSD 、Mac OS X 。</p><p>BSD是类unix系统，注意unix是闭源的，类unix是开源的，所以BSD也有自己的开源许可证：BSD 许可证。如果你修改了 BSD 内核或发行版，并且发布它，你根本不需要必须发布其源代码。你可以自由地对你的 BSD 代码做任何你想做的事情，你没有义务发布的你修改的源代码，当然你想发布也行。</p><p>人们常常会讨论GPL许可证和BSD许可证 哪个更具有开源精神，哪个更自由，小宝贝们，你们觉得呢？</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux用户</title>
      <link href="/2020/04/08/linux%E7%94%A8%E6%88%B7/"/>
      <url>/2020/04/08/linux%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="用户账户的管理"><a href="#用户账户的管理" class="headerlink" title="用户账户的管理"></a>用户账户的管理</h2><h3 id="添加账户"><a href="#添加账户" class="headerlink" title="添加账户"></a>添加账户</h3><p>添加账户 <code>useradd -m  jack</code>  -m参数表示创建用户的同时为用户创建目录</p><p><code>useradd -u 用户号</code>  指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。在Linux中，操作系统根据UID来判断用户！根据UID来判断用户！ 而不是用户名！只要id为0就是管理员，哪怕有多个id为0 的账号。</p><p><code>-g</code>用来指定用户的主组，<code>-G</code>用来指定用户的附属组 。</p><p>如<code>useradd  -g group –G group1,group2 xiaoming</code>  指定了一个主组和两个附属组。</p><p>注意，在Linux中，每个用户必须有一个主组。当创建账号时，系统会自动创建一个同名组作为该账户的主组。用户必须属于一个且只有一个主组。用户可以属于零个或者多个附加组。</p><h3 id="删除账户"><a href="#删除账户" class="headerlink" title="删除账户"></a>删除账户</h3><p>删除账户 <code>userdel  -r jack</code>  -r参数表示删除用户时把用户的主目录一起删除</p><h3 id="修改账户"><a href="#修改账户" class="headerlink" title="修改账户"></a>修改账户</h3><p>修改账户 <code>usermod  选项  用户名</code>     可以改变用户的用户号、主目录、用户组、登录shell等。</p><h2 id="用户口令的管理"><a href="#用户口令的管理" class="headerlink" title="用户口令的管理"></a>用户口令的管理</h2><p>用户账户刚刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>超级用户可以为自己和其他用户指定口令，普通用户只能 修改自己的口令</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">passwd  选项 用户名</span><br><span class="line"></span><br><span class="line">可选的参数有</span><br><span class="line"></span><br><span class="line">-l 锁定口令，即禁用账号</span><br><span class="line"></span><br><span class="line">-u 口令解锁</span><br><span class="line"></span><br><span class="line">-d 使账号无效</span><br><span class="line"></span><br><span class="line">-f 强迫用户 下次登录时修改口令</span><br></pre></td></tr></tbody></table></figure></div><h2 id="用户组与权限"><a href="#用户组与权限" class="headerlink" title="用户组与权限"></a>用户组与权限</h2><p><code>drwxrwxrwx</code></p><ul><li><p>第一组rwx：表示<strong>文件所有者</strong>的权限。谁创建了这个文件，谁就天然是文件的所有者，当然之后可以通过命令修改文件的所有者</p></li><li><p>第二组rwx：表示与<strong>用户所有者同一组</strong>的用户的权限。可以通过命令usermod -g/-G使得想要的用户和自己同一组或者拥有自己的附加组。</p></li><li><p>第三组rwx：表示不与文件所有者同组的其他用户的权限。</p></li></ul><p>一个用户的权限为他所属的多个组的累加权限。比如一个文件A中A组的用户可以写，文件B中B的用户可以写，一个用户既属于组A又属于组B，那么就可以写文件A和文件B。</p><p>可以通过<code>chmod777</code>来更改这些权限 ，其中read=4，write=2，execute=1.</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回调函数</title>
      <link href="/2020/04/08/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
      <url>/2020/04/08/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>作者：no.body<br>链接：<a href="https://www.zhihu.com/question/19801131/answer/27459821" target="_blank" rel="noopener">https://www.zhihu.com/question/19801131/answer/27459821</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="什么是回调函数？"><a href="#什么是回调函数？" class="headerlink" title="什么是回调函数？"></a>什么是回调函数？</h2><p>我们绕点远路来回答这个问题。</p><p>编程分为两类：系统编程（system programming）和应用编程（application programming）。所谓系统编程，简单来说，就是编写<strong>库</strong>；而应用编程就是利用写好的各种库来编写具某种功用的程序，也就是<strong>应用</strong>。系统程序员会给自己写的库留下一些接口，即API（application programming interface，应用编程接口），以供应用程序员使用。所以在抽象层的图示里，库位于应用的底下。</p><p>当程序跑起来时，一般情况下，应用程序（application program）会时常通过API调用库里所预先备好的函数。但是有些库函数（library function）却要求应用先传给它一个函数，好在合适的时候调用，以完成目标任务。这个被传入的、后又被调用的函数就称为<strong>回调函数</strong>（callback function）。</p><p>打个比方，有一家旅馆提供叫醒服务，但是要求旅客自己决定叫醒的方法。可以是打客房电话，也可以是派服务员去敲门，睡得死怕耽误事的，还可以要求往自己头上浇盆水。这里，“叫醒”这个行为是旅馆提供的，相当于库函数，但是叫醒的方式是由旅客决定并告诉旅馆的，也就是回调函数。而旅客告诉旅馆怎么叫醒自己的动作，也就是把回调函数传入库函数的动作，称为<strong>登记回调函数</strong>（to register a callback function）。如下图所示（图片来源：维基百科）：</p><p><a href="https://pic4.zhimg.com/50/0ef3106510e2e1630eb49744362999f8_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/50/0ef3106510e2e1630eb49744362999f8_hd.jpg" class="lazyload" title="img"></a><a href="https://pic4.zhimg.com/80/0ef3106510e2e1630eb49744362999f8_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/80/0ef3106510e2e1630eb49744362999f8_720w.jpg" class="lazyload" title="img"></a></p><p>可以看到，回调函数通常和应用处于同一抽象层（因为传入什么样的回调函数是在应用级别决定的）。而回调就成了一个高层调用底层，底层再<strong>回</strong>过头来<strong>调</strong>用高层的过程。（我认为）这应该是回调最早的应用之处，也是其得名如此的原因。</p><h2 id="回调机制的优势"><a href="#回调机制的优势" class="headerlink" title="回调机制的优势"></a>回调机制的优势</h2><p>从上面的例子可以看出，回调机制提供了非常大的灵活性。请注意，从现在开始，我们把图中的库函数改称为<strong>中间函数</strong>了，这是因为回调并不仅仅用在应用和库之间。任何时候，只要想获得类似于上面情况的灵活性，都可以利用回调。</p><p>这种灵活性是怎么实现的呢？乍看起来，回调似乎只是函数间的调用，但仔细一琢磨，可以发现两者之间的一个关键的不同：在回调中，我们利用某种方式，把回调函数像参数一样传入中间函数。可以这么理解，在传入一个回调函数之前，中间函数是不完整的。换句话说，程序可以在运行时，通过登记不同的回调函数，来决定、改变中间函数的行为。这就比简单的函数调用要灵活太多了。请看下面这段Python写成的回调的简单示例：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">even.py</span><br><span class="line">#回调函数1</span><br><span class="line">#生成一个2k形式的偶数</span><br><span class="line">def double(x):</span><br><span class="line">    return x * 2</span><br><span class="line">    </span><br><span class="line">#回调函数2</span><br><span class="line">#生成一个4k形式的偶数</span><br><span class="line">def quadruple(x):</span><br><span class="line">    return x * 4</span><br></pre></td></tr></tbody></table></figure></div><p><code>callback_demo.py</code></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">python</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> even <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#中间函数</span></span><br><span class="line"><span class="comment">#接受一个生成偶数的函数作为参数</span></span><br><span class="line"><span class="comment">#返回一个奇数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getOddNumber</span><span class="params">(k, getEvenNumber)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> + getEvenNumber(k)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#起始函数，这里是程序的主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>    </span><br><span class="line">    k = <span class="number">1</span></span><br><span class="line">    <span class="comment">#当需要生成一个2k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, double)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个4k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, quadruple)</span><br><span class="line">    print(i)</span><br><span class="line">    <span class="comment">#当需要一个8k+1形式的奇数时</span></span><br><span class="line">    i = getOddNumber(k, <span class="keyword">lambda</span> x: x * <span class="number">8</span>)</span><br><span class="line">    print(i)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></tbody></table></figure></div><p>运行<code>callback_demp.py</code>，输出如下：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">5</span><br><span class="line">9</span><br></pre></td></tr></tbody></table></figure></div><p>上面的代码里，给<code>getOddNumber</code>传入不同的回调函数，它的表现也不同，这就是回调机制的优势所在。值得一提的是，上面的第三个回调函数是一个匿名函数。</p><h2 id="易被忽略的第三方"><a href="#易被忽略的第三方" class="headerlink" title="易被忽略的第三方"></a>易被忽略的第三方</h2><p>通过上面的论述可知，中间函数和回调函数是回调的两个必要部分，不过人们往往忽略了回调里的第三位要角，就是中间函数的调用者。绝大多数情况下，这个调用者可以和程序的主函数等同起来，但为了表示区别，我这里把它称为<strong>起始函数</strong>（如上面的代码中注释所示）。</p><p>之所以特意强调这个第三方，是因为我在网上读相关文章时得到一种印象，很多人把它简单地理解为两个个体之间的来回调用。譬如，很多中文网页在解释“回调”（callback）时，都会提到这么一句话：“If you call me, I will call you back.”我没有查到这句英文的出处。我个人揣测，很多人把起始函数和回调函数看作为一体，大概有两个原因：第一，可能是“回调”这一名字的误导；第二，给中间函数传入什么样的回调函数，是在起始函数里决定的。实际上，回调并不是“你我”两方的互动，而是ABC的三方联动。有了这个清楚的概念，在自己的代码里实现回调时才不容易混淆出错。</p><p>另外，回调实际上有两种：阻塞式回调和延迟式回调。两者的区别在于：阻塞式回调里，回调函数的调用一定发生在起始函数返回之前；而延迟式回调里，回调函数的调用有可能是在起始函数返回之后。这里不打算对这两个概率做更深入的讨论，之所以把它们提出来，也是为了说明强调起始函数的重要性。网上的很多文章，提到这两个概念时，只是笼统地说阻塞式回调发生在主调函数返回之前，却没有明确这个主调函数到底是起始函数还是中间函数，不免让人糊涂，所以这里特意说明一下。另外还请注意，本文中所举的示例均为阻塞式回调。延迟式回调通常牵扯到多线程，最典型的例子是createThread(threadFuntion),这里threadFuntion是callback函数，createThread是中间函数，如果起始函数想等待线程完毕，就是用join函数。</p><h2 id="回调举例"><a href="#回调举例" class="headerlink" title="回调举例"></a>回调举例</h2><p>Java中的Arrays.sort()函数中sort方法已经实现了，但是compare的方式由callback提供。实现了sort算法和compare的解耦。增加任何不同的compare算法，sort都不用改变。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux目录</title>
      <link href="/2020/04/07/linux%E7%9B%AE%E5%BD%95/"/>
      <url>/2020/04/07/linux%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="Linux树状目录结构"><a href="#Linux树状目录结构" class="headerlink" title="Linux树状目录结构"></a>Linux树状目录结构</h2><p><a href="https://user-images.githubusercontent.com/36947860/109293154-5bf96380-7866-11eb-80e4-dfb16307ee26.png" data-fancybox="group" data-caption="image-20200407205340303" class="fancybox"><img alt="image-20200407205340303" data-src="https://user-images.githubusercontent.com/36947860/109293154-5bf96380-7866-11eb-80e4-dfb16307ee26.png" class="lazyload" title="image-20200407205340303"></a></p><blockquote><p>/boot 里面存放的系统内核文件，操作系统接管硬件后，首先读入/boot目录下的内核文件</p><p>/etc 是整个Linux系统的中心，其中包含所有系统管理和维护方面的配置文件，还有的配置文件分别位于不同的子目录下。该目录不包含 任何二进制文件，并且该目录下的所有文件主要由管理员使用，普通用户只对其具有阅读权限。该目录还包含一些网络配置文件、文件系统、x系统配置文件、设备配置信息、用户信息等。如passwd存放用户口令，shadow投影用户密码。</p><p>/lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。</p><p>/proc 这个目录是一个虚拟的目录，是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。这个目录的内容不在硬盘而是在内存中，我们也可以直接修改里面的某些文件。进程文件系统proc的根目录，其中的部分文件分别对应正在运行的进程，可用于访问当前进程的地址空间。它是一个非常特殊的虚拟文件系统，其中并不包含“实际的”文件，而是可用以引用当前运行系统的系统信息，如CPU、内存、运行时间、软件配置以及硬件配置的信息，这些信息是在内存中由系统自己产生的。/proc/net  其中的文件分别表示各种网络协议（如TCP、UDP以及ARP等）的状态与统计信息。/proc/sys  这个目录不仅存有各种系统信息，而且也包含系统内核与TCP/IP网络的可调参数。其中的kernel子目录含有共享内存和消息队列的可调参数，net子目录中含有TCP/IP的各种可调参数。例如，shmmax文件中含有系统的最大共享内存定义，如果使用“echo somevalue >/proc/sys/kernel/shmmax”命令，可以直接修改运行系统的内核参数，而无需重新引导系统。这一做法要谨慎，有的文件可能包含多个数值，或不同类型的数值，因此，在修改以前一定要弄清参数的意义和实际的数值。为了在每次启动系统时都能使用定制的系统可调参数，可以设置sysctl.conf配置文件，或编写自己的Shell启动脚本。</p></blockquote><hr><blockquote><p>/root 是超级用户的用户主目录</p><p>/home 是用户的用户主目录，在下面可以有不同用户的用户目录</p></blockquote><hr><blockquote><p>/usr 是一个庞大且重要的目录，我们要用到的很多应用程序和文件几乎都存放在这个目录了。/usr 里面放置的数据属于可分享的与不可变动的。全称是Unix System Resource。</p><p>/usr/bin 目录存放着最经常使用的命令</p><p>/usr/sbin 存放的是系统管理员使用的系统管理程序</p><p>/usr/lib 存放的系统最基本的动态连接共享库，主要是编程语言的库。典型的Linux操作系统包含了C、C++、Fortran的库文件。用这些语言开发的应用程序可以使用这些编程语言库。库文件包含了标准的C库/lib/libc.so ,数学库/lib/libm.so 等等。/lib/modules目录存放系统的核心模块，某些可被模块化的部分并不需要在编译系统核心时放入核心本体，避免本体过于庞大而导致效率过低。</p><p>/usr/include Linux开发和编译应用程序需要的头文件就在这里面。</p><p>/usr/local 是提供给一般用户的/usr目录，在这里安装软件最合适。可以理解为C:/program files。</p><p>/usr/src  Linux的源代码就存放在这里，屌不屌</p><p>/usr/share   用于存放一些共享的数据，比如音乐文件或者图标等等</p><p>/usr/games 存放Linux自带的小游戏</p></blockquote><hr><blockquote><p>/opt 目录是用户级别的程序目录，可以理解为D:/Software。安装到opt目录里下的程序，它所有的数据、库文件等等都是放在同一个目录下的。opt有可选的意思，这里可以用于放第三方大型软件和游戏，当不需要时，直接rm- rf掉即可。</p><p>/dev  dev是Device(设备)的缩写, 该目录下存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的。</p><p>/mnt 是默认的文件系统临时装载点，这是一个通用的安装点，可以临时安装任何文件系统或者远程资源。系统管理员执行mount命令完成装载工作。在系统中，该目录包含了光驱、磁盘和软驱的挂载点</p><p>/media Linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下。</p><!--/dev、/mnt、/media的区别与联系-->  <p>/dev 不是存放设备的驱动程序，而是作为访问外部设备文件的接口。比如，我们的U盘，插入linux系统后，用fdisk -l查看分区，显示文件为/dev/sda1。则我们可以将u盘挂载到/mnt/usb1下，mount /dev/sda1 /mnt/usb1 即可。</p><p>/mnt 是被系统管理员使用，手动挂载一些临时媒体设备的目录。</p><p>/media 是自动挂载的目录，比如我们的U盘插在ubuntu下会自动挂载，就会在/media下生成一个目录，这个目录就是U盘所在目录，或者说文件。</p><p>/mnt 和/media二者没有特殊的区别</p><!--/dev、/mnt、/media的区别与联系--></blockquote><hr><blockquote><p>/var————- 用于存放很多不断变化的文件，例如日志文件等。包含了日志文件、计划性任务和邮件等内容。　　　　　　</p><p>/var/cache  应用程序缓存目录；</p><p>/var/crash  系统错误信息；</p><p>/var/games 游戏数据；</p><p>/var/log  日志文件；</p><p>/var/mail 电子邮件；</p><p>/var/tmp  临时文件目录</p></blockquote></body></html>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从静态代理到动态代理</title>
      <link href="/2020/04/03/%E4%BB%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%88%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
      <url>/2020/04/03/%E4%BB%8E%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%88%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><p>代理和目标实现公共的接口</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span></span>{</span><br><span class="line">    doSomething();</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>代理和目标都需要实现接口，值得注意的是，代理中方法的实现会调用目标的方法实现</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Target</span> <span class="keyword">implements</span> <span class="title">Subject</span>()</span>{</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    doSomething(){</span><br><span class="line">        </span><br><span class="line">    }</span><br><span class="line">}</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StaticProxy</span> <span class="keyword">implements</span> <span class="title">Subject</span>()</span>{</span><br><span class="line">    Target target =<span class="keyword">new</span> Target();</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    doSomething(){</span><br><span class="line">        target.doSomething();</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>如果只有一个类有代理类，那么我们就可以用静态代理去实现，但是如果有多个类有代理类，都用静态代理的方式去实现，我们会感到无聊，因为已知一个类，要写出他的代理类，这个过程是一模一样的，我们不愿意一直重复做这种事，我们希望程序去做这种重复的事，而我们要做的，就是从中抽取公共的模式。</p><p>那么如何抽取这种公共的模式呢，答案是反射：我们知道一个方法的执行，既可以通过“ 对象.方法 ”来执行，也可以通过“ method.invoke(对象，参数)”来执行，而且invoke中可以传入方法的对象和参数。使用invoke的方式，对象可以是变量，那么就可以对不同的目标类实现代理类了。</p><p>下面这段代码就是从上述静态代理中抽取到的公共模式</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> interface <span class="title">InvocationHandler</span><span class="params">()</span></span>{</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object target)</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    }</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable</span></span><br><span class="line"><span class="function">    </span>{   </span><br><span class="line">        增加的逻辑；</span><br><span class="line">        method.invoke(target, args);</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure></div><p>也就是说，代理类实现invoke方法，这个invoke方法的参数中含有方法变量，然后，代理类的invoke最终会调用目标类的invoke方法。</p><p>那么我们怎么创建一个代理类呢，这里可能有人会说，直接new DynamicProxy()不就创建了吗？ 但完全不是这个样子的，这里的DynamicProxy类，其实只是对目标类中的invoke方法进行了包装，并没有真正包装我们想代理的方法。为了创建一个代理类，我们需要用到java提供的一个Proxy类。</p><p>从静态代理中我们观察到：</p><p>1、代理类和目标类实现了公共的接口，也就是说我们创建代理类的时候，需要用到公共的接口，才能知道要代理哪些方法。</p><p>2、同时代理类和目标类需要用到相同的类加载器</p><p>3、同时代理类还需要二次包装的invoke方法，因为二次包装的invoke方法里面实现了我们新增加的逻辑，如果不对invoke进行二次包装，我们就无法加入新增的逻辑</p><p>知道了这些，我们完全就可以构造一个代理类了，只需调用Proxy.newProxyInstance() 就可以了，把上述三个需要的条件当作参数传进去，就可以构造出一个代理类了。</p><p>参考：</p><p><a href="https://www.cnblogs.com/zhangchengzi/p/9713807.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangchengzi/p/9713807.html</a></p><p><a href="https://www.zhihu.com/question/20794107/answer/658139129" target="_blank" rel="noopener">https://www.zhihu.com/question/20794107/answer/658139129</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Unicode和utf_8</title>
      <link href="/2020/04/03/unicode%E5%92%8Cutf_8/"/>
      <url>/2020/04/03/unicode%E5%92%8Cutf_8/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="简单区别"><a href="#简单区别" class="headerlink" title="简单区别"></a>简单区别</h2><p>简单来说：</p><ul><li>Unicode是 【字符集】，为每一个字符分配一个唯一ID</li><li>UTF-8是 【编码规则】，将字符集的唯一ID转化成字节序列的规则</li></ul><h2 id="详细区别"><a href="#详细区别" class="headerlink" title="详细区别"></a>详细区别</h2><p>广义的Unicode是一个标准，定义了一个字符集和一系列编码规则，即Unicode字符集和UTF-8、UTF-16、UTF-32等等编码。</p><p>Unicode字符集为每一个字符分配一个码位，例如[知]的码位为30693，记作U+77E5（0x77E5）。</p><p>UTF-8 顾名思义，是一套以 8 位为一个编码单位的可变长编码。会将一个码位编码为 1 到 4 个字节：</p><p><a href="https://user-images.githubusercontent.com/36947860/78367963-78a8ff00-75f5-11ea-97ff-614210671f2a.png" data-fancybox="group" data-caption="微信截图_20200403214812" class="fancybox"><img alt="微信截图_20200403214812" data-src="https://user-images.githubusercontent.com/36947860/78367963-78a8ff00-75f5-11ea-97ff-614210671f2a.png" class="lazyload" title="微信截图_20200403214812"></a></p><p>根据上表中的编码规则，之前的「知」字的码位 U+77E5 属于第三行的范围：</p><p><a href="https://user-images.githubusercontent.com/36947860/78367965-79419580-75f5-11ea-86fc-de01b7df41ea.png" data-fancybox="group" data-caption="微信截图_20200403214827" class="fancybox"><img alt="微信截图_20200403214827" data-src="https://user-images.githubusercontent.com/36947860/78367965-79419580-75f5-11ea-86fc-de01b7df41ea.png" class="lazyload" title="微信截图_20200403214827"></a></p><p>这就是将U+77E5按照UTF-8编码为字节序列E79FA的过程。反之亦然。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2020/04/01/Spring/"/>
      <url>/2020/04/01/Spring/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h2><ul><li><p>Spring是一个开源的免费的框架（容器）！</p></li><li><p>Spring是一个轻量级的、非入侵式的框架！</p></li><li><p>控制反转（IOC）、面向切面编程（AOP）！</p></li><li><p>支持事务的处理，对框架整合的支持！</p><p><strong>总结一句话：Spring就是一个轻量级的控制反转（IOC）和面向切面编程的框架！</strong></p></li></ul><h2 id="导入Spring"><a href="#导入Spring" class="headerlink" title="导入Spring"></a>导入Spring</h2><p>Maven仓库：导入webmvc包会自动导入相关依赖；jdbc用于和Mybatis整合。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- https://mvnrepository.com/artifact/org.springframework/spring-webmvc --></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework<span class="tag"><!--<span class="name"-->groupId</span>></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-webmvc<span class="tag"><!--<span class="name"-->artifactId</span>></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>5.2.0.RELEASE<span class="tag"><!--<span class="name"-->version</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->dependency</span>></span><br><span class="line"><span class="comment"><!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc --></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.springframework<span class="tag"><!--<span class="name"-->groupId</span>></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>spring-jdbc<span class="tag"><!--<span class="name"-->artifactId</span>></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>5.2.0.RELEASE<span class="tag"><!--<span class="name"-->version</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->dependency</span>></span><br></pre></td></tr></tbody></table></figure></div><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p><strong>控制反转IOC（Inversion of Control），是一种设计思想，DI（依赖注入）是实现IOC的一种方法，</strong>也有人认为DI是IoC的另一种说法。没有IoC的程序中，我们使用面向对象编程，对象的创建与对象间的依赖关系完全硬编码在程序中，对象的创建由程序自己控制，控制反转后将对象的创建转移给第三方，个人认为所谓控制反转就是：获得依赖对象的方式反转了。</p><p>采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者合为一体，Bean的定义信息直接以注解的形式定义在实现类中，从而达到了零配置的目的。</p><p><strong>控制反转是一种通过描述（XML或注解）并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器，其实现方式是依赖注入（Dependency Injection,DI）</strong>。</p><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><p>依赖注入有两种形式：</p><ul><li>构造器注入</li><li>setter注入。</li></ul><p>这是通过反射实现的，这里如果忘记了可以复习一下反射</p><h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><p>三种方式：</p><ul><li>参数名赋值。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--第一种，直接通过参数名来设置--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"臭憨批"</span> /></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><ul><li>下标赋值。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--第二种，下标赋值！--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span> <span class="attr">value</span>=<span class="string">"憨批"</span> /></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><ul><li>类型赋值。</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--第三种，通过类型创建，不建议使用，重复类型难以分辨--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"java.lang.String"</span> <span class="attr">value</span>=<span class="string">"大憨批"</span> /></span></span><br><span class="line"><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><h4 id="Setter注入"><a href="#Setter注入" class="headerlink" title="Setter注入"></a>Setter注入</h4><p>Setter注入通过<code><property></property></code>标签设置每一个属性，值得注意的是，在Setter之前其实已经通过无参构造构造了对象，然后Setter为每个属性赋值</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><!--?xml version="1.0" encoding="UTF-8"?--></span></span><br><span class="line"><span class="tag"><<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"address"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Address"</span>/></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.Student"</span>></span></span><br><span class="line">        <span class="comment"><!--第一种，普通值注入，value--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"憨批"</span>/></span></span><br><span class="line">        <span class="comment"><!--第二种，Bean注入，ref--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"address"</span> <span class="attr">ref</span>=<span class="string">"address"</span>/></span></span><br><span class="line">        <span class="comment"><!--数组注入--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"books"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">array</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>红楼梦<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>西游记<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>水浒传<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>三国演义<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">            <span class="tag"><!--<span class="name"-->array</span>></span><br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line">        <span class="comment"><!--List注入--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hobbies"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">list</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>听歌<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>敲代码<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>看电影<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">            <span class="tag"><!--<span class="name"-->list</span>></span><br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line">        <span class="comment"><!--Map--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"card"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">map</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"身份证"</span> <span class="attr">value</span>=<span class="string">"1555555555"</span>/></span></span><br><span class="line">                <span class="tag"><<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"银行卡"</span> <span class="attr">value</span>=<span class="string">"5555555555"</span>/></span></span><br><span class="line">            <span class="tag"><!--<span class="name"-->map</span>></span><br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line">        <span class="comment"><!--Set--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"games"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">set</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>lol<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">                <span class="tag"><<span class="name">value</span>></span>wow<span class="tag"><!--<span class="name"-->value</span>></span><br><span class="line">            <span class="tag"><!--<span class="name"-->set</span>></span><br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line">        <span class="comment"><!--null--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"wife"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">null</span>/></span></span><br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line">        <span class="comment"><!--Properties--></span></span><br><span class="line">        <span class="tag"><<span class="name">property</span> <span class="attr">name</span>=<span class="string">"info"</span>></span></span><br><span class="line">            <span class="tag"><<span class="name">props</span>></span></span><br><span class="line">                <span class="tag"><<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"driver"</span>></span>com.mysql.jdbc.Driver<span class="tag"><!--<span class="name"-->prop</span>></span><br><span class="line">                <span class="tag"><<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"url"</span>></span>jdbc:mysql://localhost:3306/news<span class="tag"><!--<span class="name"-->prop</span>></span><br><span class="line">                <span class="tag"><<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"root"</span>></span>root<span class="tag"><!--<span class="name"-->prop</span>></span><br><span class="line">                <span class="tag"><<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"password"</span>></span>123456<span class="tag"><!--<span class="name"-->prop</span>></span><br><span class="line">            <span class="tag"><!--<span class="name"-->props</span>></span><br><span class="line">        <span class="tag"><!--<span class="name"-->property</span>></span><br><span class="line">    <span class="tag"><!--<span class="name"-->bean</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->beans</span>></span><br></pre></td></tr></tbody></table></figure></div><hr><p>人们为了偷懒，还有以下的写法，称为命名空间注入，其中p命名空间是Setter输入，c命名空间是构造器注入：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!--p命名空间注入，可以直接注入属性的值：property--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span> <span class="attr">p:name</span>=<span class="string">"憨批"</span> <span class="attr">p:age</span>=<span class="string">"18"</span>/></span></span><br><span class="line"><span class="comment"><!--c命名空间注入，通过构造器注入：construct-args--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"user2"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.User"</span> <span class="attr">c:age</span>=<span class="string">"18"</span> <span class="attr">c:name</span>=<span class="string">"憨批"</span>/></span></span><br></pre></td></tr></tbody></table></figure></div><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p><strong>自动装配其实就是将依赖注入“自动化”的一个简化配置的操作</strong></p><p>在Spring中有三种装配的方式：</p><h4 id="1、在xml中显式配置："><a href="#1、在xml中显式配置：" class="headerlink" title="1、在xml中显式配置："></a>1、在xml中显式配置：</h4><p>当bean中的属性中包含另外的bean时，我们可以通过byName或者byType的方式自动引入其他的bean，而不用像之前一样通过ref=” “来手动配置</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- byName的时候，需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致！--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.People"</span> <span class="attr">autowire</span>=<span class="string">"byName"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- byType的时候，需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致！--></span></span><br><span class="line"><span class="tag"><<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"people"</span> <span class="attr">class</span>=<span class="string">"com.kuang.pojo.People"</span> <span class="attr">autowire</span>=<span class="string">"byType"</span>></span><span class="tag"><!--<span class="name"-->bean</span>></span><br></pre></td></tr></tbody></table></figure></div><h4 id="2、注解实现自动装配"><a href="#2、注解实现自动装配" class="headerlink" title="2、注解实现自动装配"></a>2、注解实现自动装配</h4><p>使用注解须知：</p><ol><li>导入约束：context约束。</li><li>配置注解的支持：<code><context:annotation-config></context:annotation-config></code></li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"><!--?xml version="1.0" encoding="UTF-8"?--></span></span><br><span class="line"><span class="tag"><<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>></span></span><br><span class="line"></span><br><span class="line">    <span class="tag"><<span class="name">context:annotation-config</span>/></span></span><br><span class="line"></span><br><span class="line"><span class="tag"><!--<span class="name"-->beans</span>></span><br></pre></td></tr></tbody></table></figure></div><p><strong>@Autowired</strong> 直接在类的属性或者set方法上使用，当在属性上使用时，就可以不用写set方法了。</p><p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired完成的时候，我们可以使用<strong>@Qualifier(value=”xxx”)</strong> 去配置@Autowired的使用，指定一个唯一的bean对象注入！</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>{</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(value=<span class="string">"dog11"</span>)</span><br><span class="line">    <span class="keyword">private</span> Dog dog;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line"><span class="meta">@Qualifier</span>(value=<span class="string">"cat11"</span>)</span><br><span class="line">    <span class="keyword">private</span> Cat cat;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p>与Autowired相同作用的还有<strong>@Resource</strong> ，二者有些许的区别。</p><p><strong>xml与注解最佳实践：</strong></p><ul><li><p>xml用来管理bean；</p></li><li><p>注解只负责完成属性的注入；</p></li><li><p>我们在使用的过程中，只需要注意一个问题：必须让注解生效，就需要开启注解的支持。</p></li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment"><!--指定要扫描的包，这个包下的注解会生效--></span></span><br><span class="line"><span class="tag"><<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.kuang"</span>/></span></span><br><span class="line"><span class="tag"><<span class="name">context:annotation-config</span>/></span></span><br></pre></td></tr></tbody></table></figure></div><h4 id="3、通过JavaConfig实现自动装配"><a href="#3、通过JavaConfig实现自动装配" class="headerlink" title="3、通过JavaConfig实现自动装配"></a>3、通过JavaConfig实现自动装配</h4><ul><li><strong>组件扫描</strong><br>@Component 表示这个类需要在应用程序中被创建<br>@ComponentScan 自动发现应用程序中被创建的类</li><li><strong>自动装配</strong><br>@Autowired 自动满足Bean之间的依赖</li><li><strong>定义配置类</strong><br>@Configuration 表示当前类是一个配置类</li></ul><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Configuration 表示当前类是一个配置类,就和我们之前看的beans.xml</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KuangConfig</span> </span>{</span><br><span class="line">    <span class="comment">//注册一个bean，就相当于我们之前写的一个bean标签</span></span><br><span class="line">    <span class="comment">//这个方法的名字，就相当于bean标签中的id属性</span></span><br><span class="line">    <span class="comment">//这个方法的返回值，就相当于bean标签中的class属性</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">user</span><span class="params">()</span></span>{</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> User();<span class="comment">//就是返回要注入到bean的对象</span></span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h2 id="AOP-面向切面编程"><a href="#AOP-面向切面编程" class="headerlink" title="AOP(面向切面编程)"></a>AOP(面向切面编程)</h2><p>AOP（Aspect Oriented Programming）意为：面向切面编程，通过预编译方式和运行期动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生泛型，利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的频率。</p><h3 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h3><ul><li>横切关注点：跨越应用程序多个模块的方法或功能。即与我们业务逻辑无关的，但是我们需要关注的部分，就是横切关注点。</li><li>Apsect （即切面）：切面一般定义为一个java类，每个切面侧重于特定的跨领域功能，比如，事务管理或者打印日志</li><li>advice（通知）：切面必须要完成的工作。它是类中的一个方法</li><li>target（目标）：被通知对象</li><li>proxy （代理）：向目标对象应用通知之后创建的对象</li><li>pointcut（切入点）：切面通知执行的“地点”的定义</li><li>jointpoint（连接点）：与切入点匹配的执行点</li></ul><h3 id="在Spring中使用AOP"><a href="#在Spring中使用AOP" class="headerlink" title="在Spring中使用AOP"></a>在Spring中使用AOP</h3><p>使用AOP，需要导入依赖包。</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><!-- https://mvnrepository.com/artifact/org.aspectj/aspectjweaver --></span></span><br><span class="line"><span class="tag"><<span class="name">dependency</span>></span></span><br><span class="line">    <span class="tag"><<span class="name">groupId</span>></span>org.aspectj<span class="tag"><!--<span class="name"-->groupId</span>></span><br><span class="line">    <span class="tag"><<span class="name">artifactId</span>></span>aspectjweaver<span class="tag"><!--<span class="name"-->artifactId</span>></span><br><span class="line">    <span class="tag"><<span class="name">version</span>></span>1.9.5<span class="tag"><!--<span class="name"-->version</span>></span><br><span class="line"><span class="tag"><!--<span class="name"-->dependency</span>></span><br></pre></td></tr></tbody></table></figure></div><h4 id="方式一：使用Spring的API接口【主要SpringAPI接口实现】"><a href="#方式一：使用Spring的API接口【主要SpringAPI接口实现】" class="headerlink" title="方式一：使用Spring的API接口【主要SpringAPI接口实现】"></a>方式一：使用Spring的API接口【主要SpringAPI接口实现】</h4><p>SpringAOP中，通过Advice定义横切逻辑，Spring支持5种类型的Advice</p><p><a href="https://user-images.githubusercontent.com/36947860/79048481-e71e3a80-7c4f-11ea-8bef-8ac74bc0862b.png" data-fancybox="group" data-caption="image-20200106090428369" class="fancybox"><img alt="image-20200106090428369" data-src="https://user-images.githubusercontent.com/36947860/79048481-e71e3a80-7c4f-11ea-8bef-8ac74bc0862b.png" class="lazyload" title="image-20200106090428369"></a></p><p>当我们实现了接口中的方法时，需要在xml中配置AOP，如下所示：</p><p><a href="https://user-images.githubusercontent.com/36947860/79048484-ec7b8500-7c4f-11ea-9666-a24b935227cb.png" data-fancybox="group" data-caption="微信截图_20200411235348" class="fancybox"><img alt="微信截图_20200411235348" data-src="https://user-images.githubusercontent.com/36947860/79048484-ec7b8500-7c4f-11ea-9666-a24b935227cb.png" class="lazyload" title="微信截图_20200411235348"></a></p><h4 id="方式二：自定义来实现AOP【主要是切面定义】"><a href="#方式二：自定义来实现AOP【主要是切面定义】" class="headerlink" title="方式二：自定义来实现AOP【主要是切面定义】"></a>方式二：自定义来实现AOP【主要是切面定义】</h4><p>上一种是使用Spring内置的advice。第二中我们需要自己定义aspect和aspect中的advice。写完之后同样要在xml中配置</p><p><a href="https://user-images.githubusercontent.com/36947860/79048656-2436fc80-7c51-11ea-9b8d-1697f475c1ca.png" data-fancybox="group" data-caption="微信截图_20200412000307" class="fancybox"><img alt="微信截图_20200412000307" data-src="https://user-images.githubusercontent.com/36947860/79048656-2436fc80-7c51-11ea-9b8d-1697f475c1ca.png" class="lazyload" title="微信截图_20200412000307"></a></p><h4 id="方式三：使用注解实现"><a href="#方式三：使用注解实现" class="headerlink" title="方式三：使用注解实现"></a>方式三：使用注解实现</h4><p>之前的方法需要配置xml，Spring中可以通过注解实现。但是要在xml中开启aop注解支持</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">xml</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight xml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag"><<span class="name">aop:aspect-autoproxy</span>></span></span><br></pre></td></tr></tbody></table></figure></div><p><a href="https://user-images.githubusercontent.com/36947860/79048840-5eed6480-7c52-11ea-8efc-dc0c02506574.png" target="_blank" rel="noopener"><img alt="微信截图_20200412001250" data-src="https://user-images.githubusercontent.com/36947860/79048840-5eed6480-7c52-11ea-8efc-dc0c02506574.png" class="lazyload"></a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>归根到底，Spring解决了一个什么问题呢？</p><p>想一想，如果世界上只有一只猫，一只狗，我们有必要创造出一个猫类，然后把这只猫看作猫类的对象吗？我们有必要创造出一个狗类，把这条狗看作狗类的一个对象吗？我们完全可以说，猫类就是猫，猫就是猫类，狗类就是狗，狗就是狗类。但是由于java面向对象的机制，我们却不能这样。</p><p>当所有的类只有一个对象时，我们在类与类之间构建的关系其实就是在对象与对象之间构建的关系，但是由于JAVA面向对象的机制，我们不得不先构建出类之间的关系，再new出对象同时构建对象之间的关系。其实对象之间的关系是完全复刻类之间的关系的，我们没必要把这个关系构建两遍，第二遍完全可以交给机器去做，这个机器就是Spring容器。（这里我们只讨论bean的<code>scope="singleton"</code>）</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反射</title>
      <link href="/2020/03/31/%E5%8F%8D%E5%B0%84/"/>
      <url>/2020/03/31/%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="动态语言和静态语言"><a href="#动态语言和静态语言" class="headerlink" title="动态语言和静态语言"></a>动态语言和静态语言</h3><ul><li>动态语言<ul><li>是一种可以在运行时改变其结构的语言，例如新的函数、对象、甚至代码可以在运行时被引进，已有的函数可以被删除或是 其他结构上的变化。通俗的讲就是在运行时代码可以根据某些条件改变自身结构</li><li>举例：Object-C、C#、JavaScript、PHP、Python</li></ul></li><li>静态语言<ul><li>与动态语言相对的，运行时结构不可改变的语言</li><li>C、C++、JAVA</li></ul></li><li>java不是动态语言，但通过反射机制实现类似动态语言的特性</li></ul><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><h3 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h3><ul><li><p>通过类名获得：  <code>类名.class</code> , 最高效</p></li><li><p>通过对象获得：  <code>对象.getClass()</code></p></li><li>通过forname获得 ：<code>Class.forName(" ")</code></li><li>通过内置类型的包装类获得：<code>内置类型包装类.TYPE</code></li><li>已知一个Class，获取其获得父类Class：<code>Class.getSuperclass()</code></li></ul><h3 id="哪些类型可以有Class对象"><a href="#哪些类型可以有Class对象" class="headerlink" title="哪些类型可以有Class对象"></a>哪些类型可以有Class对象</h3><ul><li>类</li><li>接口</li><li>数组（同一维度的数组是同一个Class对象，不同维度的数组是不同的Class对象）</li><li>注解</li><li>枚举</li><li>基本数据类型</li><li>void</li><li>Class</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/78367926-6cbd3d00-75f5-11ea-8ab0-46d68b3559c6.png" data-fancybox="group" data-caption="QQ截图20200331110904" class="fancybox"><img alt="QQ截图20200331110904" data-src="https://user-images.githubusercontent.com/36947860/78367926-6cbd3d00-75f5-11ea-8ab0-46d68b3559c6.png" class="lazyload" title="QQ截图20200331110904"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/78367938-6fb82d80-75f5-11ea-8d4c-ac6fb4519840.png" data-fancybox="group" data-caption="QQ截图20200331110935" class="fancybox"><img alt="QQ截图20200331110935" data-src="https://user-images.githubusercontent.com/36947860/78367938-6fb82d80-75f5-11ea-8d4c-ac6fb4519840.png" class="lazyload" title="QQ截图20200331110935"></a></p><h2 id="使用反射"><a href="#使用反射" class="headerlink" title="使用反射"></a>使用反射</h2><h3 id="反射操作Class对象"><a href="#反射操作Class对象" class="headerlink" title="反射操作Class对象"></a>反射操作Class对象</h3><p>JVM在第一次读取到一中<code>class</code>类型时，就将其加载入内存。每加载一种<code>class</code>,JVM就为其创建一个<code>Class</code>类型的实例，并关联起来。这个<code>Class</code>实例是在JVM内部创建的，构造方法是<code>private</code>，只有JVM能创建<code>Class</code>实例，我们自己的JAVA程序无法创建。</p><p>通过引入<code>import java.lang.reflect.Field;</code>可以通过<code>Field</code>获取一个类的字段,进而通过<code>get</code>和<code>set</code>方法获取和修改对象的字段值</p><p>通过引入<code>import java.lang.reflect.Method;</code>可以通过<code>Method</code>获取一个类的方法，进而通过<code>invoke</code>调用方法</p><p>通过引入<code>import java.lang.reflect.Constructor;</code>可以通过Constructor获取一个类的构造方法，进而通过<code>newInstance()</code>方法构造一个类的实例（也可以在获取Class的newInstance方法，但是这样做只能调用无参构造方法）.</p><p>我们还可以通过<code>getSuperclass()</code>获取一个类的父类，通过<code>getInterfaces()</code>获取一个类的接口，</p><h3 id="反射操作泛型"><a href="#反射操作泛型" class="headerlink" title="反射操作泛型"></a>反射操作泛型</h3><p>为了反射操作泛型，JAVA新增了几种类型</p><ul><li>ParameterizedType ：表示一种参数化类型，比如Collection<string></string></li><li>GenericArrayType ：表示一种元素类型时参数化类型或者类型变量的数组类型</li><li>TypeVariable：是各种类型变量的通用父接口</li><li>WildcardType：代表一种通配符类型表达式</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/78367962-7777d200-75f5-11ea-81ae-07955544d1d1.png" data-fancybox="group" data-caption="QQ截图20200401231916" class="fancybox"><img alt="QQ截图20200401231916" data-src="https://user-images.githubusercontent.com/36947860/78367962-7777d200-75f5-11ea-81ae-07955544d1d1.png" class="lazyload" title="QQ截图20200401231916"></a></p><p>如图所示：</p><p>test01是一个以泛型为参数的方法，当我们对test01使用method.getGenericParameterTypes() 方法时，只能得到Map<string,user> 和List <user>  （这两个就是ParameterizedType类型）,而无法获得尖括号里面的Object，为此，我们还需要对其使用getActualTypeArguments()方法。</user></string,user></p><p>以上就是泛型作为函数参数时通过反射获取的方法，当泛型作为函数返回值时，我们只需要将method.getGenericParameterTypes() 换成method.getGenericReturnTypes() 即可。</p><h3 id="反射操作注解"><a href="#反射操作注解" class="headerlink" title="反射操作注解"></a>反射操作注解</h3><ul><li><p>获取一个类的全部注解： getAnnotations()</p></li><li><p>获取指定注解 ：getAnnotation(注解.class)</p></li></ul><p>获取注解后，可以进一步通过 “.字段”来获取注解的字段值</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA注解</title>
      <link href="/2020/03/31/JAVA%E6%B3%A8%E8%A7%A3/"/>
      <url>/2020/03/31/JAVA%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>Annotation是从JDK5.0开始引入的新技术，不是程序本身，可以对程序作出解释。</p><h2 id="三个内置注解："><a href="#三个内置注解：" class="headerlink" title="三个内置注解："></a>三个内置注解：</h2><p>@Override  （重写）：代表一个重新的方法</p><p>@Deprecated （过时的）：代表一个程序元素是不被推荐使用的，但是可以使用，在最新版本中已经被淘汰</p><p>@SuppressWarnings()  （镇压警告）：可以有参数，代表镇压的等级</p><h2 id="四个元注解："><a href="#四个元注解：" class="headerlink" title="四个元注解："></a>四个元注解：</h2><p>元注解是负责解释其他注解的注解，在定义注解时使用</p><p>@Target （位置）：可以传一个ElementType的参数，代表注解可以作用的程序元素类型</p><p>@Retention（时间）：表示注解在什么时间段（程序生命周期）有效，value可取三个值 runtime，class，sources</p><p>@Documented（文档）：表示我们的注解将被包含在JAVA文档中</p><p>@Inherited（继承）：表示子类可以继承父类的注解</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>1、定义注解用 @interface，所有的注解会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口。</p><p>2、参数成员只能用<strong>public</strong>或默认(<strong>default</strong>)这两个访问权修饰</p><p>3、参数成员只能用基本类型byte，short，char，int，long，float，double，boolean<strong>八种基本数据类型和</strong>String、Enum、Class、annotations等数据类型，以及这一些类型的<strong>数组。</strong></p><p>4、注解的参数格式为   参数类型+参数名()+值</p><p>5、当定义的注解只有一个参数时，可以将参数名设置为value，这样在调用注解时，可以简略传参。</p><p>6、可以通过default来声明参数的默认值</p><p>7、注解也可以没有定义成员, 不过这样注解就没啥用了，只起到标识作用</p><p><a href="https://user-images.githubusercontent.com/36947860/78367920-69c24c80-75f5-11ea-8c29-fbb9db6614c9.png" data-fancybox="group" data-caption="QQ截图20200331103153" class="fancybox"><img alt="QQ截图20200331103153" data-src="https://user-images.githubusercontent.com/36947860/78367920-69c24c80-75f5-11ea-8c29-fbb9db6614c9.png" class="lazyload" title="QQ截图20200331103153"></a></p><h2 id="读取注解"><a href="#读取注解" class="headerlink" title="读取注解"></a>读取注解</h2><p>要获取类、方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,除此之外没有别的获取注解对象的方法。</p><p>例如：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">method.getAnnotation(MyMethodAnnotation<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></tbody></table></figure></div><p>获取注解后就可以对注解进行解析，从而进行一些小小的检查或者控制功能。</p><p>参考文献</p><p><a href="https://www.cnblogs.com/a591378955/p/8350499.html" target="_blank" rel="noopener">https://www.cnblogs.com/a591378955/p/8350499.html</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回车换行</title>
      <link href="/2020/03/26/%E5%9B%9E%E8%BD%A6%E6%8D%A2%E8%A1%8C/"/>
      <url>/2020/03/26/%E5%9B%9E%E8%BD%A6%E6%8D%A2%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h1 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h1><ul><li>CR：Carriage Return，对应ASCII中转义字符\r，表示回车</li><li>LF：Linefeed，对应ASCII中转义字符\n，表示换行</li><li>CRLF：Carriage Return & Linefeed，\r\n，表示回车并换行</li></ul><p>众所周知，Windows操作系统采用两个字符来进行换行，即CRLF；Unix/Linux/Mac OS X操作系统采用单个字符LF来进行换行；另外，MacIntosh操作系统（即早期的Mac操作系统）采用单个字符CR来进行换行。</p><h1 id="野史"><a href="#野史" class="headerlink" title="野史"></a>野史</h1><p><a href="https://user-images.githubusercontent.com/36947860/77649917-964ae880-6fa5-11ea-8f0e-1a27df2574b3.png" data-fancybox="group" data-caption="微信截图_20200326210315" class="fancybox"><img alt="微信截图_20200326210315" data-src="https://user-images.githubusercontent.com/36947860/77649917-964ae880-6fa5-11ea-8f0e-1a27df2574b3.png" class="lazyload" title="微信截图_20200326210315"></a></p><p>老式机械打字机（来源：视觉中国）</p><p>据野史记载，在很久以前的机械打字机时代，CR和LF分别具有不同的作用：LF会将打印纸张上移一行位置，但是保持当前打字的水平位置不变；CR则会将“Carriage”（打字机上的滚动托架）滚回到打印纸张的最左侧，但是保持当前打字的垂直位置不变，即还是在同一行。</p><p>当CR和LF组合使用时，则会将打印纸张上移一行，且下一个打字位置将回到该行的最左侧，也就是我们今天所理解的换行操作。</p><p>随着时间的推移，机械打字机渐渐地退出了历史舞台，当初的纸张变成了今天的显示器，打字机的按键也演变为了如今的键盘。在操作系统出现的年代，受限于内存和软盘空间的不足，一些操作系统的设计者决定采用单个字符来表示换行符，如Unix的LF、MacIntosh的CR。他们的意图都是为了进行换行操作，只是当初并没有一个国际标准（或者其他原因，鬼知道），所以才有这样字符上的不同。</p><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>许多现代的文本编辑器和命令行工具都提供了可选择的换行符配置，方便用户按照自己的意愿来改变换行符的表现形式，所以我们只需要知道CRLF、CR、LF的作用即可。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Fine Tuning和feature Based</title>
      <link href="/2020/03/25/fine-tuning%E5%92%8Cfeature-based/"/>
      <url>/2020/03/25/fine-tuning%E5%92%8Cfeature-based/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="feature-based"><a href="#feature-based" class="headerlink" title="feature-based:"></a>feature-based:</h2><p>又称feature-extraction 特征提取。就是用预训练好的网络在新样本上提取出相关的特征，然后将这些特征输入一个新的分类器，从头开始训练的过程。也就是说在训练的过程中，网络的特征提取层是被冻结的，只有后面的密集链接分类器部分是可以参与训练的。</p><h2 id="fine-tuning"><a href="#fine-tuning" class="headerlink" title="fine-tuning:"></a>fine-tuning:</h2><p>微调。和feature-based的区别是，训练好新的分类器后，还要解冻特征提取层的顶部的几层，然后和分类器再次进行联合训练。之所以称为微调，就是因为在预训练好的参数上进行训练更新的参数，比预训练好的参数的变化相对小，这个相对是指相对于不采用预训练模型参数来初始化下游任务的模型参数的情况。也有一种情况，如果你有大量的数据样本可以训练，那么就可以解冻所有的特征提取层，全部的参数都参与训练，但由于是基于预训练的模型参数，所以仍然比随机初始化的方式训练全部的参数要快的多。例如有的团队使用BERT模型在下游任务的微调时，就采用了解冻所有层，微调所有参数的方法。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自回归和自编码</title>
      <link href="/2020/03/25/%E8%87%AA%E5%9B%9E%E5%BD%92%E5%92%8C%E8%87%AA%E7%BC%96%E7%A0%81/"/>
      <url>/2020/03/25/%E8%87%AA%E5%9B%9E%E5%BD%92%E5%92%8C%E8%87%AA%E7%BC%96%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p><a href="https://user-images.githubusercontent.com/36947860/77530829-e1dd9380-6ecc-11ea-96af-d8ecb9ba8ee9.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://user-images.githubusercontent.com/36947860/77530829-e1dd9380-6ecc-11ea-96af-d8ecb9ba8ee9.jpg" class="lazyload" title="img"></a></p><h2 id="自回归"><a href="#自回归" class="headerlink" title="自回归"></a>自回归</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>根据上文内容预测下一个可能跟随的单词，就是常说的自左向右的语言模型任务，或者反过来也行，就是根据下文预测前面的单词，这种类型的LM被称为自回归语言模型。（GPT,ELMO）GPT 就是典型的自回归语言模型。ELMO尽管看上去利用了上文，也利用了下文，但是本质上仍然是自回归LM，这个跟模型具体怎么实现有关系。ELMO是做了两个方向（从左到右以及从右到左两个方向的语言模型），但是是分别有两个方向的自回归LM，然后把LSTM的两个方向的隐节点状态拼接到一起，来体现双向语言模型这个事情的。所以其实是两个自回归语言模型的拼接，本质上仍然是自回归语言模型。</p><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>自回归语言模型有优点有缺点，缺点是只能利用上文或者下文的信息，不能同时利用上文和下文的信息，当然，貌似ELMO这种双向都做，然后拼接看上去能够解决这个问题，因为融合模式过于简单，所以效果其实并不是太好。它的优点，其实跟下游NLP任务有关，比如生成类NLP任务，比如文本摘要，机器翻译等，在实际生成内容的时候，就是从左向右的，自回归语言模型天然匹配这个过程。而Bert这种DAE模式，在生成类NLP任务中，就面临训练过程和应用过程不一致的问题，导致生成类的NLP任务到目前为止都做不太好。</p><h2 id="自编码"><a href="#自编码" class="headerlink" title="自编码"></a>自编码</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>自回归语言模型只能根据上文预测下一个单词，或者反过来，只能根据下文预测前面一个单词。相比而言，Bert通过在输入X中随机Mask掉一部分单词，然后预训练过程的主要任务之一是根据上下文单词来预测这些被Mask掉的单词，如果你对Denoising Autoencoder比较熟悉的话，会看出，这确实是典型的DAE的思路。那些被Mask掉的单词就是在输入侧加入的所谓噪音。类似Bert这种预训练模式，被称为DAE LM。</p><h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><p>这种DAE LM的优缺点正好和自回归LM反过来，它能比较自然地融入双向语言模型，同时看到被预测单词的上文和下文，这是好处。缺点是啥呢？主要在输入侧引入[Mask]标记，导致预训练阶段和Fine-tuning阶段不一致的问题，因为Fine-tuning阶段是看不到[Mask]标记的。DAE吗，就要引入噪音，[Mask] 标记就是引入噪音的手段，这个正常。</p><h2 id="XLNet"><a href="#XLNet" class="headerlink" title="XLNet"></a>XLNet</h2><p>XLNet的出发点就是：能否融合自回归LM和DAE LM两者的优点。就是说如果站在自回归LM的角度，如何引入和双向语言模型等价的效果；如果站在DAE LM的角度看，它本身是融入双向语言模型的，如何抛掉表面的那个[Mask]标记，让预训练和Fine-tuning保持一致。当然，XLNet还讲到了一个Bert被Mask单词之间相互独立的问题。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BERT</title>
      <link href="/2020/03/25/BERT/"/>
      <url>/2020/03/25/BERT/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="早期词嵌入模型"><a href="#早期词嵌入模型" class="headerlink" title="早期词嵌入模型"></a>早期词嵌入模型</h3><p>CBOW和Skip-gram</p><p><a href="https://user-images.githubusercontent.com/36947860/77542330-fa57a900-6ee0-11ea-9a94-02ce74f9d8fb.png" data-fancybox="group" data-caption="微信截图_20200325213702" class="fancybox"><img alt="微信截图_20200325213702" data-src="https://user-images.githubusercontent.com/36947860/77542330-fa57a900-6ee0-11ea-9a94-02ce74f9d8fb.png" class="lazyload" title="微信截图_20200325213702"></a></p><p>CBOW在训练过程中把每个词都预测一遍。</p><p>BERT在训练过程中作者随机mask 15%的token。</p><h3 id="BERT模型"><a href="#BERT模型" class="headerlink" title="BERT模型"></a>BERT模型</h3><p>BERT的全称是Bidirectional Encoder Representation from Transformers，即双向Transformer的Encoder，因为decoder是不能获要预测的信息的。模型的主要创新点都在pre-train方法上，即用了Masked LM和Next Sentence Prediction两种方法分别捕捉词语和句子级别的representation</p><p><a href="https://user-images.githubusercontent.com/36947860/77530829-e1dd9380-6ecc-11ea-96af-d8ecb9ba8ee9.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://user-images.githubusercontent.com/36947860/77530829-e1dd9380-6ecc-11ea-96af-d8ecb9ba8ee9.jpg" class="lazyload" title="img"></a></p><h3 id="Embedding"><a href="#Embedding" class="headerlink" title="Embedding"></a>Embedding</h3><p>这里的Embedding由三种Embedding求和而成：</p><p><a href="https://user-images.githubusercontent.com/36947860/77530837-e3a75700-6ecc-11ea-9e01-4645f60ce6fd.png" data-fancybox="group" data-caption="微信截图_20200325190512" class="fancybox"><img alt="微信截图_20200325190512" data-src="https://user-images.githubusercontent.com/36947860/77530837-e3a75700-6ecc-11ea-9e01-4645f60ce6fd.png" class="lazyload" title="微信截图_20200325190512"></a></p><h3 id="BERT-的训练"><a href="#BERT-的训练" class="headerlink" title="BERT 的训练"></a>BERT 的训练</h3><p><strong>Approach 1: Masked LM</strong></p><p><a href="https://user-images.githubusercontent.com/36947860/77530838-e5711a80-6ecc-11ea-9741-5fe06542c132.png" data-fancybox="group" data-caption="微信截图_20200325190650" class="fancybox"><img alt="微信截图_20200325190650" style="zoom:67%;" data-src="https://user-images.githubusercontent.com/36947860/77530838-e5711a80-6ecc-11ea-9741-5fe06542c132.png" class="lazyload" title="微信截图_20200325190650"></a></p><p><strong>Approach 2: Next Sentence Prediction</strong></p><p><a href="https://user-images.githubusercontent.com/36947860/77530847-e99d3800-6ecc-11ea-9c87-3ee45c5d1afb.png" data-fancybox="group" data-caption="微信截图_20200325190725" class="fancybox"><img alt="微信截图_20200325190725" style="zoom: 67%;" data-src="https://user-images.githubusercontent.com/36947860/77530847-e99d3800-6ecc-11ea-9c87-3ee45c5d1afb.png" class="lazyload" title="微信截图_20200325190725"></a></p><p>同时用方法1和方法2训练效果比较好</p><h3 id="BERT-的使用"><a href="#BERT-的使用" class="headerlink" title="BERT 的使用"></a>BERT 的使用</h3><ul><li>Single sentence classify ，对【CLS】的输出向量接一个线性分类器</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/77530850-eace6500-6ecc-11ea-9e07-b6bcebd26432.png" data-fancybox="group" data-caption="微信截图_20200325190958" class="fancybox"><img alt="微信截图_20200325190958" data-src="https://user-images.githubusercontent.com/36947860/77530850-eace6500-6ecc-11ea-9e07-b6bcebd26432.png" class="lazyload" title="微信截图_20200325190958"></a></p><ul><li>Slot filling，对每一个word的输出向量接一个线性分类器</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/77530856-ec982880-6ecc-11ea-9b90-54a5fdcf3260.png" data-fancybox="group" data-caption="微信截图_20200325191022" class="fancybox"><img alt="微信截图_20200325191022" data-src="https://user-images.githubusercontent.com/36947860/77530856-ec982880-6ecc-11ea-9b90-54a5fdcf3260.png" class="lazyload" title="微信截图_20200325191022"></a></p><ul><li>Natural Language Inference ，对【CLS】的输出向量接一个线性分类器</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/77530862-edc95580-6ecc-11ea-9591-a3aa883134a6.png" data-fancybox="group" data-caption="微信截图_20200325191038" class="fancybox"><img alt="微信截图_20200325191038" data-src="https://user-images.githubusercontent.com/36947860/77530862-edc95580-6ecc-11ea-9591-a3aa883134a6.png" class="lazyload" title="微信截图_20200325191038"></a></p><ul><li>Extraction-based Question Answering ，对document的输出向量做dot product计算开始坐标和结束坐标</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/77530867-ef931900-6ecc-11ea-9fd9-dcfa70e33d09.png" data-fancybox="group" data-caption="微信截图_20200325191118" class="fancybox"><img alt="微信截图_20200325191118" data-src="https://user-images.githubusercontent.com/36947860/77530867-ef931900-6ecc-11ea-9fd9-dcfa70e33d09.png" class="lazyload" title="微信截图_20200325191118"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/77530775-d25e4a80-6ecc-11ea-865f-4ec957e723a7.png" data-fancybox="group" data-caption="微信截图_20200325191134" class="fancybox"><img alt="微信截图_20200325191134" data-src="https://user-images.githubusercontent.com/36947860/77530775-d25e4a80-6ecc-11ea-865f-4ec957e723a7.png" class="lazyload" title="微信截图_20200325191134"></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>牛顿法</title>
      <link href="/2020/03/23/%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
      <url>/2020/03/23/%E7%89%9B%E9%A1%BF%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="牛顿法计算过程"><a href="#牛顿法计算过程" class="headerlink" title="牛顿法计算过程"></a>牛顿法计算过程</h3><p>五次及以上多项式方程没有根式解。但是没有根式解不意味着方程解不出来。</p><p>可以用牛顿法来解。图示就是牛顿法的过程。</p><p><a href="https://pic4.zhimg.com/80/v2-ea00a4c57c49e64123c56ebb06340f0c_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/80/v2-ea00a4c57c49e64123c56ebb06340f0c_720w.jpg" class="lazyload" title="img"></a></p><p>给定函数f</p><p>首先，我们随机选一个点A，求A点的切线。</p><p>再求的A点的切线的解，带入f求得点B。</p><p>再求点B的切线。</p><p>再求的B点的切线的解，带入f求得点C。</p><p>再求点C的切线</p><p>……</p><h3 id="牛顿法适用条件"><a href="#牛顿法适用条件" class="headerlink" title="牛顿法适用条件"></a>牛顿法适用条件</h3><p>牛顿法并不总是收敛（总是可以求得足够近似的根），收敛的充分条件为：若$f$二阶可导，那么在待求的零点 $X$周围存在一个区域，只要起始点$X_0$位于这个邻近区域内，那么牛顿-拉弗森方法必定收敛</p><h3 id="牛顿法局限性"><a href="#牛顿法局限性" class="headerlink" title="牛顿法局限性"></a>牛顿法局限性</h3><ul><li>初值的选择对问题的求解影响很大，可能导致求不出来、或者求解效率低</li><li>无法得知有几个根。就算知道有几个根，也不一定可以尽数求出</li><li>迭代过程中，不知道这次迭代的值和根的误差有多大</li></ul></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>集束搜索</title>
      <link href="/2020/03/22/%E9%9B%86%E6%9D%9F%E6%90%9C%E7%B4%A2/"/>
      <url>/2020/03/22/%E9%9B%86%E6%9D%9F%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="Wiki解释"><a href="#Wiki解释" class="headerlink" title="Wiki解释"></a>Wiki解释</h3><p>Beam Search（集束搜索）是一种启发式图搜索算法，通常用在图的解空间比较大的情况下，为了减少搜索所占用的空间和时间，在每一步深度扩展的时候，剪掉一些质量比较差的结点，保留下一些质量较高的结点。这样减少了空间消耗，并提高了时间效率。</p><h3 id="NLP中的应用"><a href="#NLP中的应用" class="headerlink" title="NLP中的应用"></a>NLP中的应用</h3><p>本人发现这个算法是在读NLP的相关论文时，下面从这个角度分析以下集束搜索。</p><p>在做文本生成时，每一个时间步可能的输出种类是词典的大小，在如此大的基数下，遍历整个生成空间是不现实的。</p><h4 id="贪心策略"><a href="#贪心策略" class="headerlink" title="贪心策略"></a>贪心策略</h4><p>最容易想到的策略是贪心搜索，即每个时间步都取一个条件概率最大的输出，再将从开始到当前步的结果作为输入去获得下一个时间步的输出，直到模型给出生成结束的标志。例如下图，每一个时间步都取出了条件概率最大一个结果，生成了序列<code>[A,B,C]</code>。</p><p><a href="https://pic4.zhimg.com/v2-8b97ab38c910e9d6b767a6cd7738a3db_b.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/v2-8b97ab38c910e9d6b767a6cd7738a3db_b.jpg" class="lazyload" title="img"></a></p><p>很明显，这样做将原来指数级别的求解空间直接压缩到了与长度线性相关的大小。由于丢弃了绝大多数的可能解，这种<strong>关注当下</strong>的策略无法保证最终得到的序列概率是最优的。</p><h4 id="Beam-search"><a href="#Beam-search" class="headerlink" title="Beam search"></a>Beam search</h4><p>而beam search是对贪心策略一个改进。思路也很简单，就是稍微放宽一些考察的范围。在每一个时间步，不再只保留当前分数最高的<strong>1</strong>个输出，而是保留<strong>num_beams</strong>个。<strong>当num_beams=1时集束搜索就退化成了贪心搜索。</strong></p><p>下图是一个实际的例子，每个时间步有ABCDE共5种可能的输出，即，图中的num_beams=2，也就是说每个时间步都会保留到当前步为止条件概率最优的2个序列。</p><p><a href="https://pic2.zhimg.com/v2-a760198d6b851fc38c8d21830d1f27c9_b.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/v2-a760198d6b851fc38c8d21830d1f27c9_b.jpg" class="lazyload" title="img"></a>Beam Search示意图</p><ul><li>在第一个时间步，A和C是最优的两个，因此得到了两个结果<code>[A],[C]</code>，其他三个就被抛弃了；</li><li>第二步会基于这两个结果继续进行生成，在A这个分支可以得到5个候选人，<code>[AA],[AB],[AC],[AD],[AE]</code>，C也同理得到5个，此时会对这10个进行统一排名，再保留最优的两个，即图中的<code>[AB]</code>和<code>[CE]</code>；</li><li>第三步同理，也会从新的10个候选人里再保留最好的两个，最后得到了<code>[ABD],[CED]</code>两个结果。</li></ul><p>可以发现，beam search在每一步需要考察的候选人数量是贪心搜索的num_beams倍，因此相较于贪心算法，是一种牺牲时间换性能的方法。</p><h4 id="集束搜索与维特比算法"><a href="#集束搜索与维特比算法" class="headerlink" title="集束搜索与维特比算法"></a>集束搜索与维特比算法</h4><p>但是<strong>集束搜索依然是一种贪心算法，可以认为是维特比算法的贪心形式</strong>，在维特比搜索中由于利用动态规划导致当字典较大时效率比较低，而集束搜索使用beam size参数来限制在每一步保留下来的可能性词的数量。</p><p>显然集束搜索属于贪心算法，不能保证一定能够找到全局最优解，因为考虑到搜索空间太大，而采用一个相对的较优解。而维特比算法在字典大小较小时能够快速找到全局最优解。</p><hr><p>参考：<a href="https://zhuanlan.zhihu.com/p/114669778" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/114669778</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>维特比算法</title>
      <link href="/2020/03/22/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95/"/>
      <url>/2020/03/22/%E7%BB%B4%E7%89%B9%E6%AF%94%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h3><p>维特比算法是针对篱笆网络的有向图（Lattice）的最短路径而提出的，凡是使用隐马尔可夫模型描述的问题都可以用它来解码。包括数字通信、语音识别、机器翻译、拼音转汉字、分词等。</p><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><p>维特比算法说白了就是用动态规划方法去求解篱笆网络的最短路径。过程非常简单。每当我们走过一个新列时，就需要计算出从开始节点到这一列每个节点的最短路径。巧妙的是，这个计算过程不必从头开始，只需要在上一列节点计算出的最短路径的基础上进行叠加。</p><h3 id="转载别人"><a href="#转载别人" class="headerlink" title="转载别人"></a>转载别人</h3><p>转载知乎一个解释很清楚的答案：</p><p><a href="https://www.zhihu.com/question/20136144/answer/763021768" target="_blank" rel="noopener">https://www.zhihu.com/question/20136144/answer/763021768</a></p><p>为了找出S到E之间的最短路径，我们先从S开始从左到右一列一列地来看。</p><p>首先起点是S，从S到A列的路径有三种可能：S-A1、S-A2、S-A3，如下图：</p><p><a href="https://pic4.zhimg.com/50/v2-facc41878c863acf63d9137df13ef422_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/50/v2-facc41878c863acf63d9137df13ef422_hd.jpg" class="lazyload" title="img"></a><a href="https://pic4.zhimg.com/80/v2-facc41878c863acf63d9137df13ef422_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/80/v2-facc41878c863acf63d9137df13ef422_720w.jpg" class="lazyload" title="img"></a></p><p>​    我们不能武断的说S-A1、S-A2、S-A3中的哪一段必定是全局最短路径中的一部分，目前为止任何一段都有可能是全局最短路径的备选项。</p><p>   我们继续往右看，到了B列。B列的B1、B2、B3逐个分析。</p><p>先看B1：</p><p><a href="https://pic2.zhimg.com/50/v2-ab128a2158510b6885daba65c7de50e0_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/50/v2-ab128a2158510b6885daba65c7de50e0_hd.jpg" class="lazyload" title="img"></a><a href="https://pic2.zhimg.com/80/v2-ab128a2158510b6885daba65c7de50e0_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/80/v2-ab128a2158510b6885daba65c7de50e0_720w.jpg" class="lazyload" title="img"></a></p><p>如上图，经过B1的所有路径只有3条：</p><p>S-A1-B1</p><p>S-A2-B1</p><p>S-A3-B1</p><p>以上这三条路径，我们肯定可以知道其中哪一条是最短的（把各路径每段距离加起来比较一下就知道哪条最短了）。假设S-A3-B1是最短的，那么我们就知道了经过B1的所有路径当中S-A3-B1是最短的，其它两条路径路径S-A1-B1和S-A2-B1都比S-A3-B1长，绝对不是目标答案，可以大胆地删掉了。删掉了不可能是答案的路径，就是viterbi算法（维特比算法）的重点，因为后面我们再也不用考虑这些被删掉的路径了。现在经过B1的所有路径只剩一条路径了，如下图：</p><p><a href="https://pic3.zhimg.com/50/v2-7ddbccbba833ec8158c07c7bd22d56c1_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/50/v2-7ddbccbba833ec8158c07c7bd22d56c1_hd.jpg" class="lazyload" title="img"></a><a href="https://pic3.zhimg.com/80/v2-7ddbccbba833ec8158c07c7bd22d56c1_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/80/v2-7ddbccbba833ec8158c07c7bd22d56c1_720w.jpg" class="lazyload" title="img"></a></p><p>接下来，我们继续看B2：</p><p><a href="https://pic2.zhimg.com/50/v2-4242fc33a113a6507cc963abaf54d4b2_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/50/v2-4242fc33a113a6507cc963abaf54d4b2_hd.jpg" class="lazyload" title="img"></a><a href="https://pic2.zhimg.com/80/v2-4242fc33a113a6507cc963abaf54d4b2_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/80/v2-4242fc33a113a6507cc963abaf54d4b2_720w.jpg" class="lazyload" title="img"></a></p><p>如上图，经过B2的路径有3条：</p><p>S-A1-B2</p><p>S-A2-B2</p><p>S-A3-B2</p><p>这三条路径中我们肯定也可以知道其中哪一条是最短的，假设S-A1-B2是最短的，那么我们就知道了经过B2的所有路径当中S-A1-B2是最短的，其它两条路径路径S-A2-B2和S-A3-B1也可以删掉了。经过B2所有路径只剩一条，如下图：</p><p><a href="https://pic3.zhimg.com/50/v2-47a6e8934348cd21fbb24d57c1e00df9_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/50/v2-47a6e8934348cd21fbb24d57c1e00df9_hd.jpg" class="lazyload" title="img"></a><a href="https://pic3.zhimg.com/80/v2-47a6e8934348cd21fbb24d57c1e00df9_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/80/v2-47a6e8934348cd21fbb24d57c1e00df9_720w.jpg" class="lazyload" title="img"></a></p><p>接下来我们继续看B3：</p><p><a href="https://pic3.zhimg.com/50/v2-c7743eb3724d2a2ee1bbbf1b3859ed60_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/50/v2-c7743eb3724d2a2ee1bbbf1b3859ed60_hd.jpg" class="lazyload" title="img"></a><a href="https://pic3.zhimg.com/80/v2-c7743eb3724d2a2ee1bbbf1b3859ed60_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/80/v2-c7743eb3724d2a2ee1bbbf1b3859ed60_720w.jpg" class="lazyload" title="img"></a></p><p>如上图，经过B3的路径也有3条：</p><p>S-A1-B3</p><p>S-A2-B3</p><p>S-A3-B3</p><p>这三条路径中我们也肯定可以知道其中哪一条是最短的，假设S-A2-B3是最短的，那么我们就知道了经过B3的所有路径当中S-A2-B3是最短的，其它两条路径路径S-A1-B3和S-A3-B3也可以删掉了。经过B3的所有路径只剩一条，如下图：</p><p><a href="https://pic3.zhimg.com/50/v2-917c1c2d0af223d5c4296b16a50fc813_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/50/v2-917c1c2d0af223d5c4296b16a50fc813_hd.jpg" class="lazyload" title="img"></a><a href="https://pic3.zhimg.com/80/v2-917c1c2d0af223d5c4296b16a50fc813_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/80/v2-917c1c2d0af223d5c4296b16a50fc813_720w.jpg" class="lazyload" title="img"></a></p><p>现在对于B列的所有节点我们都过了一遍，B列的每个节点我们都删除了一些不可能是答案的路径，看看我们剩下哪些备选的最短路径，如下图：</p><p><a href="https://pic4.zhimg.com/50/v2-c3b8a2788b84c9fe468437c49a719b60_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/50/v2-c3b8a2788b84c9fe468437c49a719b60_hd.jpg" class="lazyload" title="img"></a><a href="https://pic4.zhimg.com/80/v2-c3b8a2788b84c9fe468437c49a719b60_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/80/v2-c3b8a2788b84c9fe468437c49a719b60_720w.jpg" class="lazyload" title="img"></a></p><p>上图是我们我们删掉了其它不可能是最短路径的情况，留下了三个有可能是最短的路径：S-A3-B1、S-A1-B2、S-A2-B3。现在我们将这三条备选的路径汇总到下图：</p><p><a href="https://pic1.zhimg.com/50/v2-95d27b7061e1345c2942fd5d33b20a81_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic1.zhimg.com/50/v2-95d27b7061e1345c2942fd5d33b20a81_hd.jpg" class="lazyload" title="img"></a><a href="https://pic1.zhimg.com/80/v2-95d27b7061e1345c2942fd5d33b20a81_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic1.zhimg.com/80/v2-95d27b7061e1345c2942fd5d33b20a81_720w.jpg" class="lazyload" title="img"></a></p><p>S-A3-B1、S-A1-B2、S-A2-B3都有可能是全局的最短路径的备选路径，我们还没有足够的信息判断哪一条一定是全局最短路径的子路径。</p><p>   如果我们你认为没毛病就继续往下看C列，如果不理解，回头再看一遍，前面的步骤决定你是否能看懂viterbi算法（维特比算法）。</p><p>​    接下来讲到C列了，类似上面说的B列，我们从C1、C2、C3一个个节点分析。</p><p>经过C1节点的路径有：</p><p>S-A3-B1-C1、</p><p>S-A1-B2-C1、</p><p>S-A2-B3-C1</p><p><a href="https://pic1.zhimg.com/50/v2-8f548ae5a5083cf57f9e4d99bb0e6e22_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic1.zhimg.com/50/v2-8f548ae5a5083cf57f9e4d99bb0e6e22_hd.jpg" class="lazyload" title="img"></a><a href="https://pic1.zhimg.com/80/v2-8f548ae5a5083cf57f9e4d99bb0e6e22_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic1.zhimg.com/80/v2-8f548ae5a5083cf57f9e4d99bb0e6e22_720w.jpg" class="lazyload" title="img"></a></p><p>和B列的做法一样，从这三条路径中找到最短的那条（假定是S-A3-B1-C1），其它两条路径同样道理可以删掉了。那么经过C1的所有路径只剩一条，如下图：</p><p><a href="https://pic3.zhimg.com/50/v2-6b330bf6e276990c69c8231515465cc1_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/50/v2-6b330bf6e276990c69c8231515465cc1_hd.jpg" class="lazyload" title="img"></a><a href="https://pic3.zhimg.com/80/v2-6b330bf6e276990c69c8231515465cc1_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic3.zhimg.com/80/v2-6b330bf6e276990c69c8231515465cc1_720w.jpg" class="lazyload" title="img"></a></p><p>同理，我们可以找到经过C2和C3节点的最短路径，汇总一下：</p><p><a href="https://pic1.zhimg.com/50/v2-925cc071b0f7625a2ba9f523835cb05e_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic1.zhimg.com/50/v2-925cc071b0f7625a2ba9f523835cb05e_hd.jpg" class="lazyload" title="img"></a><a href="https://pic1.zhimg.com/80/v2-925cc071b0f7625a2ba9f523835cb05e_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic1.zhimg.com/80/v2-925cc071b0f7625a2ba9f523835cb05e_720w.jpg" class="lazyload" title="img"></a></p><p>到达C列时最终也只剩3条备选的最短路径，我们仍然没有足够信息断定哪条才是全局最短。</p><p>最后，我们继续看E节点，才能得出最后的结论。</p><p>到E的路径也只有3种可能性：</p><p><a href="https://pic4.zhimg.com/50/v2-7ccbffc5c43f7be1067a5d8dc55a9fd4_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/50/v2-7ccbffc5c43f7be1067a5d8dc55a9fd4_hd.jpg" class="lazyload" title="img"></a><a href="https://pic4.zhimg.com/80/v2-7ccbffc5c43f7be1067a5d8dc55a9fd4_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/80/v2-7ccbffc5c43f7be1067a5d8dc55a9fd4_720w.jpg" class="lazyload" title="img"></a></p><p>E点已经是终点了，我们稍微对比一下这三条路径的总长度就能知道哪条是最短路径了。</p><p><a href="https://pic4.zhimg.com/50/v2-accc8823ff890dd98620f6617e0cfe28_hd.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/50/v2-accc8823ff890dd98620f6617e0cfe28_hd.jpg" class="lazyload" title="img"></a><a href="https://pic4.zhimg.com/80/v2-accc8823ff890dd98620f6617e0cfe28_720w.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic4.zhimg.com/80/v2-accc8823ff890dd98620f6617e0cfe28_720w.jpg" class="lazyload" title="img"></a></p><p>在效率方面相对于粗暴地遍历所有路径，viterbi 维特比算法到达每一列的时候都会删除不符合最短路径要求的路径，大大降低时间复杂度。</p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><p><a href="https://pic2.zhimg.com/v2-1ca20fbcdb4eb205674d2dccc6e11afd_b.jpg" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://pic2.zhimg.com/v2-1ca20fbcdb4eb205674d2dccc6e11afd_b.jpg" class="lazyload" title="img"></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 算法与数据结构 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>隐马尔可夫模型</title>
      <link href="/2020/03/22/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/03/22/%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="隐马尔可夫模型建模"><a href="#隐马尔可夫模型建模" class="headerlink" title="隐马尔可夫模型建模"></a>隐马尔可夫模型建模</h3><p>隐马尔可夫模型（Hidden Markov Model）也就是HMM是一个统计学习模型，描述由隐藏的马尔可夫链随机生成观测序列的过程，属于生成模型。</p><p>上面是比较学术的解释，下面看看我的解释:</p><p>隐马尔可夫模型的意思大概就是：我们现在能看到的东西其实都是表象，它的背后有一个我们看不见的东西一直在变化，这个看不见的东西影响着我们能看到的东西的变化。通常我们要由我们能看到的这个东西去推测我们看不见的东西是怎么在变化的，并且去推测这个看不见的东西怎么影响着我们能看到的东西。</p><p>其中，这个看不见的东西就是<strong>隐含状态</strong> ，能看见的东西就是<strong>可见状态</strong> ，隐含状态之间的变化称为<strong>转换概率</strong> ，隐含状态通过<strong>输出概率</strong> 影响着可见状态。</p><p>隐马尔可夫模型可以说是世界的一种解释，比如说现在模拟一个聊天的场景，就你和你心爱的姑娘聊天吧，聊天过程中，人的心理状态（隐含状态）一直在变化（转换概率），说的话（可见状态）也随着心理状态的变化而变化，在姑娘比较高兴的时候，她让你滚的概率就很小，她生气的时候，就很可能让你滚蛋（输出概率）。隐马尔可夫模型就是对这样的场景的建模。我们要学会从可见状态序列去推测隐含状态序列。</p><p>隐马尔可夫模型可以用下图描述：</p><p><a href="https://camo.githubusercontent.com/b58580c84193b299943ca08a472105ab4d6a47da69ba669162e8edbcc2156e64/68747470733a2f2f696d61676573323031382e636e626c6f67732e636f6d2f626c6f672f313032323835362f3230313830352f313032323835362d32303138303530323130333234383434312d323032363731343334312e706e67" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://camo.githubusercontent.com/b58580c84193b299943ca08a472105ab4d6a47da69ba669162e8edbcc2156e64/68747470733a2f2f696d61676573323031382e636e626c6f67732e636f6d2f626c6f672f313032323835362f3230313830352f313032323835362d32303138303530323130333234383434312d323032363731343334312e706e67" class="lazyload" title="img"></a></p><p> 上图中， $X_1,X_2,X_3 …… X_T$ 是隐含序列，$O_1,O_2 …… O_T$  是观测序列。</p><p><strong>一个隐马尔可夫模型由三个概率确定：</strong></p><ol><li><strong>初始概率分布</strong>，即初始的隐含状态的概率分布，记为π；</li><li><strong>状态转移概率分布</strong>，即隐含状态间的转移概率分布, 记为A；</li><li><strong>观测概率分布</strong>，即由隐含状态生成观测状态的概率分布, 记为B；</li></ol><p>以上的三个概率分布可以说就是隐马尔可夫模型的参数，而根据这三个概率，能够确定一个隐马尔可夫模型$\lambda=(A,B,\pi)$ 。</p><h3 id="隐马尔科夫链的三个基本问题为："><a href="#隐马尔科夫链的三个基本问题为：" class="headerlink" title="隐马尔科夫链的三个基本问题为："></a>隐马尔科夫链的三个基本问题为：</h3><ol><li>给定模型$\lambda=(A,B,\pi)$ ，求$P(O|\lambda)$。</li><li>给定模型$\lambda=(A,B,\pi)$ 和$O$，求最匹配的隐藏状态序列$X$</li><li>给定观测序列$O$，估计模型的参数$λ$, 使得$P(O|\lambda)$最大？</li></ol><p>哎，太抽象了，搞不懂了，以后有时间在搞，详解这几个基本问题。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高斯混合模型</title>
      <link href="/2020/03/22/%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/"/>
      <url>/2020/03/22/%E9%AB%98%E6%96%AF%E6%B7%B7%E5%90%88%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="混合模型（Mixture-Model）"><a href="#混合模型（Mixture-Model）" class="headerlink" title="混合模型（Mixture Model）"></a>混合模型（Mixture Model）</h3><p>由K个子分布组合而成的混合分布。</p><p><a href="https://user-images.githubusercontent.com/36947860/109295632-0921ab00-786a-11eb-8ad6-34c34c7f2dcb.png" data-fancybox="group" data-caption class="fancybox"><img alt data-src="https://user-images.githubusercontent.com/36947860/109295632-0921ab00-786a-11eb-8ad6-34c34c7f2dcb.png" class="lazyload" title></a></p><h3 id="高斯混合模型"><a href="#高斯混合模型" class="headerlink" title="高斯混合模型"></a>高斯混合模型</h3><p>由K个单高斯模型组合而成的模型，由k个高斯模型混合而成的模型并不是一个高斯模型，而是可以拟合任何分布。每个子模型都有未知的 $ \alpha_k$  ,$\mu_k$ ,$\sigma_k$ 。$ \alpha_k$ 是观测数据属于第 k个子模型的概率</p><p>高斯混合模型的概率分布为</p><p>$P(x|\theta)= \sum_{k=1}^K\alpha_i\Phi(x|\theta)$</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JAVA设计模式</title>
      <link href="/2020/03/10/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/03/10/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这23种设计模式算是打开思维，让我知道原来可以这样设计，以为就要具体问题具体分析了。</p><p>设计模式的学习并非一日之功，需要在今后的项目中不断学习，总结经验。</p><p>代码写的烂，没思路的时候时常翻一翻设计模式，寻找灵感。</p><p>纸上得来终觉浅，设计模式更多的是一种经验。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>java设计模式由四人帮提出。</p><p>主要基于两个面向对象设计原则：</p><ul><li>对接口编程而不是对实现编程</li><li>优先使用对象组合而不是继承</li></ul><p>总共有23种设计模式，可以分为三大类：</p><ul><li><p>创建型模式</p><p><strong>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”</strong>。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。就像我们去商场购买商品时，不需要知道商品是怎么生产出来一样，因为它们由专门的厂商生产。</p><p>创建型模式分为以下几种：</p><ul><li>单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。</li><li>原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。</li><li>工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。</li><li>抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。</li><li>建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象。</li></ul></li><li><p>结构性模式</p><p><strong>结构型模式描述如何将类或对象按某种布局组成更大的结构。</strong></p><p>它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p><p>结构型模式分为以下 7 种：</p><ul><li>代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。</li><li>适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</li><li>桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</li><li>装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。</li><li>外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。</li><li>享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。</li><li>组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</li><li>过滤器模式（Filter Pattern）或标准模式（Criteria Pattern）：这种模式允许开发人员使用不同的标准来过滤一组对象，通过逻辑运算以解耦的方式把它们连接起来。它结合多个标准来获得单一标准。</li></ul></li><li><p>行为式模式</p><p><strong>行为型模式用于描述程序在运行时复杂的流程控制，</strong>即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p><p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p><p>行为型模式是 GoF中最为庞大的一类，它包含以下 11 种模式。</p><ul><li><p>模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p></li><li><p>策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。</p></li><li>命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。</li><li>职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。</li><li>状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。</li><li>观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。</li><li>中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。</li><li>迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。</li><li>访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。</li><li>备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。</li><li>解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。</li></ul></li></ul><p>设计模式之间的关系：</p><p><a href="E:\HugoBlog\content\post\images\design_patterns\微信截图_20200310104911.png" data-fancybox="group" data-caption="微信截图_20200310104911" class="fancybox"><img alt="微信截图_20200310104911" data-src="E:\HugoBlog\content\post\images\design_patterns\微信截图_20200310104911.png" class="lazyload" title="微信截图_20200310104911"></a></p><p>设计模式的六大原则：</p><ul><li>开闭原则 ： 对扩展开放，对修改关闭。</li><li>里氏代换原则 ：任何基类出现的地方，子类一定可以出现</li><li>依赖倒转原则 ： 依赖接口编程</li><li>接口隔离原则 ： 使用多个隔离的几口，比使用单个接口好</li><li>最少知道原则  ：实体尽可能少与其他实体发生相互作用</li><li>合成复用原则  ： 尽量使用合成、聚合的方式，而不是使用继承。</li></ul><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><strong>何时使用：</strong>  当不同条件下使用不同的实例时</p><p><strong>使用场景：</strong>  </p><ol><li>日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 </li><li>数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 </li><li>设计一个连接服务器的框架，需要三个协议，”POP3”、”IMAP”、”HTTP”，可以把这三个作为产品类，共同实现一个接口</li></ol><p><strong>实现：</strong></p><p><a href="E:\HugoBlog\content\post\images\design_patterns\微信截图_20200310104643.png" data-fancybox="group" data-caption="微信截图_20200310104643" class="fancybox"><img alt="微信截图_20200310104643" data-src="E:\HugoBlog\content\post\images\design_patterns\微信截图_20200310104643.png" class="lazyload" title="微信截图_20200310104643"></a></p><p><strong>工厂类：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShapeFactory</span> </span>{</span><br><span class="line">    </span><br><span class="line">   <span class="comment">//使用 getShape 方法获取形状类型的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> Shape <span class="title">getShape</span><span class="params">(String shapeType)</span></span>{</span><br><span class="line">      <span class="keyword">if</span>(shapeType == <span class="keyword">null</span>){</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      }        </span><br><span class="line">      <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"CIRCLE"</span>)){</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Circle();</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"RECTANGLE"</span>)){</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Rectangle();</span><br><span class="line">      } <span class="keyword">else</span> <span class="keyword">if</span>(shapeType.equalsIgnoreCase(<span class="string">"SQUARE"</span>)){</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">new</span> Square();</span><br><span class="line">      }</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><p><strong>工厂实现：</strong></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryPatternDemo</span> </span>{</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{</span><br><span class="line">      ShapeFactory shapeFactory = <span class="keyword">new</span> ShapeFactory();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Circle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape1 = shapeFactory.getShape(<span class="string">"CIRCLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Circle 的 draw 方法</span></span><br><span class="line">      shape1.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Rectangle 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape2 = shapeFactory.getShape(<span class="string">"RECTANGLE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Rectangle 的 draw 方法</span></span><br><span class="line">      shape2.draw();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取 Square 的对象，并调用它的 draw 方法</span></span><br><span class="line">      Shape shape3 = shapeFactory.getShape(<span class="string">"SQUARE"</span>);</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//调用 Square 的 draw 方法</span></span><br><span class="line">      shape3.draw();</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>如果要产生一种东西，那么需要一个工厂；要产生另一种东西，我们需要另一个工厂。世界上的东西太多了，我们需要无数个工厂，工厂和工厂其实是差不多的，我们把工厂向上抽象，形成一个工厂的工厂，这就是抽象工厂模式。</p><p><a href="E:\HugoBlog\content\post\images\design_patterns\微信截图_20200310111012.png" data-fancybox="group" data-caption="微信截图_20200310111012" class="fancybox"><img alt="微信截图_20200310111012" data-src="E:\HugoBlog\content\post\images\design_patterns\微信截图_20200310111012.png" class="lazyload" title="微信截图_20200310111012"></a></p><h3 id="详解单例模式"><a href="#详解单例模式" class="headerlink" title="详解单例模式"></a>详解单例模式</h3><p><strong>关键代码：</strong>构造函数是私有的。</p><p><strong>应用实例：</strong></p><ul><li>1、一个班级只有一个班主任。</li><li>2、Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。</li><li>3、一些设备管理器常常设计为单例模式，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。</li></ul><p><strong>意图：</strong>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p><p><strong>主要解决：</strong>一个全局使用的类频繁地创建与销毁。</p><p><a href="E:\HugoBlog\content\post\images\design_patterns\微信截图_20200310112524.png" data-fancybox="group" data-caption="微信截图_20200310112524" class="fancybox"><img alt="微信截图_20200310112524" data-src="E:\HugoBlog\content\post\images\design_patterns\微信截图_20200310112524.png" class="lazyload" title="微信截图_20200310112524"></a></p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleObject</span> </span>{</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//创建 SingleObject 的一个对象</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> SingleObject instance = <span class="keyword">new</span> SingleObject();</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//让构造函数为 private，这样该类就不会被实例化</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">SingleObject</span><span class="params">()</span></span>{}</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleObject <span class="title">getInstance</span><span class="params">()</span></span>{</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">   }</span><br><span class="line"> </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMessage</span><span class="params">()</span></span>{</span><br><span class="line">      System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">   }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure></div><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>object类的clone()方法里面有一个native方法，native方法的效率远高于java的非native方法。</p><p>需要实现一个Cloneable接口，Cloneable接口是不包含任何方法的，只是一个标识接口。</p><p>之所以要这么设计，是因为接口里面是不能写方法实现的，且clone()方法是一个公用的native方法，那么这个方法就只能被放在所以类的父类即Object类中，所以Cloneable接口只能作为一个标识接口</p><h3 id="对比-代理模式、适配器模式、装饰者模式"><a href="#对比-代理模式、适配器模式、装饰者模式" class="headerlink" title="对比 代理模式、适配器模式、装饰者模式"></a>对比 代理模式、适配器模式、装饰者模式</h3><p><strong>代理模式和装饰者模式区别</strong></p><p>当使用代理模式的时候，我们常常在一个代理类中创建一个对象的实例。并且，当我们使用装饰器模式的时候，我们通常的做法是将原始对象作为一个参数传给装饰者的构造器</p><p><strong>代理模式和适配器模式区别</strong></p><p>代理和被代理实现相同的接口</p><p>适配器和被适配实现不同的接口</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式说白了就是一个系统可以从多个角度来分析时，我们选择一个角度以抽象类的继承的方式实现，其他的角度以接口实现的方式实现，然后将接口放入到抽象类中实现组合。</p><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><p>​    • 第一种设计方案是为每一种形状都提供一套各种颜色的版本。</p><p><a href="https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180432090-1967755010.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180432090-1967755010.png" class="lazyload" title="img"></a></p><p>​    • 第二种设计方案是根据实际需要对形状和颜色进行组合。</p><p><a href="https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180443952-1070829097.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180443952-1070829097.png" class="lazyload" title="img"></a></p><p>  对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p><p><strong>模式结构</strong></p><p><a href="https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180526113-1204626425.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://img2018.cnblogs.com/blog/1475571/201901/1475571-20190112180526113-1204626425.png" class="lazyload" title="img"></a></p><p>桥接模式包含如下角色：</p><p>  • <strong>Abstraction</strong>：抽象类</p><p>  • <strong>RefinedAbstraction</strong>：扩充抽象类</p><p>  • <strong>Implementor</strong>：实现类接口</p><p>  • <strong>ConcreteImplementor</strong>：具体实现类</p><p><strong>模式分析</strong></p><p>理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。</p><p>  • 抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</p><p>  • 实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</p><p>   • 脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</p><p>典型的实现类接口代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1 public interface Implementor</span><br><span class="line">2 {</span><br><span class="line">3     public void operationImpl();</span><br><span class="line">4 }</span><br></pre></td></tr></tbody></table></figure></div><p> 典型的抽象类代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> 1 public abstract class Abstraction</span><br><span class="line"> 2 {</span><br><span class="line"> 3     protected Implementor impl;</span><br><span class="line"> 4     </span><br><span class="line"> 5     public void setImpl(Implementor impl)</span><br><span class="line"> 6     {</span><br><span class="line"> 7         this.impl=impl;</span><br><span class="line"> 8     }</span><br><span class="line"> 9     </span><br><span class="line">10     public abstract void operation();</span><br><span class="line">11 }</span><br></pre></td></tr></tbody></table></figure></div><p> 典型的扩充抽象类代码：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">Code</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight plain"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 public class RefinedAbstraction extends Abstraction</span><br><span class="line">2 {</span><br><span class="line">3     public void operation()</span><br><span class="line">4     {</span><br><span class="line">5         //代码</span><br><span class="line">6         impl.operationImpl();</span><br><span class="line">7         //代码</span><br><span class="line">8     }</span><br><span class="line">9 }</span><br></pre></td></tr></tbody></table></figure></div><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式通过共享技术实现相同或相似对象的重用提高系统资源的利用率。</p><p>在享元模式中可以共享的相同内容称为 内部状态(Intrinsic State)，而那些需要外部环境来设置的不能共享的内容称为 外部状态(Extrinsic State)，其中外部状态和内部状态是相互独立的，外部状态的变化不会引起内部状态的变化。由于区分了内部状态和外部状态，因此可以通过设置不同的外部状态使得相同的对象可以具有一些不同的特征，而相同的内部状态是可以共享的。也就是说<strong>，享元模式的本质是分离与共享</strong> ： 分离变与不变，并且共享不变。把一个对象的状态分成内部状态和外部状态，内部状态即是不变的，外部状态是变化的；然后通过共享不变的部分，达到减少对象数量并节约内存的目的。</p><ul><li>内部状态 是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。</li><li>外部状态 是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。</li></ul><p>在享元模式中通常会出现工厂模式，需要创建一个享元工厂来负责维护一个享元池(Flyweight Pool)（用于存储具有相同内部状态的享元对象）。<strong>享元模式的核心在于享元工厂类</strong>，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。　</p><p>参考：<a href="https://blog.csdn.net/justloveyou_/article/details/55045638" target="_blank" rel="noopener">https://blog.csdn.net/justloveyou_/article/details/55045638</a></p><h3 id="过滤器模式"><a href="#过滤器模式" class="headerlink" title="过滤器模式"></a>过滤器模式</h3><p>使用foreach对一个列表进行过滤，不同的过滤器对列表的过滤策略不同</p><h3 id="对比-外观模式和模板模式"><a href="#对比-外观模式和模板模式" class="headerlink" title="对比 外观模式和模板模式"></a>对比 外观模式和模板模式</h3><p>要做某件事情，需要多个类的协作。如果不适用外观模式，那么用户代码将是：串行的一个一个的调用各个类的方法，完成一件事情。这样的过程显然不容易维护，一旦这个步骤需要发生改变，那么就需要修改所有的代码。</p><p>而外观模式，则是，使用一个类将这些动作封装在一个函数中。其实外观模式就是个函数，为了复用而存在的函数。外观模式就是起了一层包装作用。外观模式属于事后模式，一般在接手一个复杂的老系统时，因为内部多个子系统间有非常复杂的耦合关联，为了屏蔽这种“坏味道”对新系统的影响，这时候就建立一个门面，新系统只需要面向这个门面(一系列接口)就可以了。</p><p>模板模式扩展了外观模式，当做同一件事情，但是这件事情中可以细分出来的一个步骤可以有不同实现。模板模式的实现是基于虚函数的重载实现的。外观模式只是封装了各个类的调用。而模板模式则是加了继承，采用多态的方式来实现统一操作的不同实现。</p><p>外观模式实现的是多各类协作共同完成一件事情，因此我们使用一个函数来封装这些操作，（将这个函数放在一个类中）。</p><p>模板模式实现的是一个类的多个函数组合完成一件事情，虽然类的每个函数可能有不同的实现方式，但是流程是一样的。因此使用继承方式，在类中新建一个函数依次调用其他的成员函数。模板模式中将一个大函数拆分为小函数，然后又将小函数封装为一个函数。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者（Observer）模式的定义：指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。这种模式有时又称作发布-订阅模式、模型-视图模式，它是对象行为型模式。</p><p>观察者模式是一种对象行为型模式，其主要优点如下。</p><ul><li><p>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</p></li><li><p>目标与观察者之间建立了一套触发机制。</p></li></ul><p>它的主要缺点如下：</p><ul><li>目标与观察者之间的依赖关系并没有完全解除，而且有可能出现循环引用。</li><li>当观察者对象很多时，通知的发布会花费很多时间，影响程序的效率</li></ul><p>观察者模式的主要角色如下：</p><ol><li>抽象主题：提供了一个观察者列表和对观察者的管理方法和一个抽象的通知方法</li><li>具体主题：实现具体的通知方法(调用 观察者)</li><li>抽象观察者：包含一个抽象的收到通知后的方法</li><li>具体观察者：实现具体的收到通知后的方法。</li></ol><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><p>策略模式就是一个类封装一个算法，实现一个算法接口，然后搞个Context来调用这些算法。</p><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><p>迭代器模式主要包含以下角色。</p><ol><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，<strong>通常包含hasNext()方法，first方法，next()方法。</strong></li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ol><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">java</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight java"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>{</span><br><span class="line">    <span class="function">Object <span class="title">first</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">}</span><br><span class="line"><span class="comment">//具体迭代器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span></span></span><br><span class="line"><span class="class"></span>{ </span><br><span class="line">    <span class="keyword">private</span> List<object> list=<span class="keyword">null</span>; <br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index=-<span class="number">1</span>; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(List<object> list)<br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="keyword">this</span>.list=list; </span><br><span class="line">    } </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        <span class="keyword">if</span>(index<list.size()-<span class="number">1</list.size()-<span></span>)<br><span class="line">        { </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        {</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">first</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{</span><br><span class="line">        index=<span class="number">0</span>;</span><br><span class="line">        Object obj=list.get(index);;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    }</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>{ </span><br><span class="line">        Object obj=<span class="keyword">null</span>; </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.hasNext())</span><br><span class="line">        { </span><br><span class="line">            obj=list.get(++index); </span><br><span class="line">        } </span><br><span class="line">        <span class="keyword">return</span> obj; </span><br><span class="line">    }   </span><br><span class="line">}</span><br></object></span></span></span></object></span></pre></td></tr></tbody></table></figure></div><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><p>在调用者和实现者之间实现命令类，从而实现调用者和实现者的解耦。</p><h3 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h3><p>使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>责任链模式就是链表</p><p>核心代码：在抽象处理者中，调用了当前处理者后，要紧接着调用next。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>GAN</title>
      <link href="/2020/03/01/GAN/"/>
      <url>/2020/03/01/GAN/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="GAN为什么是“生成器-判别器”"><a href="#GAN为什么是“生成器-判别器”" class="headerlink" title="GAN为什么是“生成器+判别器”"></a>GAN为什么是“生成器+判别器”</h2><p>GAN全称是生成式对抗网络。包含一个生成器和一个判别器。</p><p><a href="https://user-images.githubusercontent.com/36947860/76310844-96db5200-630a-11ea-9317-f0283db6a483.png" data-fancybox="group" data-caption="微信截图_20200302121110" class="fancybox"><img alt="微信截图_20200302121110" data-src="https://user-images.githubusercontent.com/36947860/76310844-96db5200-630a-11ea-9317-f0283db6a483.png" class="lazyload" title="微信截图_20200302121110"></a></p><p>下面我们以两个问题作为引导，分析生成器和判别器各自的优缺点，然后阐述将判别器和生成器结合在一起的好处，从而解释为什么GAN是“生成器+判别器”。</p><h3 id="Question-1-：Can-Generator-learn-by-itself？"><a href="#Question-1-：Can-Generator-learn-by-itself？" class="headerlink" title="Question 1 ：Can Generator learn by itself？"></a>Question 1 ：Can Generator learn by itself？</h3><p>要训练Generator，我们可以采用有监督学习的方式，随机生成一些向量，并且为每个图片assign一个向量，之后便可以进行训练。</p><p>这样训练的效果是不好的，因为我们assign给每个图片的向量是随机的，这些向量其实本身并不能很好的表征图像。那么怎么使得向量可以表示图像的特征呢？这就可以用到Auto-Encoder。我们可以训练一个Auto-Encoder，然后把他的解码器部分拿出来，就是一个Generator。</p><p><a href="https://user-images.githubusercontent.com/36947860/76309006-def87580-6306-11ea-9409-72bca20d88b8.png" data-fancybox="group" data-caption="微信截图_20200302120421" class="fancybox"><img alt="微信截图_20200302120421" data-src="https://user-images.githubusercontent.com/36947860/76309006-def87580-6306-11ea-9409-72bca20d88b8.png" class="lazyload" title="微信截图_20200302120421"></a></p><p>但是这样仍然有一个问题，就是对于不是从Auto-Encoder学到的code，Generator生成的效果并不好。</p><p><a href="https://user-images.githubusercontent.com/36947860/76309021-e881dd80-6306-11ea-93a9-b0591894afef.png" data-fancybox="group" data-caption="微信截图_20200302123311" class="fancybox"><img alt="微信截图_20200302123311" data-src="https://user-images.githubusercontent.com/36947860/76309021-e881dd80-6306-11ea-93a9-b0591894afef.png" class="lazyload" title="微信截图_20200302123311"></a></p><p>解决这个问题，可以使用VAE(Variational Auto-Encoder),加噪声后进行训练。</p><p><a href="https://user-images.githubusercontent.com/36947860/76309025-eb7cce00-6306-11ea-9daf-1a9b5fc351c2.png" data-fancybox="group" data-caption="微信截图_20200302123549" class="fancybox"><img alt="微信截图_20200302123549" data-src="https://user-images.githubusercontent.com/36947860/76309025-eb7cce00-6306-11ea-9daf-1a9b5fc351c2.png" class="lazyload" title="微信截图_20200302123549"></a></p><p>这样训练出来的生成器已经很好了，但是我们又有了新的问题：</p><p><a href="https://user-images.githubusercontent.com/36947860/76309033-eddf2800-6306-11ea-9add-225ca0246b7a.png" data-fancybox="group" data-caption="微信截图_20200302123745" class="fancybox"><img alt="微信截图_20200302123745" data-src="https://user-images.githubusercontent.com/36947860/76309033-eddf2800-6306-11ea-9add-225ca0246b7a.png" class="lazyload" title="微信截图_20200302123745"></a></p><p>这样进行训练，机器会以有多少个pixel不同来计算loss，这和我们人的观点是不同的。如上图所示，对于图1和图2，只有一个pixel的不同，我们会认为这样的结果是不ok的，但机器会觉得ok，对于图3和图4，即时有6个pixel的不同，我们也觉得ok。</p><hr><p><strong>从上面的训练过程我们可以观察到生成器的优缺点：</strong></p><p><strong>优点：</strong></p><ul><li>Easy to generate even with deep model。</li></ul><p><strong>缺点：</strong></p><ul><li>Imitate the appearance</li><li>Hard to learn the correlation between components</li></ul><hr><h3 id="Question-2-：Can-Discriminator-generate？"><a href="#Question-2-：Can-Discriminator-generate？" class="headerlink" title="Question 2 ：Can Discriminator generate？"></a>Question 2 ：Can Discriminator generate？</h3><p><a href="https://user-images.githubusercontent.com/36947860/76309051-f6cff980-6306-11ea-8121-66ca49b6c441.png" data-fancybox="group" data-caption="微信截图_20200302125342" class="fancybox"><img alt="微信截图_20200302125342" data-src="https://user-images.githubusercontent.com/36947860/76309051-f6cff980-6306-11ea-8121-66ca49b6c441.png" class="lazyload" title="微信截图_20200302125342"></a></p><ul><li><p>首先我们给定positive examples（with labels)和negative examples(with labels)，然后利用这些数据训练一个判别器，positive examples 就给他高分，negative examples就给他低分。这是很好训练的，就是训练一个做分类的神经网络。</p></li><li><p>之后，我们假设存在这样一个算法，他可以产生使得分类器产生分数最高得图像（比如说，穷举法，穷举所有得图像，丢到判别器中，如果产生得分数最高，就把图片选出来）。$ \widetilde{x}=arg maxD(x)$</p></li><li><p>然后，我们把这个算法得到得图片标记为negative，再次去训练判别器。</p></li><li>如此循环</li></ul><p>可以看到判别器是可以做生成的，只是在training中要产生使得判别器分数最高的图像比较困难。</p><p>判别器还有一个性质：</p><p><a href="https://user-images.githubusercontent.com/36947860/76309065-fafc1700-6306-11ea-85b7-e0ea6e99fe89.png" data-fancybox="group" data-caption="微信截图_20200302131553" class="fancybox"><img alt="微信截图_20200302131553" data-src="https://user-images.githubusercontent.com/36947860/76309065-fafc1700-6306-11ea-85b7-e0ea6e99fe89.png" class="lazyload" title="微信截图_20200302131553"></a></p><hr><p><strong>因此我们可以总结判别器的优缺点</strong></p><p><strong>优点：</strong></p><ul><li>considering the big picture</li></ul><p><strong>缺点：</strong></p><ul><li>Generation is hard</li></ul><hr><h3 id="Generator-Discriminator"><a href="#Generator-Discriminator" class="headerlink" title="Generator+ Discriminator"></a>Generator+ Discriminator</h3><p>从上面的分析我们可以看出，判别器是可以做生成的，但是在training中要设计一个可以产生使得判别器分数最高的图像的算法。<strong>惊喜的是，Generator可以充当这个算法</strong> </p><p><a href="https://user-images.githubusercontent.com/36947860/76309073-ff283480-6306-11ea-9592-d2930b4f915f.png" data-fancybox="group" data-caption="微信截图_20200302131839" class="fancybox"><img alt="微信截图_20200302131839" data-src="https://user-images.githubusercontent.com/36947860/76309073-ff283480-6306-11ea-9592-d2930b4f915f.png" class="lazyload" title="微信截图_20200302131839"></a></p><h3 id="Benefit-of-GAN"><a href="#Benefit-of-GAN" class="headerlink" title="Benefit of GAN"></a>Benefit of GAN</h3><p>从判别器的角度来看，生成器充当了判别器做生成时的最难的算法部分。</p><p>从生成器的角度来看，判别器解决了生成器做生成时没有大局观的痛点。</p><p><a href="https://user-images.githubusercontent.com/36947860/76309078-02bbbb80-6307-11ea-999b-b84b20513dfe.png" data-fancybox="group" data-caption="微信截图_20200302133055" class="fancybox"><img alt="微信截图_20200302133055" data-src="https://user-images.githubusercontent.com/36947860/76309078-02bbbb80-6307-11ea-999b-b84b20513dfe.png" class="lazyload" title="微信截图_20200302133055"></a></p><h2 id="Theory-behind-GAN"><a href="#Theory-behind-GAN" class="headerlink" title="Theory behind GAN"></a>Theory behind GAN</h2><p><a href="https://user-images.githubusercontent.com/36947860/76309085-051e1580-6307-11ea-8cbb-65d6a89e9f8d.png" data-fancybox="group" data-caption="微信截图_20200302155451" class="fancybox"><img alt="微信截图_20200302155451" data-src="https://user-images.githubusercontent.com/36947860/76309085-051e1580-6307-11ea-8cbb-65d6a89e9f8d.png" class="lazyload" title="微信截图_20200302155451"></a></p><ul><li>现在我们有一个假的分布和一个真的分布，我们的目标是最小化两个分布之间的差异。我们可以用KL散度来衡量二者之间的差异，或者其他的散度。</li><li>或者，我们可以用一个函数。理想中这个函数应该可以极大的区分样本之间的差异，才能被当作我们的衡量函数。判别器是这个函数的一部分，是一个需要训练的神经网络，只有判别器训练的足够好，使得这个函数足够好，才能更好的衡量这个差异。</li></ul><p>在最原始的GAN中，这个函数是与JS散度相关的，后续还有其他的(如推土机距离)相关的判别器。</p><p><a href="E:\HugoBlog\content\post\images\GAN\微信截图_20200302165232.png" data-fancybox="group" data-caption="微信截图_20200302165232" class="fancybox"><img alt="微信截图_20200302165232" data-src="E:\HugoBlog\content\post\images\GAN\微信截图_20200302165232.png" class="lazyload" title="微信截图_20200302165232"></a></p><p>解释为何JS散度相关：</p><p><a href="https://user-images.githubusercontent.com/36947860/76310929-c9854a80-630a-11ea-89a4-ae201fe5951b.png" data-fancybox="group" data-caption="img" class="fancybox"><img alt="img" data-src="https://user-images.githubusercontent.com/36947860/76310929-c9854a80-630a-11ea-89a4-ae201fe5951b.png" class="lazyload" title="img"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/76310903-b7a3a780-630a-11ea-9e8a-4005df50661f.png" data-fancybox="group" data-caption="微信截图_20200302170606" class="fancybox"><img alt="微信截图_20200302170606" data-src="https://user-images.githubusercontent.com/36947860/76310903-b7a3a780-630a-11ea-9e8a-4005df50661f.png" class="lazyload" title="微信截图_20200302170606"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/76310918-bf634c00-630a-11ea-813f-d83b7e241081.png" data-fancybox="group" data-caption="微信截图_20200302170614" class="fancybox"><img alt="微信截图_20200302170614" data-src="https://user-images.githubusercontent.com/36947860/76310918-bf634c00-630a-11ea-813f-d83b7e241081.png" class="lazyload" title="微信截图_20200302170614"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/76310923-c2f6d300-630a-11ea-8b77-a481d41e42a3.png" data-fancybox="group" data-caption="微信截图_20200302170621" class="fancybox"><img alt="微信截图_20200302170621" data-src="https://user-images.githubusercontent.com/36947860/76310923-c2f6d300-630a-11ea-8b77-a481d41e42a3.png" class="lazyload" title="微信截图_20200302170621"></a></p><h2 id="GAN的训练："><a href="#GAN的训练：" class="headerlink" title="GAN的训练："></a>GAN的训练：</h2><p>理论上,</p><p><a href="https://user-images.githubusercontent.com/36947860/76308965-ce47ff80-6306-11ea-90ba-93e6ae43a91e.png" data-fancybox="group" data-caption="微信截图_20200302173520" class="fancybox"><img alt="微信截图_20200302173520" data-src="https://user-images.githubusercontent.com/36947860/76308965-ce47ff80-6306-11ea-90ba-93e6ae43a91e.png" class="lazyload" title="微信截图_20200302173520"></a></p><p>实际上，我们无法得到$E<em>{x~P</em>{data}}$ 和$E_{x~P_G}$ ，我们采用如下的方式：</p><p><a href="https://user-images.githubusercontent.com/36947860/76308967-cee09600-6306-11ea-9f8c-b9c4b710f432.png" data-fancybox="group" data-caption="微信截图_20200302173846" class="fancybox"><img alt="微信截图_20200302173846" data-src="https://user-images.githubusercontent.com/36947860/76308967-cee09600-6306-11ea-9f8c-b9c4b710f432.png" class="lazyload" title="微信截图_20200302173846"></a></p><p>这样的话，就可以看作二分类器。</p><p><a href="https://user-images.githubusercontent.com/36947860/76308960-cbe5a580-6306-11ea-9006-25409f9e0c42.png" data-fancybox="group" data-caption="微信截图_20200302173504" class="fancybox"><img alt="微信截图_20200302173504" data-src="https://user-images.githubusercontent.com/36947860/76308960-cbe5a580-6306-11ea-9006-25409f9e0c42.png" class="lazyload" title="微信截图_20200302173504"></a></p><p>所以整个算法流程如下：</p><p><a href="https://user-images.githubusercontent.com/36947860/76308904-b3758b00-6306-11ea-9c35-e678e4483194.png" data-fancybox="group" data-caption="微信截图_20200302170406" class="fancybox"><img alt="微信截图_20200302170406" data-src="https://user-images.githubusercontent.com/36947860/76308904-b3758b00-6306-11ea-9c35-e678e4483194.png" class="lazyload" title="微信截图_20200302170406"></a></p><p>在训练判别器的时候，我们要repeat多次，使得整个判别器足够好。</p><p>而在训练生成器的时候，我们通常是训练一次就够了。</p><p><strong>解释如下：</strong></p><p>$V(G<em>0,D_0^*)$ is the JS divergence between $P</em>{data}(x)$ and $P_{G_0}(x)$</p><p>当我们训练一次生成器，就得到了$G_1$</p><p><a href="https://user-images.githubusercontent.com/36947860/76310727-52e84d00-630a-11ea-861c-ba1549a16fbf.png" data-fancybox="group" data-caption="微信截图_20200302172356" class="fancybox"><img alt="微信截图_20200302172356" data-src="https://user-images.githubusercontent.com/36947860/76310727-52e84d00-630a-11ea-861c-ba1549a16fbf.png" class="lazyload" title="微信截图_20200302172356"></a></p><p>此时，要衡量的应该是 $P<em>{data}(x)$ 和 $P</em>{G_1}(x)$之间的 JS divergence ，但此时使用的损失函数依然是$V(G_0,D_0^*)$ ，所以在$G_0$和$G_1$差别不大的情况下可以多训练几次，一般只训练一次。</p><p>补充知识：</p><p><a href="https://user-images.githubusercontent.com/36947860/76309131-1535f500-6307-11ea-8b50-16f4838c794c.png" data-fancybox="group" data-caption="微信截图_20200302164321" class="fancybox"><img alt="微信截图_20200302164321" data-src="https://user-images.githubusercontent.com/36947860/76309131-1535f500-6307-11ea-8b50-16f4838c794c.png" class="lazyload" title="微信截图_20200302164321"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/76309117-0f401400-6307-11ea-9f44-d80dcdd92267.png" data-fancybox="group" data-caption="微信截图_20200302155535" class="fancybox"><img alt="微信截图_20200302155535" data-src="https://user-images.githubusercontent.com/36947860/76309117-0f401400-6307-11ea-9f44-d80dcdd92267.png" class="lazyload" title="微信截图_20200302155535"></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>万能近似定理(universal approximation theorem )</title>
      <link href="/2020/02/29/%E4%B8%87%E8%83%BD%E8%BF%91%E4%BC%BC%E5%AE%9A%E7%90%86/"/>
      <url>/2020/02/29/%E4%B8%87%E8%83%BD%E8%BF%91%E4%BC%BC%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><p><strong>万能近似定理是深度学习最根本的理论依据</strong>  。In the mathematical theory of artificial neural networks, the <strong><a href="https://en.wikipedia.org/wiki/Universal_approximation_theorem" target="_blank" rel="noopener">universal approximation theorem</a></strong> states that a feed-forward network with a single hidden layer containing a finite number of neurons can approximate continuous functions on compact subsets of <strong>R</strong>, under mild assumptions on the activation function. </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>首先言简意赅的说明，万能近似定理实际是以分段函数的方式来拟合任意函数，类似于微积分的思想。</p><p>阶跃函数：</p><p><a href="https://user-images.githubusercontent.com/36947860/75610431-03589300-5b4c-11ea-9218-9e9ac3f36537.PNG" data-fancybox="group" data-caption="11238071-beb666701a2a2f5a" class="fancybox"><img alt="11238071-beb666701a2a2f5a" data-src="https://user-images.githubusercontent.com/36947860/75610431-03589300-5b4c-11ea-9218-9e9ac3f36537.PNG" class="lazyload" title="11238071-beb666701a2a2f5a"></a></p><p>脉冲函数(sigmoid函数)：</p><p><a href="https://user-images.githubusercontent.com/36947860/75610427-ffc50c00-5b4b-11ea-854d-a53162ce02e3.PNG" data-fancybox="group" data-caption="11238071-124ad906fe7620bc" class="fancybox"><img alt="11238071-124ad906fe7620bc" data-src="https://user-images.githubusercontent.com/36947860/75610427-ffc50c00-5b4b-11ea-854d-a53162ce02e3.PNG" class="lazyload" title="11238071-124ad906fe7620bc"></a></p><p>当我们给激活函数一个参数时，就可以将激活函数看作阶跃函数，比如$ \sigma(t)={1\over1+e^-1000t}$,此时就算给t一个很小的值，$\sigma(t)$也会很接近1，此时$\sigma(t)$就变成以0为阶跃点的阶跃函数，如果再将t根据左加右减原则进行平移，理论上可以得到以任意点为阶跃点的阶跃函数。</p><p>但是此时，我们得到的阶跃函数都是两段的，</p><p><a href="https://user-images.githubusercontent.com/36947860/75610364-862d1e00-5b4b-11ea-8091-fbe1560956dc.png" data-fancybox="group" data-caption="微信截图_20200229232333" class="fancybox"><img alt="微信截图_20200229232333" data-src="https://user-images.githubusercontent.com/36947860/75610364-862d1e00-5b4b-11ea-8091-fbe1560956dc.png" class="lazyload" title="微信截图_20200229232333"></a></p><p>如果要得到一个三段的函数，</p><p><a href="https://user-images.githubusercontent.com/36947860/75610368-8b8a6880-5b4b-11ea-889d-3dfe65bbfe01.png" data-fancybox="group" data-caption="微信截图_20200229232702" class="fancybox"><img alt="微信截图_20200229232702" data-src="https://user-images.githubusercontent.com/36947860/75610368-8b8a6880-5b4b-11ea-889d-3dfe65bbfe01.png" class="lazyload" title="微信截图_20200229232702"></a></p><p>我们需要将不同的阶跃函数进行组合。</p><p><a href="https://user-images.githubusercontent.com/36947860/75610369-8d542c00-5b4b-11ea-95ee-fbd2b584b764.png" data-fancybox="group" data-caption="微信截图_20200229232939" class="fancybox"><img alt="微信截图_20200229232939" data-src="https://user-images.githubusercontent.com/36947860/75610369-8d542c00-5b4b-11ea-95ee-fbd2b584b764.png" class="lazyload" title="微信截图_20200229232939"></a></p><p>所以通过含有一个隐藏层的神经网络，我们可以得到任意分段.</p><p><a href="https://user-images.githubusercontent.com/36947860/75610439-123f4580-5b4c-11ea-93ed-f11b6374924e.PNG" data-fancybox="group" data-caption="11238071-ee9b127d2ba6d742" class="fancybox"><img alt="11238071-ee9b127d2ba6d742" data-src="https://user-images.githubusercontent.com/36947860/75610439-123f4580-5b4c-11ea-93ed-f11b6374924e.PNG" class="lazyload" title="11238071-ee9b127d2ba6d742"></a></p><p>再配合输出层的权值，可以拟合任意函数。</p><p><a href="https://user-images.githubusercontent.com/36947860/75610371-8f1def80-5b4b-11ea-9a23-562d5c9c37ee.png" data-fancybox="group" data-caption="微信截图_20200229232950" class="fancybox"><img alt="微信截图_20200229232950" data-src="https://user-images.githubusercontent.com/36947860/75610371-8f1def80-5b4b-11ea-9a23-562d5c9c37ee.png" class="lazyload" title="微信截图_20200229232950"></a></p><p>同理，使用ReLU做激活函数也可以做到任意精度拟合，从形式上看ReLU也是两段的，他不仅可以表示水平线还可以表示斜线。所以一样能做到任意精度拟合。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>信息熵_交叉熵_相对熵</title>
      <link href="/2020/02/26/%E4%BF%A1%E6%81%AF%E7%86%B5_%E4%BA%A4%E5%8F%89%E7%86%B5_%E7%9B%B8%E5%AF%B9%E7%86%B5/"/>
      <url>/2020/02/26/%E4%BF%A1%E6%81%AF%E7%86%B5_%E4%BA%A4%E5%8F%89%E7%86%B5_%E7%9B%B8%E5%AF%B9%E7%86%B5/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>这篇解释的特别清楚可以看一下：<a href="https://www.zhihu.com/question/41252833/answer/195901726" target="_blank" rel="noopener">https://www.zhihu.com/question/41252833/answer/195901726</a></p><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p><strong>信息熵：</strong> 根据真实分布，我们能够找到一个最优策略，以最小的代价消除系统的不确定性<strong>，</strong>而这个代价大小就是信息熵，记住，信息熵衡量了系统的不确定性，而我们要消除这个不确定性，所要付出的【最小努力】（猜题次数、编码长度等）的大小就是信息熵。</p><p>信息熵代表的是随机变量或整个系统的不确定性，熵越大，随机变量或系统的不确定性就越大</p><p> <a href="https://www.zhihu.com/equation?tex=%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7B1%7D%7Bp_k%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7B1%7D%7Bp_k%7D" class="lazyload" title="[公式]"></a> </p><p><strong>交叉熵：</strong> 其用来衡量在给定的真实分布下，使用非真实分布所指定的策略消除系统的不确定性所需要付出的努力的大小。</p><p>交叉熵的公式为： <a href="https://www.zhihu.com/equation?tex=%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7B1%7D%7Bq_k%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7B1%7D%7Bq_k%7D" class="lazyload" title="[公式]"></a> ，其中 <a href="https://www.zhihu.com/equation?tex=p_k" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=p_k" class="lazyload" title="[公式]"></a> 表示真实分布， <a href="https://www.zhihu.com/equation?tex=q_k" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=q_k" class="lazyload" title="[公式]"></a> 表示非真实分布。</p><p><strong>相对熵(KL散度)</strong>：其用来衡量两个取值为正的函数或概率分布之间的差异，即：</p><p>KL(f(x) || g(x)) = <a href="https://www.zhihu.com/equation?tex=%5Csum_%7B+x+%5Cin+X%7D+f%28x%29+%2A+%5Clog_2+%5Cfrac%7Bf%28x%29%7D%7Bg%28x%29%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Csum_%7B+x+%5Cin+X%7D+f%28x%29+%2A+%5Clog_2+%5Cfrac%7Bf%28x%29%7D%7Bg%28x%29%7D" class="lazyload" title="[公式]"></a></p><p>现在，假设我们想知道某个策略和最优策略之间的差异，我们就可以用相对熵来衡量这两者之间的差异。即，相对熵 = 某个策略的交叉熵 - 信息熵（根据系统真实分布计算而得的信息熵，为最优策略），公式如下：</p><p>KL（p || q） = H（p，q） - H（p） = <a href="https://www.zhihu.com/equation?tex=+%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7B1%7D%7Bq_k%7D+-+%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7B1%7D%7Bp_k%7D+%3D+%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7Bp_k%7D%7Bq_k%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=+%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7B1%7D%7Bq_k%7D+-+%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7B1%7D%7Bp_k%7D+%3D+%5Csum_%7Bk%3D1%7D%5EN+p_k+%5Clog_2+%5Cfrac%7Bp_k%7D%7Bq_k%7D" class="lazyload" title="[公式]"></a></p><h3 id="交叉熵与机器学习"><a href="#交叉熵与机器学习" class="headerlink" title="交叉熵与机器学习"></a>交叉熵与机器学习</h3><p>交叉熵在信息论的定义是：</p><p><a href="https://www.zhihu.com/equation?tex=H%28p%2C+q%29+%3D+H%28p%29+%2B+D_%7BKL%7D%28p+%7C%7C+q%29" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=H%28p%2C+q%29+%3D+H%28p%29+%2B+D_%7BKL%7D%28p+%7C%7C+q%29" class="lazyload" title="[公式]"></a></p><p>在p、q均是离散(discrete)分布时，上式等价为：</p><p><a href="https://www.zhihu.com/equation?tex=H%28p%2C+q%29+%3D+-%5Csum_%7Bi%3D1%7D%5EK+p%28x_i%29+%5Clog+q%28x_i%29" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=H%28p%2C+q%29+%3D+-%5Csum_%7Bi%3D1%7D%5EK+p%28x_i%29+%5Clog+q%28x_i%29" class="lazyload" title="[公式]"></a></p><p><strong>其中， <a href="https://www.zhihu.com/equation?tex=x_i" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=x_i" class="lazyload" title="[公式]"></a> 是 <a href="https://www.zhihu.com/equation?tex=p" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=p" class="lazyload" title="[公式]"></a> 分布、 <a href="https://www.zhihu.com/equation?tex=q" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=q" class="lazyload" title="[公式]"></a> 分布共同的样本空间中的同一个样本点</strong>， 样本空间的大小 <a href="https://www.zhihu.com/equation?tex=K" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=K" class="lazyload" title="[公式]"></a> 。</p><p>机器学习所使用的交叉熵损失函数与信息论里的交叉熵略有不同：</p><ol><li>在机器学习看来，信息论里的交叉熵仅仅是针对一个样本的交叉熵，在机器学习进行优化时，会把所有样本的交叉熵值做一个平均，即机器学习的交叉熵损失函数定义为：假设有N个样本，<a href="https://www.zhihu.com/equation?tex=J%28w%29+%3D+%5Cdfrac%7B1%7D%7BN%7D+%5Csum_%7Bn%3D1%7D+%5EN+H%28p_n%2C+q_n%29" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=J%28w%29+%3D+%5Cdfrac%7B1%7D%7BN%7D+%5Csum_%7Bn%3D1%7D+%5EN+H%28p_n%2C+q_n%29" class="lazyload" title="[公式]"></a></li><li>因为交叉熵常用于解决分类问题，而分类问题(我们一般说分类问题，是指单标签多分类问题)的概率本质是计算类别变量的广义的伯努利分布，所以<strong>机器学习采用的是交叉熵的离散形式</strong>：<a href="https://www.zhihu.com/equation?tex=CE+%3D-+%5Csum_%7Bi%3D1%7D%5EK+t_i+%5Clog+s_i" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=CE+%3D-+%5Csum_%7Bi%3D1%7D%5EK+t_i+%5Clog+s_i" class="lazyload" title="[公式]"></a>。</li></ol><p>其中，<a href="https://www.zhihu.com/equation?tex=t_i" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=t_i" class="lazyload" title="[公式]"></a>是期望的类别标签，<a href="https://www.zhihu.com/equation?tex=s_i" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=s_i" class="lazyload" title="[公式]"></a>是模型对第<a href="https://www.zhihu.com/equation?tex=i" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=i" class="lazyload" title="[公式]"></a>个类别计算得到的<a href="https://www.zhihu.com/equation?tex=score" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=score" class="lazyload" title="[公式]"></a>，通常在计算损失之前，我们会用激活函数( <a href="https://www.zhihu.com/equation?tex=Sigmoid%2C+Softmax" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=Sigmoid%2C+Softmax" class="lazyload" title="[公式]"></a> )对<a href="https://www.zhihu.com/equation?tex=score" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=score" class="lazyload" title="[公式]"></a>加以转换，即我们会用<a href="https://www.zhihu.com/equation?tex=f%28s_i%29" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=f%28s_i%29" class="lazyload" title="[公式]"></a>替代上式的<a href="https://www.zhihu.com/equation?tex=s_i" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=s_i" class="lazyload" title="[公式]"></a>。</p><p>综合以上两点，得到机器学习的交叉熵损失函数：</p><p><a href="https://www.zhihu.com/equation?tex=J%28w%29+%3D+-+%5Cdfrac%7B1%7D%7BN%7D+%5Csum_%7Bn%3D1%7D+%5EN+%5Csum_%7Bi%3D1%7D%5EK+t_i+%5Clog+s_i" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=J%28w%29+%3D+-+%5Cdfrac%7B1%7D%7BN%7D+%5Csum_%7Bn%3D1%7D+%5EN+%5Csum_%7Bi%3D1%7D%5EK+t_i+%5Clog+s_i" class="lazyload" title="[公式]"></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么损失函数越大梯度下降越快？</title>
      <link href="/2020/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E8%B6%8A%E5%A4%A7%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E8%B6%8A%E5%BF%AB%EF%BC%9F/"/>
      <url>/2020/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E8%B6%8A%E5%A4%A7%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E8%B6%8A%E5%BF%AB%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>根据最基础的全连接神经网络，损失函数C是和w相关的，当C越大时，对w的求导就越大，下降就越快。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分类和回归的逻辑统一</title>
      <link href="/2020/02/24/%E5%88%86%E7%B1%BB%E5%92%8C%E5%9B%9E%E5%BD%92%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%9F%E4%B8%80%20/"/>
      <url>/2020/02/24/%E5%88%86%E7%B1%BB%E5%92%8C%E5%9B%9E%E5%BD%92%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%9F%E4%B8%80%20/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>分类和回归是机器学习的两种模型，但在某种程度上又是逻辑统一的。</p><h3 id="二分类和回归的统一——-sigma"><a href="#二分类和回归的统一——-sigma" class="headerlink" title="二分类和回归的统一——$\sigma()$"></a>二分类和回归的统一——$\sigma()$</h3><p>下面我们从贝叶斯分类器的角度将二分类和回归联系起来。</p><p><a href="https://user-images.githubusercontent.com/36947860/75307991-2b17d480-5888-11ea-8ede-9ca05ff4ab33.png" data-fancybox="group" data-caption="微信截图_20200224221524" class="fancybox"><img alt="微信截图_20200224221524" data-src="https://user-images.githubusercontent.com/36947860/75307991-2b17d480-5888-11ea-8ede-9ca05ff4ab33.png" class="lazyload" title="微信截图_20200224221524"></a></p><p>首先介绍一下贝叶斯分类器，<strong>贝叶斯分类遵循基本的三步骤</strong>。</p><ol><li>选择model，贝叶斯中当然选择的是贝叶斯分类器作为model</li><li>定义损失函数，分类问题的损失函数是极大似然估计(作者其他博文有讲)，在做极大似然估计时，我们首先要选择一个输出可能的分布，一般选择高斯分布，那这个时候就有人要问了，为什么是高斯分布呢？其实不管怎么样它总要有个分布，这个是人为选择的，也可以选择别的分布。选好分布后，就用极大似然法估计分布的参数。</li><li>选择最好的函数。</li></ol><hr><p>下面的推导过程展示了<strong>如何将二元高斯分布下的贝叶斯分类器转换为回归问题</strong>。</p><p><a href="https://user-images.githubusercontent.com/36947860/75308087-6ca87f80-5888-11ea-81ee-b4e545853d5f.png" data-fancybox="group" data-caption="微信截图_20200226105355" class="fancybox"><img alt="微信截图_20200226105355" data-src="https://user-images.githubusercontent.com/36947860/75308087-6ca87f80-5888-11ea-81ee-b4e545853d5f.png" class="lazyload" title="微信截图_20200226105355"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/75308094-70d49d00-5888-11ea-9351-e97398b92c40.png" data-fancybox="group" data-caption="微信截图_20200226105439" class="fancybox"><img alt="微信截图_20200226105439" data-src="https://user-images.githubusercontent.com/36947860/75308094-70d49d00-5888-11ea-9351-e97398b92c40.png" class="lazyload" title="微信截图_20200226105439"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/75308068-60bcbd80-5888-11ea-8280-904a2cef42c7.png" data-fancybox="group" data-caption="微信截图_20200226105502" class="fancybox"><img alt="微信截图_20200226105502" data-src="https://user-images.githubusercontent.com/36947860/75308068-60bcbd80-5888-11ea-8280-904a2cef42c7.png" class="lazyload" title="微信截图_20200226105502"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/75308079-66b29e80-5888-11ea-8c4b-a1ee2789e5b0.png" data-fancybox="group" data-caption="微信截图_20200226105529" class="fancybox"><img alt="微信截图_20200226105529" data-src="https://user-images.githubusercontent.com/36947860/75308079-66b29e80-5888-11ea-8c4b-a1ee2789e5b0.png" class="lazyload" title="微信截图_20200226105529"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/75308083-69ad8f00-5888-11ea-8531-9cd32af17b1d.png" data-fancybox="group" data-caption="微信截图_20200226105626" class="fancybox"><img alt="微信截图_20200226105626" data-src="https://user-images.githubusercontent.com/36947860/75308083-69ad8f00-5888-11ea-8531-9cd32af17b1d.png" class="lazyload" title="微信截图_20200226105626"></a></p><p>通过推导可以看出，分类问题和回归问题是统一的，我们不必再通过计算$\mu_1$,$\mu_2$,$\Sigma _1 $,$\Sigma_2$,$N_1$,$N_2$来计算概率，而可以通过DeepLearning的手段直接计算w和b，从而求得概率，而与线性回归不同的是，我们需要将输出结果用$\sigma()$函数转化到0~1之间，这就是<strong>逻辑回归</strong>。</p><h3 id="多分类和回归的统一——-Softmax"><a href="#多分类和回归的统一——-Softmax" class="headerlink" title="多分类和回归的统一—— $Softmax()$"></a>多分类和回归的统一—— $Softmax()$</h3><p>以上介绍的是二元分类和回归的关系，如果要将多分类问题和回归联系起来，那就要用到softmax，softmax能处理分类问题的原理和以上类似，不做原理分析和推导，直接用就可以了。</p><p>公式如下：</p><script type="math/tex; mode=display">S_i= {e_i\over \sum_j e^j}</script><p>图解：</p><p><a href="https://user-images.githubusercontent.com/36947860/75311806-e47ba780-5892-11ea-8245-1358b63a38dd.png" data-fancybox="group" data-caption="微信截图_20200226120956" class="fancybox"><img alt="微信截图_20200226120956" data-src="https://user-images.githubusercontent.com/36947860/75311806-e47ba780-5892-11ea-8245-1358b63a38dd.png" class="lazyload" title="微信截图_20200226120956"></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>多分类的两种方式</title>
      <link href="/2020/02/24/%E5%A4%9A%E5%88%86%E7%B1%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
      <url>/2020/02/24/%E5%A4%9A%E5%88%86%E7%B1%BB%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="多分类的两种方式"><a href="#多分类的两种方式" class="headerlink" title="多分类的两种方式"></a>多分类的两种方式</h3><ul><li><p>K个独立的二元分类器——用于不互斥的分类</p></li><li><p>softmax——用于互斥的分类</p></li></ul><p><strong>softmax VS k个二元分类器</strong></p><p>如果你在开发一个音乐分类的应用，需要对k种类型的音乐进行识别，那么是选择使用 softmax 分类器呢，还是使用 logistic 回归算法建立 k 个独立的二元分类器呢？<br>这一选择取决于你的类别之间是否互斥，例如，如果你有四个类别的音乐，分别为：古典音乐、乡村音乐、摇滚乐和爵士乐，那么你可以假设每个训练样本只会被打上一个标签（即：一首歌只能属于这四种音乐类型的其中一种），此时你应该使用类别数 k = 4 的softmax回归。（如果在你的数据集中，有的歌曲不属于以上四类的其中任何一类，那么你可以添加一个“其他类”，并将类别数 k 设为5。）<br>如果你的四个类别如下：人声音乐、舞曲、影视原声、流行歌曲，那么这些类别之间并不是互斥的。例如：一首歌曲可以来源于影视原声，同时也包含人声 。这种情况下，使用4个二分类的 logistic 回归分类器更为合适。这样，对于每个新的音乐作品 ，我们的算法可以分别判断它是否属于各个类别。<br>现在我们来看一个计算视觉领域的例子，你的任务是将图像分到三个不同类别中。(i) 假设这三个类别分别是：室内场景、户外城区场景、户外荒野场景。你会使用sofmax回归还是 3个logistic 回归分类器呢？ (ii) 现在假设这三个类别分别是室内场景、黑白图片、包含人物的图片，你又会选择 softmax 回归还是多个 logistic 回归分类器呢？<br>在第一个例子中，三个类别是互斥的，因此更适于选择softmax回归分类器 。而在第二个例子中，建立三个独立的 logistic回归分类器更加合适。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>为什么采用交叉熵做为逻辑回归的损失函数</title>
      <link href="/2020/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E4%BA%A4%E5%8F%89%E7%86%B5%E5%81%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/"/>
      <url>/2020/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%87%E7%94%A8%E4%BA%A4%E5%8F%89%E7%86%B5%E5%81%9A%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="为什么逻辑回归要用交叉熵作为损失函数？"><a href="#为什么逻辑回归要用交叉熵作为损失函数？" class="headerlink" title="为什么逻辑回归要用交叉熵作为损失函数？"></a>为什么逻辑回归要用交叉熵作为损失函数？</h3><p>当使用交叉熵作为损失函数时，对于二分类问题，求导可以消去$\sigma()$函数，对于softmax，求导可以消去exp，这样直观上对w的求导变得更加简单，当对w的求导变得简单时，梯度下降法才可以更好的work，否则会出现各种诸如梯度弥散，梯度爆炸等问题。</p><h4 id="二分类中交叉熵做损失函数的推导："><a href="#二分类中交叉熵做损失函数的推导：" class="headerlink" title="二分类中交叉熵做损失函数的推导："></a>二分类中交叉熵做损失函数的推导：</h4><p>假设$a=\sigma(z),z=wx+b$,y为真实分布。</p><p>用链式求导法</p><p>${\partial C \over \partial w}={\partial C \over \partial a}*{\partial a \over \partial w}$</p><p>${\partial C \over \partial a}={(z(y-a)*(-1)) \over 2}=a-y$</p><p>${\partial a \over \partial w}={\sigma’(z)*dz \over dw}=\sigma’(z)x$</p><p>${\partial C \over \partial w}={\partial C \over \partial a}*\sigma ‘(z)x$</p><p>如果我们将$\sigma’(z)$消去，求导就会简单很多，</p><p>而$\sigma ‘(z)=\sigma (z)(1-\sigma ‘(z)) =1-a$,</p><p>所以，带有$\sigma’(z)$的求导公式为${\partial C \over \partial w}={\partial C \over \partial a}*(1-a)x$,</p><p>去掉$\sigma’(z)$的求导公式为${\partial C \over \partial w}=(a-y)x$</p><p>令两式相等得${\partial C \over \partial a}*(1-a)x=(a-y)x$,</p><p>解得$C=-[y\ln a+(1-y)\ln (1-a)]+constant$,</p><p>这是单个训练示例对代价函数的贡献。为了得到完整的代价函数，需要对训练实例进行平均，得到</p><p>$C=-{1\over n}\sum_x[y\ln a+(1-y)\ln (1-a)]+constant$,</p><p>所以，用交叉熵做损失函数可以使得求导更加简单。</p><p><strong>参考：</strong></p><p><a href="https://www.cnblogs.com/xhslovecx/p/10858646.html" target="_blank" rel="noopener">https://www.cnblogs.com/xhslovecx/p/10858646.html</a></p><hr><h4 id="softmax中交叉熵做损失函数的推导"><a href="#softmax中交叉熵做损失函数的推导" class="headerlink" title="softmax中交叉熵做损失函数的推导"></a>softmax中交叉熵做损失函数的推导</h4><p>在多分类问题中，我们经常使用交叉熵作为损失函数</p><p>$Loss=-\sum_{i}t_ilny_i$</p><p>其中，$t_i$表示真实值，$y_i$表示求出的softmax值。当预测第i个时，可以认为$t_i=1$.此时损失函数变成了：</p><p>$Loss_i=-lny_i$</p><p>接下来对Loss求导。根据定义：</p><p>$y_i={e^i\over\sum_je^j}$</p><p>且</p><p>${e^i\over\sum<em>je^j}=1-{\sum</em>{j\not=i}ej\over\sum_je^j}$</p><p>接下来开始求导：</p><p>$ \frac{\partial  Loss_i}{\partial _i}=-\frac{\partial ln y_i}{\partial _i} $</p><p>$ = \frac{\partial (-ln \frac{e^i}{\sum_j e^j}) }{\partial _i}  $</p><p>$ = - \frac {1}{ \frac{e^i}{\sum_j e^j}} \cdot \frac{\partial (\frac{e^i}{\sum_j e^j})}{ \partial_i} $</p><p>$ = -\frac{\sum<em>j e^j}{e^i} \cdot \frac{\partial (1 - \frac{\sum</em>{j \neq i} e^j}{\sum_j e^j}) } {\partial_i} $</p><p>对$i$求导，$(- \sum _ {j \neq i}e^j )$为常数</p><p>$ = -\frac{\sum<em>j e^j}{e^i} \cdot (- \sum </em> {j \neq i}e^j ) \cdot \frac{\partial( \frac {1} {\sum_j e^j} ) } { \partial _i} $</p><p>$=\frac { \sum<em>j e^j \cdot \sum</em>{j \neq i} e^j}  {e^i } \cdot \frac { - e^i} { (\sum_j e^j) ^ 2} $</p><p>分数求导法则</p><p>$= -\frac { \sum_{j \neq i} e^j } { \sum_j e^j }  $</p><p>$ = -(1 - \frac{ e ^ i } { \sum_j e^j } ) $</p><p>$= y_i - 1 $</p><p>上面的结果表示，我们只需要正想求出$y_i$，将结果减1就是反向更新的梯度，导数的计算是不是非常简单！</p><p><strong>参考：</strong></p><p><a href="https://blog.csdn.net/bitcarmanlee/article/details/82320853" target="_blank" rel="noopener">https://blog.csdn.net/bitcarmanlee/article/details/82320853</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 交叉熵 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>似然函数和极大似然估计</title>
      <link href="/2020/02/24/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/"/>
      <url>/2020/02/24/%E4%BC%BC%E7%84%B6%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%81%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h3 id="概率和似然"><a href="#概率和似然" class="headerlink" title="概率和似然"></a>概率和似然</h3><p>已知一个分布的参数，就可以根据这个分布去推测产生各种情况的可能性，我们称之为<strong>概率</strong></p><p>已知一个分布的各种可能的情况，就可以根据这些情况去推测分布的参数，我们称之为<strong>似然（似然度）</strong>。</p><hr><h3 id="似然函数"><a href="#似然函数" class="headerlink" title="似然函数"></a>似然函数</h3><p>假设我们现在猜测这个参数为θ，那么评价我们猜的准不准就要计算它的似然度</p><script type="math/tex; mode=display">L(θ|x)=P(X=x|θ)</script><p>似然度$L(θ|x)$在数值上等于给定参数θ后变量X的概率。</p><p>而这个公式我们称之为似然（度）函数。</p><hr><h3 id="极大似然估计-Maximum-Likelihood"><a href="#极大似然估计-Maximum-Likelihood" class="headerlink" title="极大似然估计(Maximum Likelihood)"></a>极大似然估计(Maximum Likelihood)</h3><p>一般我们要求得当<strong>似然度</strong>$L(θ|x)$最大时的$\theta$,这就是极大似然估计。</p><hr><h3 id="Maximum-Log-Likelihood"><a href="#Maximum-Log-Likelihood" class="headerlink" title="Maximum Log-Likelihood"></a>Maximum Log-Likelihood</h3><p>由于每个点发生的概率都很小，乘积会变得极其小，不利于计算和观察，因此通常我们用 Maximum Log-Likelihood 来计算。</p><ul><li>因为 Log 函数具备单调性，不会改变极值的位置</li><li>同时在 0-1 之间输入值很小的变化可以引起输出值相对较大的变动</li></ul><hr><h3 id="作者的困惑"><a href="#作者的困惑" class="headerlink" title="作者的困惑"></a>作者的困惑</h3><p>作者对这个概念理解不清晰的原因在于教科书上这个名字起得不好，应该叫<strong>似然度</strong>更加清晰一些。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么神经网络中参数的初始化要接近0？</title>
      <link href="/2020/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A6%81%E6%8E%A5%E8%BF%910%EF%BC%9F/"/>
      <url>/2020/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%8F%82%E6%95%B0%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96%E8%A6%81%E6%8E%A5%E8%BF%910%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>当参数初始化接近0时，整个函数的斜率比较小，函数较为平滑。函数平滑的好处如下：</p><p>以$y=wx+b$为例，如果$w$比较大，即时$x_1$和$x_2$相差很小的$\Delta x$,他们的$y$值也会相差很大，这是不符合直觉的，所以应该将$w$初始化比较小的值。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么样本方差要除以n-1？</title>
      <link href="/2020/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%B7%E6%9C%AC%E6%96%B9%E5%B7%AE%E8%A6%81%E9%99%A4%E4%BB%A5n-1%EF%BC%9F/"/>
      <url>/2020/02/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%B7%E6%9C%AC%E6%96%B9%E5%B7%AE%E8%A6%81%E9%99%A4%E4%BB%A5n-1%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p><em>版权声明：本文为CSDN博主「Hearthougan」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。</em><br><em>原文链接：<a href="https://blog.csdn.net/Hearthougan/article/details/77859173" target="_blank" rel="noopener">https://blog.csdn.net/Hearthougan/article/details/77859173</a></em></p><p><em>转载作为学习笔记</em></p><hr><p>设样本均值为$\overline{X}$，样本方差为$S^2$，总体均值为$\mu$，总体方差为$\sigma^2$，那么样本方差有如下公式：</p><p><a href="https://user-images.githubusercontent.com/36947860/75150338-209df380-573f-11ea-932e-b855ccf897bd.png" data-fancybox="group" data-caption="20170905232955708" class="fancybox"><img alt="20170905232955708" data-src="https://user-images.githubusercontent.com/36947860/75150338-209df380-573f-11ea-932e-b855ccf897bd.png" class="lazyload" title="20170905232955708"></a></p><p>很多人可能都会有疑问，为什么要除以$n-1$，而不是$n$，但是翻阅资料，发现很多都是交代到，如果除以$n$，对样本方差的估计不是无偏估计，比总体方差要小，要想是无偏估计就要调小分母，所以除以$n-1$，那么问题来了，为什么不是除以$n-2$、$n-3$等等。所以在这里彻底总结一下，首先交代一下无偏估计。</p><p><strong>无偏估计</strong></p><p>以例子来说明，假如你想知道一所大学里学生的平均身高是多少，一个大学好几万人，全部统计有点不现实，但是你可以先随机挑选100个人，统计他们的身高，然后计算出他们的平均值，记为$\overline X_1$。如果你只是把$\overline X_1$作为整体的身高平均值，误差肯定很大，因为你再随机挑选出100个人，身高平均值很可能就跟刚才计算的不同，为了使得统计结果更加精确，你需要多抽取几次，然后分别计算出他们的平均值，分别记为：$\overline X_1<script type="math/tex">\overline X_2</script>\overline X_3$$\overline X_k$,然后在把这些平均值，再做平均，记为：$E(\overline X)$，这样的结果肯定比只计算一次更加精确，随着重复抽取的次数增多，这个期望值会越来越接近总体均值$\mu$，如果满足$E(\overline X)=\mu$，这就是一个无偏估计，其中统计的样本均值也是一个随机变量，$\overline X_i$就是$\overline X$的一个取值。<strong>无偏估计的意义是：在多次重复下，它们的平均数接近所估计的参数真值。</strong></p><p>介绍无偏估计的意义就是，我们计算的样本方差，希望它是总体方差的一个无偏估计，那么假如我们的样本方差是如下形式：</p><p><a href="https://user-images.githubusercontent.com/36947860/75150340-2398e400-573f-11ea-85bb-2ae50858ac51.png" data-fancybox="group" data-caption="20170905233050202" class="fancybox"><img alt="20170905233050202" data-src="https://user-images.githubusercontent.com/36947860/75150340-2398e400-573f-11ea-85bb-2ae50858ac51.png" class="lazyload" title="20170905233050202"></a></p><p>那么，我们根据无偏估计的定义可得：</p><p><a href="https://user-images.githubusercontent.com/36947860/75150344-24317a80-573f-11ea-92be-54db191fe789.png" data-fancybox="group" data-caption="20170905233442186" class="fancybox"><img alt="20170905233442186" data-src="https://user-images.githubusercontent.com/36947860/75150344-24317a80-573f-11ea-92be-54db191fe789.png" class="lazyload" title="20170905233442186"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/75150348-24ca1100-573f-11ea-8132-b540e97a1332.png" data-fancybox="group" data-caption="20170905233618683" class="fancybox"><img alt="20170905233618683" data-src="https://user-images.githubusercontent.com/36947860/75150348-24ca1100-573f-11ea-8132-b540e97a1332.png" class="lazyload" title="20170905233618683"></a></p><p>由上式可以看出如果除以$n$，那么样本方差比总体方差的值偏小，那么该怎么修正，使得样本方差式总体方差的无偏估计呢？我们接着上式继续化简（其中Var()函数代表求方差variance）：</p><p><a href="https://user-images.githubusercontent.com/36947860/75150349-2562a780-573f-11ea-9626-3f52540a7dce.png" data-fancybox="group" data-caption="20170905235049219" class="fancybox"><img alt="20170905235049219" data-src="https://user-images.githubusercontent.com/36947860/75150349-2562a780-573f-11ea-9626-3f52540a7dce.png" class="lazyload" title="20170905235049219"></a></p><p>到这里得到如下式子，看到了什么？该怎修正似乎有点眉目。</p><p><a href="https://user-images.githubusercontent.com/36947860/75150354-25fb3e00-573f-11ea-927c-083ef4e5a9f4.png" data-fancybox="group" data-caption="20170905235354241" class="fancybox"><img alt="20170905235354241" data-src="https://user-images.githubusercontent.com/36947860/75150354-25fb3e00-573f-11ea-927c-083ef4e5a9f4.png" class="lazyload" title="20170905235354241"></a></p><p>如果让我们假设的样本方差$S^2$乘以$n\over n-1$，即修正成如下形式，是不是可以得到样本方差是总体方差$ \sigma^2$的无偏估计呢？</p><p><a href="https://user-images.githubusercontent.com/36947860/75150360-27c50180-573f-11ea-8130-4322817d0000.png" data-fancybox="group" data-caption="20170906000129602" class="fancybox"><img alt="20170906000129602" data-src="https://user-images.githubusercontent.com/36947860/75150360-27c50180-573f-11ea-8130-4322817d0000.png" class="lazyload" title="20170906000129602"></a></p><p>则：</p><p><a href="https://user-images.githubusercontent.com/36947860/75150362-285d9800-573f-11ea-9c97-c97eba3cd706.png" data-fancybox="group" data-caption="20170906000513463" class="fancybox"><img alt="20170906000513463" data-src="https://user-images.githubusercontent.com/36947860/75150362-285d9800-573f-11ea-9c97-c97eba3cd706.png" class="lazyload" title="20170906000513463"></a></p><p>因此修正之后的样本方差的期望是总体方差的一个无偏估计，这就是为什么分母为何要除以n-1。</p><hr><p><strong>计算方差的三个公式</strong></p><ul><li>$ \sigma ^2 =E[(X-\mu)^2]$</li><li>$ S ^2 ={1\over n}\sum_{i=1}^n(X_i-\mu)^2$</li><li>$ S ^2 ={1\over n-1}\sum_{i=1}^n(X_i-\overline X)^2$</li></ul><p>因为$\overline X$是由$X_i$计算出来的，所以$(X_i-\overline X)$显然会小于$(X_i-\mu)^2$，所以要除以较小的数。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>从PCA到Auto Encoder</title>
      <link href="/2020/02/23/%E4%BB%8EPCA%E5%88%B0Auto-encoder/"/>
      <url>/2020/02/23/%E4%BB%8EPCA%E5%88%B0Auto-encoder/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h2><p>PCA意为主成分分析，PCA降维就是分析主成分，然后再降维。</p><p><strong>Q：</strong>那么降维的时候，为什么要分析主成分呢？</p><p><strong>A：</strong>我们在做降维时，可以将当前的样本点投影到任意的向量空间，那么怎么投影才是最好的呢，一般我们认为投影之后的样本点越分散，也就是方差越大，则投影越好，所以我们选择是的样本点方差最大的维度进行投影，这个过程就是主成分分析。</p><p>具体的计算过程是线性代数知识，可以看这个视频<a href="https://www.bilibili.com/video/av29441413?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/av29441413?p=3</a></p><h2 id="Autoencoder"><a href="#Autoencoder" class="headerlink" title="Autoencoder"></a>Autoencoder</h2><p>PCA looks like a neural network with one hidden layer(linear activation function)，用神经网络的做法去做PCA，这就是自编码器。</p><p>为什么说PCA是神经网络呢？</p><p>PCA的运算过程概括起来可以是z=Wx，我们把x看作网络的输入，w作为网络的参数，z作为网络的输出，就可以把PCA看做神经网络。此时我们可以称这个网络为自编码器，那么怎么去训练自编码器呢，我们知道W是orthonormal(标准正交的)，所以同时有x=Wz(线性代数知识)。如果我们搭一个两层的网络，即（x输入，W，z，W，x输出），就可以算x输入和x输出之间的loss，就可以根据反向传播来训练了。</p><p>自编码器训练出来的W和通过PCA计算出来的W是不同的。在只有一层线性映射的时候我们可以用PCA直接算出结果，但自编码器的好处是可以处理多层网络和非线性的激活函数。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Autoencoder </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GRU</title>
      <link href="/2020/02/23/GRU/"/>
      <url>/2020/02/23/GRU/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>GRU全称是Gate Recurrent Unit，也是LSTM的一个变种，它较LSTM网络的结构更加简单，而且效果也很好，因此也是当前非常流形的一种网络。</p><p><a href="https://user-images.githubusercontent.com/36947860/75111815-e2d69780-5678-11ea-897b-94a155aebb7b.jpg" data-fancybox="group" data-caption="v2-8134a00c243153bfd9fd2bcbe0844e9c_1200x500" class="fancybox"><img alt="v2-8134a00c243153bfd9fd2bcbe0844e9c_1200x500" style="zoom:80%;" data-src="https://user-images.githubusercontent.com/36947860/75111815-e2d69780-5678-11ea-897b-94a155aebb7b.jpg" class="lazyload" title="v2-8134a00c243153bfd9fd2bcbe0844e9c_1200x500"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/75111802-c3d80580-5678-11ea-816c-9e9f2eca7c5a.png" data-fancybox="group" data-caption="1335117-20180727095108158-462781335" class="fancybox"><img alt="1335117-20180727095108158-462781335" data-src="https://user-images.githubusercontent.com/36947860/75111802-c3d80580-5678-11ea-816c-9e9f2eca7c5a.png" class="lazyload" title="1335117-20180727095108158-462781335"></a></p><p>根据这两个图描述的<strong>前向传播公式</strong>如下:</p><p><a href="https://user-images.githubusercontent.com/36947860/75111807-d18d8b00-5678-11ea-91ab-06dfc807926a.png" data-fancybox="group" data-caption="微信截图_20200223184933" class="fancybox"><img alt="微信截图_20200223184933" data-src="https://user-images.githubusercontent.com/36947860/75111807-d18d8b00-5678-11ea-91ab-06dfc807926a.png" class="lazyload" title="微信截图_20200223184933"></a></p><p><strong>文字描述</strong>：</p><ul><li><p>首先将上次的隐藏层状态(长期记忆)和输入x串接起来，乘上不同的参数矩阵，再通过σ激活函数形成重置门和更新门</p></li><li><p>将上次隐藏层的状态(长期记忆)通过重置门重置后，与输入x串接起来，乘上参数矩阵，再通过tanh激活函数形成临时记忆</p></li><li>通过更新门，对长期记忆进行选择性遗忘，同时将临时记忆选择性更新到长期记忆中</li></ul><p><strong>GRU与LSTM类比：</strong></p><ul><li><p>GRU用一个更新门实现了类似LSTM中遗忘门和输入门两个门的功能，而LSTM中的输出门的功能，则用GRU中的重置门实现。</p></li><li><p>在GRU中，隐藏层状态就是长期记忆，而将长期记忆通过重置门后与这次的输入串接，我们认为包含较多的本次记忆信息，而包含较少的长期记忆信息。在LSTM中也有类似的操作，都将隐藏层状态与输入串接来代表本次的输入，只是具体的实现不同。</p></li><li><p>GRU把旧知识的遗忘和新知识的记忆联动起来，有多大程度的长期记忆的遗忘，就有多大程度的临时记忆的加入。而LSTM中遗忘和记忆的过程是分开的。</p></li></ul><h2 id="作者的疑惑——求解释"><a href="#作者的疑惑——求解释" class="headerlink" title="作者的疑惑——求解释"></a>作者的疑惑——求解释</h2><p><strong>关于为什么LSTM和GRU都要把输入的信息和上次的隐藏层状态串接，本人也没有得到专业的解释。</strong>对此，本人的猜测是，把他们串接起来就可以计算之前步和当前步的相关性，之后乘以矩阵变换维度，再乘以激活函数映射到一定的数值范围内，这时候就可以根据之前步和当前步的相关性进行遗忘和更新以及输出。从这个角度来说，LSTM和GRU都很简单，都是通过串接之后再计算相关性来实现门控，再通过这个门控控制记忆和遗忘</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GRU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tips_for_training_DNN</title>
      <link href="/2020/02/22/Tips_for_training_DNN/"/>
      <url>/2020/02/22/Tips_for_training_DNN/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="训练误差的来源"><a href="#训练误差的来源" class="headerlink" title="训练误差的来源"></a>训练误差的来源</h2><p><strong><em>where does the error come from？</em></strong></p><p><strong><em>Error comes  from bias and variance.</em></strong> </p><p><a href="https://user-images.githubusercontent.com/36947860/74907655-d0e1c400-53ee-11ea-982f-718ade42924a.jpg" data-fancybox="group" data-caption="1581745412(1)" class="fancybox"><img alt="1581745412(1)" data-src="https://user-images.githubusercontent.com/36947860/74907655-d0e1c400-53ee-11ea-982f-718ade42924a.jpg" class="lazyload" title="1581745412(1)"></a></p><div class="table-container"><table><thead><tr><th></th><th>bias</th><th>variance</th><th>常见误差</th></tr></thead><tbody><tr><td>复杂模型</td><td>较小</td><td>较大</td><td>overfiting</td></tr><tr><td>简单模型</td><td>较大</td><td>较小</td><td>underfiting</td></tr></tbody></table></div><hr><h2 id="Tips-for-training-DNN"><a href="#Tips-for-training-DNN" class="headerlink" title="Tips for training DNN"></a>Tips for training DNN</h2><p>啥也不说，先看张图</p><p><a href="https://user-images.githubusercontent.com/36947860/74907659-d2ab8780-53ee-11ea-9fdb-75a0d576f247.png" data-fancybox="group" data-caption="1581752334(1)" class="fancybox"><img alt="1581752334(1)" data-src="https://user-images.githubusercontent.com/36947860/74907659-d2ab8780-53ee-11ea-9fdb-75a0d576f247.png" class="lazyload" title="1581752334(1)"></a></p><hr><h3 id="New-activation-function"><a href="#New-activation-function" class="headerlink" title="New activation function"></a>New activation function</h3><p>对激活函数进行创新可以改进模型</p><p><strong>question：为什么需要激活函数？</strong></p><p>如果没有激活函数，整个网络就是线性的，<strong>线性的缺点</strong>，在于线性函数的组合仍然是线性函数，这意味着无论我们堆多少层网络，如果这些层都使用线性激活函数，那么这些层最终等效于一层。（可以自己画一个简单的全连接网络计算一下）</p><hr><h4 id="常见激活函数"><a href="#常见激活函数" class="headerlink" title="常见激活函数"></a>常见激活函数</h4><p><a href="https://user-images.githubusercontent.com/36947860/74907718-e48d2a80-53ee-11ea-9058-392f80175315.png" data-fancybox="group" data-caption="激活函数" class="fancybox"><img alt="激活函数" data-src="https://user-images.githubusercontent.com/36947860/74907718-e48d2a80-53ee-11ea-9058-392f80175315.png" class="lazyload" title="激活函数"></a></p><hr><h4 id="Sigmoid"><a href="#Sigmoid" class="headerlink" title="Sigmoid"></a>Sigmoid<a href="https://user-images.githubusercontent.com/36947860/74907738-eb1ba200-53ee-11ea-8a11-7298ccf95878.png" data-fancybox="group" data-caption="微信截图_20200216012819" class="fancybox"><img alt="微信截图_20200216012819" data-src="https://user-images.githubusercontent.com/36947860/74907738-eb1ba200-53ee-11ea-8a11-7298ccf95878.png" class="lazyload" title="微信截图_20200216012819"></a></h4><p>生物神经元似乎是用 Sigmoid（S 型）激活函数活动的，因此研究人员在很长一段时间内坚持 Sigmoid 函数。但事实证明，Relu 激活函数通常在 ANN 工作得更好。这是生物研究误导的例子之一。</p><p>当神经网络有很多层，每个隐藏层都使用Sigmoid函数作为激励函数时，很容易引起梯度消失的问题</p><p>我们知道Sigmoid函数有一个缺点：当x较大或较小时，导数接近0；并且Sigmoid函数导数的最大值是0.25</p><p>我们将问题简单化来说明梯度消失问题，假设输入只有一个特征，没有偏置单元，每层只有一个神经元</p><p><a href="https://user-images.githubusercontent.com/36947860/74907663-d3441e00-53ee-11ea-82fd-208f3dc94e4a.png" data-fancybox="group" data-caption="20180807163139589" class="fancybox"><img alt="20180807163139589" data-src="https://user-images.githubusercontent.com/36947860/74907663-d3441e00-53ee-11ea-82fd-208f3dc94e4a.png" class="lazyload" title="20180807163139589"></a></p><p>则代价函数对w的导数可以表示为：</p><p><a href="https://user-images.githubusercontent.com/36947860/74907660-d2ab8780-53ee-11ea-9dfe-91ed6db63d45.png" data-fancybox="group" data-caption="2018080717114969" class="fancybox"><img alt="2018080717114969" data-src="https://user-images.githubusercontent.com/36947860/74907660-d2ab8780-53ee-11ea-9dfe-91ed6db63d45.png" class="lazyload" title="2018080717114969"></a></p><p>如果我们使用标准方法来初始化网络中的权重，那么会使用一个均值为0标准差为1的高斯分布。因此所有的权重通常会满足|wj|<1，而s‘是小于0.25的值，那么当神经网络特别深的时候，梯度呈指数级衰减，导数在每一层至少会被压缩为原来的1/4，当z值绝对值特别大时，导数趋于0，正是因为这两个原因，从输出层不断向输入层反向传播训练时，导数很容易逐渐变为0，使得权重和偏差参数无法被更新，导致神经网络无法被优化，训练永远不会收敛到良好的解决方案。 这被称为<strong>梯度消失</strong>问题。</p><p>当我们将w初始化为一个较大的值时，例如>10的值，那么从输出层到输入层每一层都会有一个s‘(zn)×wn的倍增，当s‘(zn)为0.25时，s‘(zn)×wn>2.5，同梯度消失类似，当神经网络很深时，梯度呈指数级增长，最后到输入时，梯度将会非常大，我们会得到一个非常大的权重更新，这就是<strong>梯度爆炸</strong>的问题，在循环神经网络中最为常见。</p><p>原文链接：<a href="https://blog.csdn.net/junjun150013652/article/details/81274958" target="_blank" rel="noopener">https://blog.csdn.net/junjun150013652/article/details/81274958</a></p><hr><h4 id="ReLU"><a href="#ReLU" class="headerlink" title="ReLU"></a>ReLU</h4><p><a href="https://user-images.githubusercontent.com/36947860/74907666-d4754b00-53ee-11ea-952c-c97d0905bb3a.png" data-fancybox="group" data-caption="QQ截图20200216215330" class="fancybox"><img alt="QQ截图20200216215330" data-src="https://user-images.githubusercontent.com/36947860/74907666-d4754b00-53ee-11ea-952c-c97d0905bb3a.png" class="lazyload" title="QQ截图20200216215330"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907669-d50de180-53ee-11ea-93ec-27c46aabf49e.png" data-fancybox="group" data-caption="QQ截图20200216215421" class="fancybox"><img alt="QQ截图20200216215421" data-src="https://user-images.githubusercontent.com/36947860/74907669-d50de180-53ee-11ea-93ec-27c46aabf49e.png" class="lazyload" title="QQ截图20200216215421"></a></p><p>ReLU可以解决Sigmoid函数的梯度消失和梯度爆炸问题。</p><hr><p><strong>question：ReLU化简后不就是线性激活函数吗?</strong></p><p>关于这个问题，可以有以下解释：</p><p>1、首先什么是线性的网络，如果把线性网络看成一个大的矩阵M。那么输入样本A和B，则会经过同样的线性变换MA，MB（这里A和B经历的线性变换矩阵M是一样的）。</p><p>2、的确对于单一的样本A，经过由relu激活函数所构成神经网络，其过程确实可以等价是经过了一个线性变换M1，但是对于样本B，在经过同样的网络时，由于每个神经元是否激活（0或者Wx+b）与样本A经过时情形不同了（不同样本），因此B所经历的线性变换M2并不等于M1。因此，relu构成的神经网络虽然对每个样本都是线性变换，但是不同样本之间经历的线性变换M并不一样，所以整个样本空间在经过relu构成的网络时其实是经历了非线性变换的。</p><p>3、还有一种解释就是，不同样本的同一个feature，在通过relu构成的神经网络时，流经的路径不一样（relu激活值为0，则堵塞；激活值为本身，则通过），因此最终的输出空间其实是输入空间的非线性变换得来的。</p><p>4、更极端的，不管是tanh还是sigmoid，你都可以把它们近似看成是分段线性的函数（很多段），但依然能够有非线性表达能力；relu虽然只有两段，但同样也是非线性激活函数，道理与之是一样的。</p><p>链接：<a href="https://www.jianshu.com/p/66cb257ec37e" target="_blank" rel="noopener">https://www.jianshu.com/p/66cb257ec37e</a></p><hr><h4 id="Leaky-ReLU"><a href="#Leaky-ReLU" class="headerlink" title="Leaky ReLU"></a>Leaky ReLU</h4><p><a href="https://user-images.githubusercontent.com/36947860/74907670-d5a67800-53ee-11ea-8e5d-dac1da0aaeca.png" data-fancybox="group" data-caption="QQ截图20200216221007" class="fancybox"><img alt="QQ截图20200216221007" data-src="https://user-images.githubusercontent.com/36947860/74907670-d5a67800-53ee-11ea-8e5d-dac1da0aaeca.png" class="lazyload" title="QQ截图20200216221007"></a></p><hr><h4 id="Maxout"><a href="#Maxout" class="headerlink" title="Maxout"></a>Maxout</h4><p><a href="https://user-images.githubusercontent.com/36947860/74907674-d63f0e80-53ee-11ea-9d98-02493f2fc778.png" data-fancybox="group" data-caption="QQ截图20200216221200" class="fancybox"><img alt="QQ截图20200216221200" data-src="https://user-images.githubusercontent.com/36947860/74907674-d63f0e80-53ee-11ea-9d98-02493f2fc778.png" class="lazyload" title="QQ截图20200216221200"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907675-d6d7a500-53ee-11ea-94ed-d4ebd2cb2abc.png" data-fancybox="group" data-caption="QQ截图20200216221556" class="fancybox"><img alt="QQ截图20200216221556" data-src="https://user-images.githubusercontent.com/36947860/74907675-d6d7a500-53ee-11ea-94ed-d4ebd2cb2abc.png" class="lazyload" title="QQ截图20200216221556"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907676-d7703b80-53ee-11ea-9ff0-052cc9882474.png" data-fancybox="group" data-caption="QQ截图20200216221608" class="fancybox"><img alt="QQ截图20200216221608" data-src="https://user-images.githubusercontent.com/36947860/74907676-d7703b80-53ee-11ea-9ff0-052cc9882474.png" class="lazyload" title="QQ截图20200216221608"></a></p><hr><p><strong>question：Maxout激活函数如何求导？</strong></p><p>根据Maxout将网络化简后，去掉那些不参与正向传播过程的神经单元，再进行求导。</p><p>同理CNN中的pooling层也这样求导。</p><hr><h3 id="Adaptive-Learning-Rate"><a href="#Adaptive-Learning-Rate" class="headerlink" title="Adaptive Learning Rate"></a>Adaptive Learning Rate</h3><p>At the beginning,we are far from the destination,so we use large learning rate.</p><p>After several epochs,we are close to the destination,so we reduce the learning rate.</p><h4 id="1-t-decay"><a href="#1-t-decay" class="headerlink" title="1/t decay"></a>1/t decay</h4><p><a href="https://user-images.githubusercontent.com/36947860/74907683-d808d200-53ee-11ea-8055-12c4fa71abcf.png" data-fancybox="group" data-caption="QQ截图20200216225204" class="fancybox"><img alt="QQ截图20200216225204" data-src="https://user-images.githubusercontent.com/36947860/74907683-d808d200-53ee-11ea-8055-12c4fa71abcf.png" class="lazyload" title="QQ截图20200216225204"></a></p><hr><h4 id="Adagrad"><a href="#Adagrad" class="headerlink" title="Adagrad"></a>Adagrad</h4><p><a href="https://user-images.githubusercontent.com/36947860/74907680-d808d200-53ee-11ea-9b23-d4e9346fd4e7.png" data-fancybox="group" data-caption="QQ截图20200216224137" class="fancybox"><img alt="QQ截图20200216224137" data-src="https://user-images.githubusercontent.com/36947860/74907680-d808d200-53ee-11ea-9b23-d4e9346fd4e7.png" class="lazyload" title="QQ截图20200216224137"></a></p><p>依然符合随着训练次数增加，learning rate减小。</p><hr><p><strong>question：当某一次grad很大时，学习率反而更小了，这难道不和我们的规律矛盾吗？</strong></p><p>确实有这样反直觉的疑惑，一种合理的解释是：<em>root  mean square</em> of the previous derivatives of the parameter w 其实代表了w的二次微分，即陡峭程度，用w的一次微分除以二次微分，才是w应该更新的最佳步长。</p><hr><h4 id="RMSProp"><a href="#RMSProp" class="headerlink" title="RMSProp"></a>RMSProp</h4><p>error surface can be very complex when trainning NN，所以learning rate应该具备快速变化的能力。</p><p><a href="https://user-images.githubusercontent.com/36947860/74907685-d8a16880-53ee-11ea-84ab-c29f827d326b.png" data-fancybox="group" data-caption="QQ截图20200216231042" class="fancybox"><img alt="QQ截图20200216231042" data-src="https://user-images.githubusercontent.com/36947860/74907685-d8a16880-53ee-11ea-84ab-c29f827d326b.png" class="lazyload" title="QQ截图20200216231042"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907686-d939ff00-53ee-11ea-8e8b-684892285b07.png" data-fancybox="group" data-caption="QQ截图20200216231202" class="fancybox"><img alt="QQ截图20200216231202" data-src="https://user-images.githubusercontent.com/36947860/74907686-d939ff00-53ee-11ea-8e8b-684892285b07.png" class="lazyload" title="QQ截图20200216231202"></a></p><p>可以参照计算机网络RTT更新公式。</p><h4 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h4><p>在网络训练中，loss可能收敛在plateau,saddle point, local minima.可以参照物理学中的知识，加一个momentum。</p><p><a href="https://user-images.githubusercontent.com/36947860/74907687-d9d29580-53ee-11ea-80fd-be1bfaf5ad0e.png" data-fancybox="group" data-caption="QQ截图20200216231341" class="fancybox"><img alt="QQ截图20200216231341" data-src="https://user-images.githubusercontent.com/36947860/74907687-d9d29580-53ee-11ea-80fd-be1bfaf5ad0e.png" class="lazyload" title="QQ截图20200216231341"></a></p><p>不加momentum</p><p><a href="https://user-images.githubusercontent.com/36947860/74907690-da6b2c00-53ee-11ea-8715-fb942212909a.png" data-fancybox="group" data-caption="QQ截图20200216231915" class="fancybox"><img alt="QQ截图20200216231915" data-src="https://user-images.githubusercontent.com/36947860/74907690-da6b2c00-53ee-11ea-8715-fb942212909a.png" class="lazyload" title="QQ截图20200216231915"></a></p><p>加momentum</p><p><a href="https://user-images.githubusercontent.com/36947860/74907691-db03c280-53ee-11ea-962b-0b538c30f24f.png" data-fancybox="group" data-caption="QQ截图20200216231940" class="fancybox"><img alt="QQ截图20200216231940" data-src="https://user-images.githubusercontent.com/36947860/74907691-db03c280-53ee-11ea-962b-0b538c30f24f.png" class="lazyload" title="QQ截图20200216231940"></a></p><hr><h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4><p>RMSProb+Momentum</p><p><a href="https://user-images.githubusercontent.com/36947860/74907692-db9c5900-53ee-11ea-86cd-e2bee8140b93.png" data-fancybox="group" data-caption="QQ截图20200216232815" class="fancybox"><img alt="QQ截图20200216232815" data-src="https://user-images.githubusercontent.com/36947860/74907692-db9c5900-53ee-11ea-86cd-e2bee8140b93.png" class="lazyload" title="QQ截图20200216232815"></a></p><hr><p>接下来的方法都是处理过拟合的方法</p><h3 id="Early-Stopping"><a href="#Early-Stopping" class="headerlink" title="Early Stopping"></a>Early Stopping</h3><p>没什么卵用</p><hr><h3 id="Regularization"><a href="#Regularization" class="headerlink" title="Regularization"></a>Regularization</h3><p><strong>L2正则化</strong></p><p><a href="https://user-images.githubusercontent.com/36947860/74907693-dc34ef80-53ee-11ea-804b-18bc21abc501.png" data-fancybox="group" data-caption="QQ截图20200216233114" class="fancybox"><img alt="QQ截图20200216233114" data-src="https://user-images.githubusercontent.com/36947860/74907693-dc34ef80-53ee-11ea-804b-18bc21abc501.png" class="lazyload" title="QQ截图20200216233114"></a></p><p>使用L2范数做正则化，每次会使Weight小一点，所以这也叫做weight decay。</p><p><strong>正则化这个tip相较于其他tip对网络的优化程度比较小。解释如下：</strong></p><p>我们在训练神经网络时，通常对w初始化一个比较接近0的数，然后通过一次次更新，w距离0越来越远。而正则化所做的事情，其实就是每次使w离0近一点，这难道不就相当于减少训练次数吗?</p><p><strong>L1正则化</strong></p><p><a href="https://user-images.githubusercontent.com/36947860/74907694-dc34ef80-53ee-11ea-8e2a-19d0dacfbd0c.png" data-fancybox="group" data-caption="QQ截图20200216234835" class="fancybox"><img alt="QQ截图20200216234835" data-src="https://user-images.githubusercontent.com/36947860/74907694-dc34ef80-53ee-11ea-8e2a-19d0dacfbd0c.png" class="lazyload" title="QQ截图20200216234835"></a></p><p>sgn()为正负1，当w为正，则结果-1，w为负，则结果加1。</p><p><strong>L1正则化和L2正则化对比：</strong></p><p>L1  learn出来的值有的很大，有的很小，分布很散，因为他每次都是加减固定的值。而L2 learn出来的值都偏小，因为他是成比例缩小的。</p><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><p><a href="https://user-images.githubusercontent.com/36947860/74907695-dccd8600-53ee-11ea-81d0-0562e1dc7f18.png" data-fancybox="group" data-caption="QQ截图20200216235500" class="fancybox"><img alt="QQ截图20200216235500" data-src="https://user-images.githubusercontent.com/36947860/74907695-dccd8600-53ee-11ea-81d0-0562e1dc7f18.png" class="lazyload" title="QQ截图20200216235500"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907696-dd661c80-53ee-11ea-8831-f61a3e556c91.png" data-fancybox="group" data-caption="QQ截图20200216235743" class="fancybox"><img alt="QQ截图20200216235743" data-src="https://user-images.githubusercontent.com/36947860/74907696-dd661c80-53ee-11ea-8831-f61a3e556c91.png" class="lazyload" title="QQ截图20200216235743"></a></p><p><strong>Why the weigth should multiply  (1-p)  when testing?</strong></p><p> 来一个直观的解释，假设现在有100个1，dropout rate 是20%，那么只有80个1参与运算，sum之后值为80，当测试时，100个1全部参与运算，所以每个1都要乘以80%，再sum，才能得到80。</p><hr><p><strong>Dropout is a kind of ensemble</strong></p><p><a href="https://user-images.githubusercontent.com/36947860/74907699-ddfeb300-53ee-11ea-8296-3d673bc4b3bc.png" data-fancybox="group" data-caption="QQ截图20200217000615" class="fancybox"><img alt="QQ截图20200217000615" data-src="https://user-images.githubusercontent.com/36947860/74907699-ddfeb300-53ee-11ea-8296-3d673bc4b3bc.png" class="lazyload" title="QQ截图20200217000615"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907701-de974980-53ee-11ea-852b-42889b62b1f7.png" data-fancybox="group" data-caption="QQ截图20200217000655" class="fancybox"><img alt="QQ截图20200217000655" data-src="https://user-images.githubusercontent.com/36947860/74907701-de974980-53ee-11ea-852b-42889b62b1f7.png" class="lazyload" title="QQ截图20200217000655"></a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Why_deep</title>
      <link href="/2020/02/22/why_deep/"/>
      <url>/2020/02/22/why_deep/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>相对于机器学习，深度学习为什么要 <strong>Deep</strong> 呢？</p><p>直觉上是因为神经网络层数越多，参数就越多，拟合能力越强，但是参数多可以向 <strong>shallow</strong> 的方向发展，那为甚什么要向 <strong>Deep</strong> 的方向发展呢？</p><p>要对比<strong>Deep</strong>与<strong>Shallow</strong>  ，首先要保证他们的参数两是一样的，这样对比才比较公平，如下图：</p><p><a href="https://user-images.githubusercontent.com/60562661/75113138-f5a39900-5685-11ea-8aa6-e8668f869b82.png" data-fancybox="group" data-caption="1582463394370" class="fancybox"><img alt="1582463394370" style="zoom: 50%;" data-src="https://user-images.githubusercontent.com/60562661/75113138-f5a39900-5685-11ea-8aa6-e8668f869b82.png" class="lazyload" title="1582463394370"></a></p><p>更深的网络模型确实是有更好的表现，误差会更低。</p><p>事实上更加Deep，有更多的 <strong>Hidden Layer</strong>  ，是在做<code>模组化(Modularization)</code> 这件事，这和模块化、函数式编程很相似，也就是说每层有具体的功能，例如：</p><ul><li>第一层的神经元是比较基础的分类器；第二层则是比较高级的…</li><li>其中第二层以第一层的输出作为输入，第三层以第二层的输出作为输入，以此类推…</li><li>模组化是机器自己学习出来的，模组化可以想象CNN —比较底层可以识别细节信息，高层则可以更好的识别语义信息</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/109256726-9b598d00-7831-11eb-927f-39f49caaeca1.png" data-fancybox="group" data-caption="1582463874502" class="fancybox"><img alt="1582463874502" data-src="https://user-images.githubusercontent.com/36947860/109256726-9b598d00-7831-11eb-927f-39f49caaeca1.png" class="lazyload" title="1582463874502"></a></p><p>做<code>Modularization</code>  这件事的好处就是网络可以举一反三，不再需要很多很多的<code>data</code>.</p><p>有一种流行的说法：<code>AI = BigData + DeepLearning</code>  大数据与深度学习相结合所以可以做识别等任务(<strong>深度学习需要很大的数据支撑</strong>)，恰恰相反，深度学习只需要更少的Data，这里的<strong>BigData </strong> 即使有100g，1000g 依然不能包含所有的Data，因此才需要<code>DeepLearning</code>来举一反三 ，如果真的有能包含所有东西的大数据那根本不需要深度学习这件事了，直接做标签分类就实现了。</p><p>知乎上也有对这个问题的讨论：</p><p><a href="https://www.zhihu.com/question/366859726/answer/1009232734" target="_blank" rel="noopener">https://www.zhihu.com/question/366859726/answer/1009232734</a></p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RNN_LSTM</title>
      <link href="/2020/02/18/RNN_LSTM/"/>
      <url>/2020/02/18/RNN_LSTM/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="Naive-RNN"><a href="#Naive-RNN" class="headerlink" title="Naive  RNN:"></a>Naive  RNN:</h2><p><a href="https://user-images.githubusercontent.com/36947860/74907654-d0e1c400-53ee-11ea-8488-4e09eebcd038.jpg" data-fancybox="group" data-caption="2256672-cf18bb1f06e750a4" class="fancybox"><img alt="2256672-cf18bb1f06e750a4" data-src="https://user-images.githubusercontent.com/36947860/74907654-d0e1c400-53ee-11ea-8488-4e09eebcd038.jpg" class="lazyload" title="2256672-cf18bb1f06e750a4"></a></p><h2 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN:"></a>Bidirectional RNN:</h2><p><a href="https://user-images.githubusercontent.com/36947860/74907651-cf180080-53ee-11ea-90cb-ccb2a6d18c10.png" data-fancybox="group" data-caption="2256672-039a45251aa5d220" class="fancybox"><img alt="2256672-039a45251aa5d220" data-src="https://user-images.githubusercontent.com/36947860/74907651-cf180080-53ee-11ea-90cb-ccb2a6d18c10.png" class="lazyload" title="2256672-039a45251aa5d220"></a></p><p>RNN是三维的，沿时间维串起来，形成一个立体。因为下一时间点隐藏层的计算需要上一时间点隐藏层的数据，因此因此层需要一个memory单元来存储中间计算结果。</p><h2 id="long-short-term-Memory（LSTM）："><a href="#long-short-term-Memory（LSTM）：" class="headerlink" title="long short-term Memory（LSTM）："></a>long short-term Memory（LSTM）：</h2><p>从命名可以看出，LSTM依然是短期记忆网络，只不过是记忆的时间比较长而已。LSTM有input Gate，forget gate，outputgate，和input四个输入，所以LSTM需要的参数（w）是一般网络的四倍。即原本的一个输入vector，乘上4个不同的w矩阵，变成4个不同的vector，对应到这四个输入。</p><p>LSTM的一个神经元长这样：</p><p><a href="https://user-images.githubusercontent.com/36947860/74907709-e1923a00-53ee-11ea-91e8-98839b20c5ae.png" data-fancybox="group" data-caption="QQ截图20200218230517" class="fancybox"><img alt="QQ截图20200218230517" data-src="https://user-images.githubusercontent.com/36947860/74907709-e1923a00-53ee-11ea-91e8-98839b20c5ae.png" class="lazyload" title="QQ截图20200218230517"></a></p><p><strong>LSTM的计算过程</strong>长这样，如果看不懂可以去看李宏毅的教学视频</p><p>简单描述一下：</p><p>输入一个向量X（就跟全连接网络输入的X一样），X乘上4个不同的transformer，变成Z和Z的三个控制信号（Z就和全连接网络里的Z一样），然后输入到neuron里面进行组合运算（全连接的neuron里面只有一个激活函数，但LSTM的neuron有5个激活函数），之后再进行输出。</p><p>通常呢，对输入的向量X也有改进，即</p><p>X_改进=X_原来    <em>串接</em> 上一时间点Output Gate后的输出  <em>串接</em>   上一时间点上一层cell中的值(peephole)。</p><p><a href="https://user-images.githubusercontent.com/36947860/74907711-e22ad080-53ee-11ea-8967-e2134d699319.png" data-fancybox="group" data-caption="QQ截图20200218232243" class="fancybox"><img alt="QQ截图20200218232243" data-src="https://user-images.githubusercontent.com/36947860/74907711-e22ad080-53ee-11ea-8967-e2134d699319.png" class="lazyload" title="QQ截图20200218232243"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907712-e22ad080-53ee-11ea-916b-7e46feed2b65.png" data-fancybox="group" data-caption="QQ截图20200218232303" class="fancybox"><img alt="QQ截图20200218232303" data-src="https://user-images.githubusercontent.com/36947860/74907712-e22ad080-53ee-11ea-916b-7e46feed2b65.png" class="lazyload" title="QQ截图20200218232303"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907713-e2c36700-53ee-11ea-837f-a03774f3e880.png" data-fancybox="group" data-caption="QQ截图20200218232447" class="fancybox"><img alt="QQ截图20200218232447" data-src="https://user-images.githubusercontent.com/36947860/74907713-e2c36700-53ee-11ea-837f-a03774f3e880.png" class="lazyload" title="QQ截图20200218232447"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907716-e35bfd80-53ee-11ea-8a6d-99daa264eb77.png" data-fancybox="group" data-caption="QQ截图20200218232656" class="fancybox"><img alt="QQ截图20200218232656" data-src="https://user-images.githubusercontent.com/36947860/74907716-e35bfd80-53ee-11ea-8a6d-99daa264eb77.png" class="lazyload" title="QQ截图20200218232656"></a></p><p>最后，我们来<strong>总结一下LSTM</strong>：</p><p><a href="https://user-images.githubusercontent.com/36947860/75104096-ce29dd80-563f-11ea-840d-23ca579e0819.jpg" data-fancybox="group" data-caption="微信图片_20200223132154" class="fancybox"><img alt="微信图片_20200223132154" data-src="https://user-images.githubusercontent.com/36947860/75104096-ce29dd80-563f-11ea-840d-23ca579e0819.jpg" class="lazyload" title="微信图片_20200223132154"></a></p><p>李宏毅老师的视频确实讲的好，但这个图未免有些太乱了，我们从知乎上找了一张描述更清晰的图，来对LSTM做一个总结。</p><p>三个门控的激活函数都是σ激活函数，从左到右依次是遗忘门，输入门，输出门。门的激活函数不选用relu是因为relu是没有饱和区域的，那么就没法起到门的作用。</p><ul><li><p>遗忘门的作用是控制长期记忆有多大长度被保留下来</p></li><li><p>输入门的作用是控制临时记忆有多大程度被记录在长期记忆中</p></li><li><p>输出门的作用是控制长期记忆有多大程度被当作隐藏层状态的输出。</p></li></ul><p>候选记忆用tanh激活函数产生是因为tanh的输出在-1~1，是0中心的，并且在0附近的梯度大，模型收敛快。</p><p>隐藏层状态的输出同理。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RNN </tag>
            
            <tag> LSTM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CNN</title>
      <link href="/2020/02/18/CNN/"/>
      <url>/2020/02/18/CNN/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="CNN全览"><a href="#CNN全览" class="headerlink" title="CNN全览"></a>CNN全览</h2><p><a href="https://user-images.githubusercontent.com/36947860/74907705-df2fe000-53ee-11ea-9cd0-ca974e24c0ac.png" data-fancybox="group" data-caption="QQ截图20200218220905" class="fancybox"><img alt="QQ截图20200218220905" data-src="https://user-images.githubusercontent.com/36947860/74907705-df2fe000-53ee-11ea-9cd0-ca974e24c0ac.png" class="lazyload" title="QQ截图20200218220905"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907664-d4754b00-53ee-11ea-817f-ae03119ea0f6.png" data-fancybox="group" data-caption="mnist" class="fancybox"><img alt="mnist" data-src="https://user-images.githubusercontent.com/36947860/74907664-d4754b00-53ee-11ea-817f-ae03119ea0f6.png" class="lazyload" title="mnist"></a></p><p>CNN主要包含卷积和池化两个操作</p><p>卷积层解决了两个问题：</p><ul><li>有时，我们不用检测整个图片，只用检测图片的一部分</li><li>一样的部分可能出现在图像的不同部分。</li></ul><p>池化层解决了一个问题：</p><ul><li>图片清晰度不高依然可以辨识</li></ul><p>所以，CNN并不能自动辨识不同尺度的相同图像，需要加一些额外手段。</p><h2 id="CNN细节"><a href="#CNN细节" class="headerlink" title="CNN细节"></a>CNN细节</h2><p>1、卷积核是有z轴的，z轴大小对应了输入图像的channel，假设现在又一个m×n×n的图像，则一个卷积核的大小需要是m×k×k，运算后产生一个1×?×?的新map，假设有2个卷积核，则产生2×?×?的新map，即卷积核的数量决定了新生成的map的channel数。</p><p>2、convolution和fully connected的关系</p><p>卷积层，其实相当于全连接层拿掉了一些weight+weight参数共享，假设只有1个channel，卷积核的大小为k×k，有n个卷积核，则卷积层需要的参数个数为n×k×k</p><p><a href="https://user-images.githubusercontent.com/36947860/74907706-dfc87680-53ee-11ea-9079-ade9fe256b20.png" data-fancybox="group" data-caption="QQ截图20200218223322" class="fancybox"><img alt="QQ截图20200218223322" data-src="https://user-images.githubusercontent.com/36947860/74907706-dfc87680-53ee-11ea-9079-ade9fe256b20.png" class="lazyload" title="QQ截图20200218223322"></a></p><p>3、Flatten</p><p>一个卷积核输出一个feature，n个卷积核就输出n个feature（1×?×?的map），flatten做的事情就是把n个feature拉直。</p><p><a href="https://user-images.githubusercontent.com/36947860/74907707-e0610d00-53ee-11ea-95c9-3111a1128f4e.png" data-fancybox="group" data-caption="QQ截图20200218223911" class="fancybox"><img alt="QQ截图20200218223911" data-src="https://user-images.githubusercontent.com/36947860/74907707-e0610d00-53ee-11ea-95c9-3111a1128f4e.png" class="lazyload" title="QQ截图20200218223911"></a></p><p>4、反卷积</p><p>反卷积是卷积的反向操作，用于将图片还原到原来的尺寸，还原时的padding和步长有固定的计算步骤，暂时不展开详述。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向传播算法</title>
      <link href="/2020/02/15/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/15/%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>我们已经知道了梯度下降法的基本原理，那么对神经网络中的参数进行更新就可以利用梯度下降的方法，首先，我们根据链式法则对每个参数进行求导，然后利用梯度下降法更新。这样做当然是可行的，但是未免太蠢了。假如有100万个参数，我们就要求导100万次，并且每次都要进行链式展开，计算量实在太大了。此时，有一个聪明的善于观察的人啊，他发现每次链式展开的求导公式里，有很多重复的部分，根据这个现象，他提出了大名鼎鼎的反向传播算法，解决了神经网络中求梯度时计算量太大的问题。</p><h2 id="反向传播算法图解"><a href="#反向传播算法图解" class="headerlink" title="反向传播算法图解"></a>反向传播算法图解</h2><p><a href="https://user-images.githubusercontent.com/36947860/74907731-e820b180-53ee-11ea-85f1-e38641b0a03f.png" data-fancybox="group" data-caption="微信截图_20200216001150" class="fancybox"><img alt="微信截图_20200216001150" data-src="https://user-images.githubusercontent.com/36947860/74907731-e820b180-53ee-11ea-85f1-e38641b0a03f.png" class="lazyload" title="微信截图_20200216001150"></a></p><p><a href="https://user-images.githubusercontent.com/36947860/74907732-e8b94800-53ee-11ea-8050-fe0dbcc00314.png" data-fancybox="group" data-caption="微信截图_20200216001840" class="fancybox"><img alt="微信截图_20200216001840" data-src="https://user-images.githubusercontent.com/36947860/74907732-e8b94800-53ee-11ea-8050-fe0dbcc00314.png" class="lazyload" title="微信截图_20200216001840"></a></p><hr><p><a href="https://user-images.githubusercontent.com/36947860/74907733-e951de80-53ee-11ea-871a-effc8a80cdc9.png" data-fancybox="group" data-caption="微信截图_20200216002028" class="fancybox"><img alt="微信截图_20200216002028" data-src="https://user-images.githubusercontent.com/36947860/74907733-e951de80-53ee-11ea-871a-effc8a80cdc9.png" class="lazyload" title="微信截图_20200216002028"></a></p><p><strong>惊喜发现：</strong> 和正向传播用的权重一模一样，和正向传播过程一模一样。</p><hr><p><a href="https://user-images.githubusercontent.com/36947860/74907735-e9ea7500-53ee-11ea-80c4-925ac212773c.png" data-fancybox="group" data-caption="微信截图_20200216003313" class="fancybox"><img alt="微信截图_20200216003313" data-src="https://user-images.githubusercontent.com/36947860/74907735-e9ea7500-53ee-11ea-80c4-925ac212773c.png" class="lazyload" title="微信截图_20200216003313"></a></p><h2 id="简要概括"><a href="#简要概括" class="headerlink" title="简要概括"></a>简要概括</h2><p>假设在正向传播中的某一层表示为：</p><p><a href="https://www.zhihu.com/equation?tex=%5Ctext+%7B+out+%7D%3DZ_%7BL%7D+W_%7BL%2B1%7D%2B%5Ctilde%7Bb%7D_%7BL%2B1%7D" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Ctext+%7B+out+%7D%3DZ_%7BL%7D+W_%7BL%2B1%7D%2B%5Ctilde%7Bb%7D_%7BL%2B1%7D" class="lazyload" title="[公式]"></a></p><p>则反向传播中，对Z的求导公式为（T表示转置）：公式1</p><p><a href="https://www.zhihu.com/equation?tex=+%5CRightarrow+%5Cfrac%7B%5Cpartial+J%7D%7B%5Cpartial+Z_%7BL%7D%7D%3D%5Cfrac%7B%5Cpartial+J%7D%7B%5Cpartial+out%7DW_%7BL%2B1%7D%5ET+" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=+%5CRightarrow+%5Cfrac%7B%5Cpartial+J%7D%7B%5Cpartial+Z_%7BL%7D%7D%3D%5Cfrac%7B%5Cpartial+J%7D%7B%5Cpartial+out%7DW_%7BL%2B1%7D%5ET+" class="lazyload" title="[公式]"></a></p><p>对W的求导公式为（T表示转置）：公式2</p><p><a href="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+J%7D%7B%5Cpartial+W_%7BL%2B1%7D%7D%3DZ_L%5ET%5Cfrac%7B%5Cpartial+J%7D%7B%5Cpartial+out%7D+" data-fancybox="group" data-caption="[公式]" class="fancybox"><img alt="[公式]" data-src="https://www.zhihu.com/equation?tex=%5Cfrac%7B%5Cpartial+J%7D%7B%5Cpartial+W_%7BL%2B1%7D%7D%3DZ_L%5ET%5Cfrac%7B%5Cpartial+J%7D%7B%5Cpartial+out%7D+" class="lazyload" title="[公式]"></a></p><p>只要我们从后往前算，每一步只需要利用上一步的结果，加一点点小小的步骤。所有的z、w、b都只需要利用对out的导数即可（不太严谨，因为没有把激活函数考虑在内，但激活函数并不破坏这种依赖，只是加了一点小小的步骤）。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降法</title>
      <link href="/2020/02/15/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/"/>
      <url>/2020/02/15/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="梯度"><a href="#梯度" class="headerlink" title="梯度"></a>梯度</h3><p>梯度的方向总是平行于xOy平面。假设在这样一个二维曲面上，紫色箭头就是图中红色点P的梯度,两条黄色的箭头就是x和y的偏导。</p><p>沿着紫色箭头的方向垂直于xOy平面将原曲面切开，将会在原曲面上得到一条曲线，如图中的蓝色曲线（是曲线的一部分），求点P在该曲线上的导数，就是P点在梯度方向的方向导数。</p><p><a href="https://user-images.githubusercontent.com/36947860/74907717-e3f49400-53ee-11ea-9e74-f8af8c1859ef.jpg" data-fancybox="group" data-caption="v2-2370004ffcbcfb29eff636e829a21df4_hd" class="fancybox"><img alt="v2-2370004ffcbcfb29eff636e829a21df4_hd" data-src="https://user-images.githubusercontent.com/36947860/74907717-e3f49400-53ee-11ea-9e74-f8af8c1859ef.jpg" class="lazyload" title="v2-2370004ffcbcfb29eff636e829a21df4_hd"></a></p><p>总结以下四点：</p><ul><li>P点在平行于xOy平面的360°都有<strong>方向</strong></li><li>每个方向都有导数，就是<strong>方向导数</strong></li><li><p>方向导数取到最大值的方向就叫做<strong>梯度方向</strong></p></li><li><p>求梯度方向的方向导数的值，就是<strong>梯度的值</strong>、</p></li></ul><h3 id="泰勒展开式"><a href="#泰勒展开式" class="headerlink" title="泰勒展开式"></a>泰勒展开式</h3><p>我们知道，所有的函数都可以用泰勒展开式展开。</p><ul><li>只含有一个参数的函数展开如下：</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/74907719-e525c100-53ee-11ea-80b3-737c00f2d47d.png" data-fancybox="group" data-caption="微信截图_20200215223932" class="fancybox"><img alt="微信截图_20200215223932" data-src="https://user-images.githubusercontent.com/36947860/74907719-e525c100-53ee-11ea-80b3-737c00f2d47d.png" class="lazyload" title="微信截图_20200215223932"></a></p><ul><li>含有两个参数的泰勒展开如下：</li></ul><p><a href="https://user-images.githubusercontent.com/36947860/74907720-e525c100-53ee-11ea-9d97-486053dca7fd.png" data-fancybox="group" data-caption="微信截图_20200215224022" class="fancybox"><img alt="微信截图_20200215224022" data-src="https://user-images.githubusercontent.com/36947860/74907720-e525c100-53ee-11ea-9d97-486053dca7fd.png" class="lazyload" title="微信截图_20200215224022"></a></p><ul><li>多个参数依次类推。。。</li></ul><h2 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h2><p>假设NN现在只包含两个参数θ1和θ2，设损失函数为L(θ)，那么在以点(a,b)为圆心，η为半径的范围内，（a和b就是梯度下降前的θ1和θ2，η就是学习率）有：</p><p><a href="https://user-images.githubusercontent.com/36947860/74907723-e656ee00-53ee-11ea-901b-9aa5cd678057.png" data-fancybox="group" data-caption="微信截图_20200215225156" class="fancybox"><img alt="微信截图_20200215225156" data-src="https://user-images.githubusercontent.com/36947860/74907723-e656ee00-53ee-11ea-901b-9aa5cd678057.png" class="lazyload" title="微信截图_20200215225156"></a></p><p>根据我们上一篇博客对梯度的介绍，可以看出(u,v)就是点(a,b)处的梯度。</p><p>我们的目标就是最小化损失函数L(θ)，L(θ)=常量+点积。当点积(u,v)(θ1-a,θ2-b)最小时，有(θ1-a,θ2-b)和(u,v)反向，且(θ1-a,θ2-b)的模为η。</p><p>所以有<a href="https://user-images.githubusercontent.com/36947860/74907727-e6ef8480-53ee-11ea-9190-03a716783c15.png" data-fancybox="group" data-caption="微信截图_20200215230954" class="fancybox"><img alt="微信截图_20200215230954" style="zoom:80%;" data-src="https://user-images.githubusercontent.com/36947860/74907727-e6ef8480-53ee-11ea-9190-03a716783c15.png" class="lazyload" title="微信截图_20200215230954"></a>，即<a href="https://user-images.githubusercontent.com/36947860/74907728-e7881b00-53ee-11ea-8a0b-97fc90df633f.png" data-fancybox="group" data-caption="微信截图_20200215231128" class="fancybox"><img alt="微信截图_20200215231128" style="zoom:80%;" data-src="https://user-images.githubusercontent.com/36947860/74907728-e7881b00-53ee-11ea-8a0b-97fc90df633f.png" class="lazyload" title="微信截图_20200215231128"></a></p><h2 id="批梯度下降法和随机梯度下降法"><a href="#批梯度下降法和随机梯度下降法" class="headerlink" title="批梯度下降法和随机梯度下降法"></a>批梯度下降法和随机梯度下降法</h2><h3 id="批梯度下降法"><a href="#批梯度下降法" class="headerlink" title="批梯度下降法"></a>批梯度下降法</h3><p>假设现在有10个数据样本，依次将这10个数据输入神经网络，依次计算出每个数据输入后的w的梯度，总共算出10个梯度，将这10个梯度累加，得到1个梯度。利用该梯度对w进行更新。</p><h3 id="随机梯度下降法"><a href="#随机梯度下降法" class="headerlink" title="随机梯度下降法"></a>随机梯度下降法</h3><p>假设现在有10个数据样本，将一个数据输入网络，计算出w的梯度，立即利用该梯度对w进行更新，重复10次。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>批梯度下降和随机梯度下降过程中，前向传播和反向传播的次数没有变化，每一个数据都要进行前向传播和反向传播。不同之处在于，批梯度下降要等所有数据的反向传播完成后，累加所有梯度，再对w进行更新。而随机梯度下降每次有一个数据反向传播完成，就立即利用该次反向传播得到的梯度对w进行更新。</p><hr><p><strong>Q: 假如一个批梯度下降的批是2，那么批一次之后的模型，和利用随机梯度下降法下降两次之后的模型一样吗？</strong></p><p>A: 不一样。假设未进行梯度下降之前的模型是模型M1，批梯度下降在计算第一个数据的梯度时，利用的是模型M1，计算 第二个模型的梯度时，利用的还是模型M1。而随机梯度下降法先根据模型M1得到第一个数据的梯度，进行更新后，得到模型M2，再利用模型M2，计算第二个数据的梯度。所以在都经过两个数据后，批梯度下降法利用了一个模型，随机梯度下降法利用了两个模型，所以得到的新模型不一样。</p></body></html>]]></content>
      
      
      <categories>
          
          <category> 机器学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Git常用操作整合</title>
      <link href="/2020/02/02/git%E6%8E%A8%E9%80%81%E6%96%87%E4%BB%B6/"/>
      <url>/2020/02/02/git%E6%8E%A8%E9%80%81%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<html><head><link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script></head><body><p>github远程托管文件 非常的方便。git操作种比较多的就是本地文件推送到远程，仓库等。而我一直也是没有搞明白，github本地文件远程推送是如何操作的，以至于今天卡了很久，来记录一下。</p><p><a href="https://user-images.githubusercontent.com/36947860/109246170-b79eff00-781c-11eb-9457-6759875d5846.jpg" data-fancybox="group" data-caption="git" class="fancybox"><img alt="git" data-src="https://user-images.githubusercontent.com/36947860/109246170-b79eff00-781c-11eb-9457-6759875d5846.jpg" class="lazyload" title="git"></a></p><h2 id="git推送本地文件"><a href="#git推送本地文件" class="headerlink" title="git推送本地文件"></a>git推送本地文件</h2><h3 id="一般流程"><a href="#一般流程" class="headerlink" title="一般流程"></a>一般流程</h3><p><strong>Note </strong>:  默认远程仓库是空的</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.新建远程仓库 ，这个可以自己去查阅，很容易</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.把本地需要推送的文件夹设置为git仓库</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.添加文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.提交文件</span></span><br><span class="line">git commit -m <span class="string">'first_commit'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.添加镜像源</span></span><br><span class="line">git remote add origin https://github.com/fryddup/fryddup.github.io.git</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6.推送文件</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure></div><h3 id="同步问题"><a href="#同步问题" class="headerlink" title="同步问题"></a>同步问题</h3><p>以上代码即可实现本地文件推送到远程，但是注意当仓库不是空的，仓库有改动，应当如下操作：</p><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'first_commit'</span></span><br><span class="line"></span><br><span class="line">git pull  <span class="comment">#注意，此命令即是远程文件同步到本地。</span></span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></tbody></table></figure></div><h2 id="git-代理相关"><a href="#git-代理相关" class="headerlink" title="git 代理相关"></a>git 代理相关</h2><h3 id="设置代理"><a href="#设置代理" class="headerlink" title="设置代理"></a>设置代理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global http.proxy <span class="string">'socks5://127.0.0.1:根据vpn选择端口号'</span> </span><br><span class="line">git config --global https.proxy <span class="string">'socks5://127.0.0.1:根据vpn选择端口号'</span></span><br></pre></td></tr></tbody></table></figure></div><p>git代理设置相关的东西,实际上应该根据自己的vpn选择开哪一种代理。<code>ssr</code>用sock5代理是可以的，但是<code>clash</code> 需设置成http代理。代理的端口号要根据vpn来设置，并不是通用的。</p><h3 id="查看代理"><a href="#查看代理" class="headerlink" title="查看代理"></a>查看代理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br></pre></td></tr></tbody></table></figure></div><h3 id="取消代理"><a href="#取消代理" class="headerlink" title="取消代理"></a>取消代理</h3><div class="code-area-wrap"><div class="highlight-tools"><i class="fa fa-angle-down code-expand" aria-hidden="true"></i><div class="code_lang">bash</div><div class="copy-notice"></div><i class="fa fa-clipboard" aria-hidden="true"></i></div><figure class="highlight bash"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></tbody></table></figure></div></body></html>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
